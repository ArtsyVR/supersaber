/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 199);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(19);
var hide = __webpack_require__(11);
var redefine = __webpack_require__(12);
var ctx = __webpack_require__(20);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(67)('wks');
var uid = __webpack_require__(41);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var IE8_DOM_DEFINE = __webpack_require__(111);
var toPrimitive = __webpack_require__(26);
var dP = Object.defineProperty;

exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(25);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(23);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(7);
var createDesc = __webpack_require__(37);
module.exports = __webpack_require__(6) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var has = __webpack_require__(14);
var SRC = __webpack_require__(41)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(19).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var fails = __webpack_require__(3);
var defined = __webpack_require__(23);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(50);
var createDesc = __webpack_require__(37);
var toIObject = __webpack_require__(17);
var toPrimitive = __webpack_require__(26);
var has = __webpack_require__(14);
var IE8_DOM_DEFINE = __webpack_require__(111);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(14);
var toObject = __webpack_require__(9);
var IE_PROTO = __webpack_require__(88)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(49);
var defined = __webpack_require__(23);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(10);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(3);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(20);
var IObject = __webpack_require__(49);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(8);
var asc = __webpack_require__(73);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(19);
var fails = __webpack_require__(3);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(4);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(132);
var $export = __webpack_require__(0);
var shared = __webpack_require__(67)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(135))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(6)) {
  var LIBRARY = __webpack_require__(30);
  var global = __webpack_require__(2);
  var fails = __webpack_require__(3);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(69);
  var $buffer = __webpack_require__(94);
  var ctx = __webpack_require__(20);
  var anInstance = __webpack_require__(32);
  var propertyDesc = __webpack_require__(37);
  var hide = __webpack_require__(11);
  var redefineAll = __webpack_require__(38);
  var toInteger = __webpack_require__(25);
  var toLength = __webpack_require__(8);
  var toIndex = __webpack_require__(130);
  var toAbsoluteIndex = __webpack_require__(40);
  var toPrimitive = __webpack_require__(26);
  var has = __webpack_require__(14);
  var classof = __webpack_require__(48);
  var isObject = __webpack_require__(4);
  var toObject = __webpack_require__(9);
  var isArrayIter = __webpack_require__(80);
  var create = __webpack_require__(34);
  var getPrototypeOf = __webpack_require__(16);
  var gOPN = __webpack_require__(35).f;
  var getIterFn = __webpack_require__(96);
  var uid = __webpack_require__(41);
  var wks = __webpack_require__(5);
  var createArrayMethod = __webpack_require__(22);
  var createArrayIncludes = __webpack_require__(56);
  var speciesConstructor = __webpack_require__(68);
  var ArrayIterators = __webpack_require__(97);
  var Iterators = __webpack_require__(43);
  var $iterDetect = __webpack_require__(62);
  var setSpecies = __webpack_require__(39);
  var arrayFill = __webpack_require__(72);
  var arrayCopyWithin = __webpack_require__(103);
  var $DP = __webpack_require__(7);
  var $GOPD = __webpack_require__(15);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(5)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(11)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(41)('meta');
var isObject = __webpack_require__(4);
var has = __webpack_require__(14);
var setDesc = __webpack_require__(7).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(3)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(20);
var call = __webpack_require__(114);
var isArrayIter = __webpack_require__(80);
var anObject = __webpack_require__(1);
var toLength = __webpack_require__(8);
var getIterFn = __webpack_require__(96);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(1);
var dPs = __webpack_require__(120);
var enumBugKeys = __webpack_require__(76);
var IE_PROTO = __webpack_require__(88)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(75)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(78).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(122);
var hiddenKeys = __webpack_require__(76).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(122);
var enumBugKeys = __webpack_require__(76);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(12);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var dP = __webpack_require__(7);
var DESCRIPTORS = __webpack_require__(6);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(25);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 41 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
};


/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(7).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(5)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var defined = __webpack_require__(23);
var fails = __webpack_require__(3);
var spaces = __webpack_require__(92);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 47 */
/***/ (function(module, exports) {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};



/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(18);
var TAG = __webpack_require__(5)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(18);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 50 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(402);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ');

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 52 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file hosts our error definitions
// We use custom error "types" so that we can act on them when we need it
// e.g.: if error instanceof errors.UnparsableJSON then..

var inherits = __webpack_require__(136);

function AlgoliaSearchError(message, extraProperties) {
  var forEach = __webpack_require__(47);

  var error = this;

  // try to get a stacktrace
  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, this.constructor);
  } else {
    error.stack = (new Error()).stack || 'Cannot get a stacktrace, browser is too old';
  }

  this.name = 'AlgoliaSearchError';
  this.message = message || 'Unknown error';

  if (extraProperties) {
    forEach(extraProperties, function addToErrorObject(value, key) {
      error[key] = value;
    });
  }
}

inherits(AlgoliaSearchError, Error);

function createCustomError(name, message) {
  function AlgoliaSearchCustomError() {
    var args = Array.prototype.slice.call(arguments, 0);

    // custom message not set, use default
    if (typeof args[0] !== 'string') {
      args.unshift(message);
    }

    AlgoliaSearchError.apply(this, args);
    this.name = 'AlgoliaSearch' + name + 'Error';
  }

  inherits(AlgoliaSearchCustomError, AlgoliaSearchError);

  return AlgoliaSearchCustomError;
}

// late exports to let various fn defs and inherits take place
module.exports = {
  AlgoliaSearchError: AlgoliaSearchError,
  UnparsableJSON: createCustomError(
    'UnparsableJSON',
    'Could not parse the incoming response as JSON, see err.more for details'
  ),
  RequestTimeout: createCustomError(
    'RequestTimeout',
    'Request timedout before getting a response'
  ),
  Network: createCustomError(
    'Network',
    'Network issue, see err.more for details'
  ),
  JSONPScriptFail: createCustomError(
    'JSONPScriptFail',
    '<script> was loaded but did not call our provided callback'
  ),
  JSONPScriptError: createCustomError(
    'JSONPScriptError',
    '<script> unable to load due to an `error` event on it'
  ),
  Unknown: createCustomError(
    'Unknown',
    'Unknown error occured'
  )
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var foreach = __webpack_require__(47);

module.exports = function map(arr, fn) {
  var newArr = [];
  foreach(arr, function(item, itemIndex) {
    newArr.push(fn(item, itemIndex, arr));
  });
  return newArr;
};


/***/ }),
/* 55 */
/***/ (function(module, exports) {

var BASE_URL = 'https://s3-us-west-2.amazonaws.com/supersaber';

function getS3FileUrl(id, name) {
  return `${BASE_URL}/${id}-${name}`;
}
module.exports.getS3FileUrl = getS3FileUrl;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(17);
var toLength = __webpack_require__(8);
var toAbsoluteIndex = __webpack_require__(40);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var redefineAll = __webpack_require__(38);
var meta = __webpack_require__(31);
var forOf = __webpack_require__(33);
var anInstance = __webpack_require__(32);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var $iterDetect = __webpack_require__(62);
var setToStringTag = __webpack_require__(44);
var inheritIfRequired = __webpack_require__(79);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(11);
var redefine = __webpack_require__(12);
var fails = __webpack_require__(3);
var defined = __webpack_require__(23);
var wks = __webpack_require__(5);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(18);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(4);
var cof = __webpack_require__(18);
var MATCH = __webpack_require__(5)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(5)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(30) || !__webpack_require__(3)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete __webpack_require__(2)[K];
});


/***/ }),
/* 64 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var ctx = __webpack_require__(20);
var forOf = __webpack_require__(33);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(19);
var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(30) ? 'pure' : 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var SPECIES = __webpack_require__(5)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var uid = __webpack_require__(41);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(40);
var toLength = __webpack_require__(8);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(203);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(7);
var createDesc = __webpack_require__(37);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(5)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var setPrototypeOf = __webpack_require__(87).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(43);
var ITERATOR = __webpack_require__(5)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(34);
var descriptor = __webpack_require__(37);
var setToStringTag = __webpack_require__(44);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(11)(IteratorPrototype, __webpack_require__(5)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(30);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var hide = __webpack_require__(11);
var Iterators = __webpack_require__(43);
var $iterCreate = __webpack_require__(81);
var setToStringTag = __webpack_require__(44);
var getPrototypeOf = __webpack_require__(16);
var ITERATOR = __webpack_require__(5)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 83 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 84 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(93).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(18)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(10);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(20)(Function.call, __webpack_require__(15).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(67)('keys');
var uid = __webpack_require__(41);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(25);
var defined = __webpack_require__(23);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(61);
var defined = __webpack_require__(23);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(25);
var defined = __webpack_require__(23);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(20);
var invoke = __webpack_require__(112);
var html = __webpack_require__(78);
var cel = __webpack_require__(75);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(18)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var DESCRIPTORS = __webpack_require__(6);
var LIBRARY = __webpack_require__(30);
var $typed = __webpack_require__(69);
var hide = __webpack_require__(11);
var redefineAll = __webpack_require__(38);
var fails = __webpack_require__(3);
var anInstance = __webpack_require__(32);
var toInteger = __webpack_require__(25);
var toLength = __webpack_require__(8);
var toIndex = __webpack_require__(130);
var gOPN = __webpack_require__(35).f;
var dP = __webpack_require__(7).f;
var arrayFill = __webpack_require__(72);
var setToStringTag = __webpack_require__(44);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(19);
var LIBRARY = __webpack_require__(30);
var wksExt = __webpack_require__(131);
var defineProperty = __webpack_require__(7).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(48);
var ITERATOR = __webpack_require__(5)('iterator');
var Iterators = __webpack_require__(43);
module.exports = __webpack_require__(19).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(29);
var step = __webpack_require__(115);
var Iterators = __webpack_require__(43);
var toIObject = __webpack_require__(17);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(82)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 98 */
/***/ (function(module, exports) {

/* global AFRAME */

/*
 * Provides a simple API for creating decorator functions which you can apply to your Component definitions.
 * These decorated functions are executed when their Component is instantiated, and have their 'this' attribute set
 * to the new Component.
 *
 * Decorators should only be used on functions that are owned by Component descriptors registered with
 * AFRAME.registerComponent. Decorating any other function will have no effect, as the decorator
 * functor will never be executed.
 */

/*
 * Decorates a function with a functor that is executed in the context of each instantiated Component which owns it.
 *
 * @param func - Function to decorate.
 * @param decoratorFunc - Functor which decorates func. It's definition should appear like this:
 *    function decoratorFunctor(funcPropertyName) {
 *      const func = this[funcPropertyName]; // 'this' is assigned to the instantiated Component.
 *      // Decorator should return a function
 *      return () => {
 *        console.log(this.el.id + " has a decorated function!");
 *        return func.apply(this, arguments);
 *      }
 *    }
 *
 * @returns A pending decorated functor which will be executed when a component that owns it is instantiated.
 */
function decorate(func, decoratorFunc) {
  return decorations.add(func, decoratorFunc);
}

// Helper for storing and retrieving decorator functors for a given function.
const decorations = (function() {
  const funcMap = new WeakMap();

  function add(func, decorator) {
    const parent = funcMap.has(func) ? func : undefined; // In case decorators are nested.
    const decoratedFunc = function() {
      func.apply(this, arguments);
    }
    funcMap.set(decoratedFunc, {parent: parent, decorator: decorator});
    return decoratedFunc;
  }

  function getAll(func) {
    var iter = funcMap.get(func);
    var decorators = [];
    while (iter !== undefined) {
      decorators.push(iter.decorator);
      iter = iter.parent;
    }
    return decorators;
  }

  function isFunctionDecorated(func) {
    return funcMap.has(func);
  }

  return {
    add: add,
    getAll: getAll,
    isFunctionDecorated: isFunctionDecorated
  }
})();

// Here I'm wrapping the AFRAME.registerComponent function and also each Component constructor. Whenever a new component
// is instantiated I'm scanning its list of properties for any functions which have been decorated. Each decoration
// functor will then be executed in the context of the component which owns the function.
(function() {
  Object.keys(AFRAME.components).forEach( function(c) {
    wrapComponent(c)
  });
  wrapRegister();

  function executeDecoratorsOnNewComponent(component) {
    const prot = Object.getPrototypeOf(component);
    Object.getOwnPropertyNames(prot).forEach( function(name) {
      const prop = prot[name];
      if (typeof prop === "function" && decorations.isFunctionDecorated(prop)) {
        decorations.getAll(prop).forEach(function(decorator) {
          component[name] = decorator.call(component, name, prop);
        });
      }
    });
  }

  function wrapComponent(name) {
    const orig = AFRAME.components[name].Component;

    AFRAME.components[name].Component = function() {
      // Override init on the instance to execute the decorator functors before initializing.
      this.init = function() {
        delete this.init;
        executeDecoratorsOnNewComponent(this);
        this.init.apply(this, arguments);
      }
      orig.apply(this, arguments);
    }
    AFRAME.components[name].Component.prototype = orig.prototype;
  }

  function wrapRegister() {
    const origRegister = AFRAME.registerComponent;
    AFRAME.registerComponent = function(name) {
      origRegister.apply(AFRAME, arguments);
      return wrapComponent(name);
    }
  }
})();

module.exports.decorate = decorate;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

/* global AFRAME */

if (typeof AFRAME === 'undefined') {
  throw new Error('aframe-event-decorators was loaded before AFRAME was available');
}

const eventBinder = __webpack_require__(154);
const decorate = __webpack_require__(98).decorate;

module.exports.bindEvent = eventBinder.bindEvent;
module.exports.bindEventPlayPause = eventBinder.bindEventPlayPause;
module.exports.decorate = decorate;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = buildSearchMethod;

var errors = __webpack_require__(53);

/**
 * Creates a search method to be used in clients
 * @param {string} queryParam the name of the attribute used for the query
 * @param {string} url the url
 * @return {function} the search method
 */
function buildSearchMethod(queryParam, url) {
  /**
   * The search method. Prepares the data and send the query to Algolia.
   * @param {string} query the string used for query search
   * @param {object} args additional parameters to send with the search
   * @param {function} [callback] the callback to be called with the client gets the answer
   * @return {undefined|Promise} If the callback is not provided then this methods returns a Promise
   */
  return function search(query, args, callback) {
    // warn V2 users on how to search
    if (typeof query === 'function' && typeof args === 'object' ||
      typeof callback === 'object') {
      // .search(query, params, cb)
      // .search(cb, params)
      throw new errors.AlgoliaSearchError('index.search usage is index.search(query, params, cb)');
    }

    // Normalizing the function signature
    if (arguments.length === 0 || typeof query === 'function') {
      // Usage : .search(), .search(cb)
      callback = query;
      query = '';
    } else if (arguments.length === 1 || typeof args === 'function') {
      // Usage : .search(query/args), .search(query, cb)
      callback = args;
      args = undefined;
    }
    // At this point we have 3 arguments with values

    // Usage : .search(args) // careful: typeof null === 'object'
    if (typeof query === 'object' && query !== null) {
      args = query;
      query = undefined;
    } else if (query === undefined || query === null) { // .search(undefined/null)
      query = '';
    }

    var params = '';

    if (query !== undefined) {
      params += queryParam + '=' + encodeURIComponent(query);
    }

    var additionalUA;
    if (args !== undefined) {
      if (args.additionalUA) {
        additionalUA = args.additionalUA;
        delete args.additionalUA;
      }
      // `_getSearchParams` will augment params, do not be fooled by the = versus += from previous if
      params = this.as._getSearchParams(args, params);
    }


    return this._search(params, url, callback, additionalUA);
  };
}


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function omit(obj, test) {
  var keys = __webpack_require__(405);
  var foreach = __webpack_require__(47);

  var filtered = {};

  foreach(keys(obj), function doFilter(keyName) {
    if (test(keyName) !== true) {
      filtered[keyName] = obj[keyName];
    }
  });

  return filtered;
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(18);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(40);
var toLength = __webpack_require__(8);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(33);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(49);
var toLength = __webpack_require__(8);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(10);
var isObject = __webpack_require__(4);
var invoke = __webpack_require__(112);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(7).f;
var create = __webpack_require__(34);
var redefineAll = __webpack_require__(38);
var ctx = __webpack_require__(20);
var anInstance = __webpack_require__(32);
var forOf = __webpack_require__(33);
var $iterDefine = __webpack_require__(82);
var step = __webpack_require__(115);
var setSpecies = __webpack_require__(39);
var DESCRIPTORS = __webpack_require__(6);
var fastKey = __webpack_require__(31).fastKey;
var validate = __webpack_require__(46);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(48);
var from = __webpack_require__(104);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(38);
var getWeak = __webpack_require__(31).getWeak;
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var anInstance = __webpack_require__(32);
var forOf = __webpack_require__(33);
var createArrayMethod = __webpack_require__(22);
var $has = __webpack_require__(14);
var validate = __webpack_require__(46);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(60);
var isObject = __webpack_require__(4);
var toLength = __webpack_require__(8);
var ctx = __webpack_require__(20);
var IS_CONCAT_SPREADABLE = __webpack_require__(5)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(6) && !__webpack_require__(3)(function () {
  return Object.defineProperty(__webpack_require__(75)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 112 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(4);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(84);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 117 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 118 */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(36);
var gOPS = __webpack_require__(64);
var pIE = __webpack_require__(50);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(49);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(7);
var anObject = __webpack_require__(1);
var getKeys = __webpack_require__(36);

module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(17);
var gOPN = __webpack_require__(35).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(14);
var toIObject = __webpack_require__(17);
var arrayIndexOf = __webpack_require__(56)(false);
var IE_PROTO = __webpack_require__(88)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(36);
var toIObject = __webpack_require__(17);
var isEnum = __webpack_require__(50).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(35);
var gOPS = __webpack_require__(64);
var anObject = __webpack_require__(1);
var Reflect = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat;
var $trim = __webpack_require__(45).trim;

module.exports = 1 / $parseFloat(__webpack_require__(92) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt;
var $trim = __webpack_require__(45).trim;
var ws = __webpack_require__(92);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var newPromiseCapability = __webpack_require__(86);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(8);
var repeat = __webpack_require__(91);
var defined = __webpack_require__(23);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(25);
var toLength = __webpack_require__(8);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(5);


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(107);
var validate = __webpack_require__(46);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(57)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(6) && /./g.flags != 'g') __webpack_require__(7).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(59)
});


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(107);
var validate = __webpack_require__(46);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(57)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(22)(0);
var redefine = __webpack_require__(12);
var meta = __webpack_require__(31);
var assign = __webpack_require__(119);
var weak = __webpack_require__(109);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var validate = __webpack_require__(46);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(57)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 136 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 137 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* global AFRAME, THREE */

var anime = __webpack_require__(171);

AFRAME.anime = anime;

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

var colorHelperFrom = new THREE.Color();
var colorHelperTo = new THREE.Color();

var utils = AFRAME.utils;
var getComponentProperty = utils.entity.getComponentProperty;
var setComponentProperty = utils.entity.setComponentProperty;
var splitCache = {};

var TYPE_COLOR = 'color';
var PROP_POSITION = 'position';
var PROP_ROTATION = 'rotation';
var PROP_SCALE = 'scale';
var STRING_COMPONENTS = 'components';
var STRING_OBJECT3D = 'object3D';

/**
 * Animation component for A-Frame using anime.js.
 *
 * The component manually controls the tick by setting `autoplay: false` on anime.js and
 * manually * calling `animation.tick()` in the tick handler. To pause or resume, we toggle a
 * boolean * flag * `isAnimationPlaying`.
 *
 * anime.js animation config for tweenining Javascript objects and values works as:
 *
 *  config = {
 *    targets: {foo: 0.0, bar: '#000'},
 *    foo: 1.0,
 *    bar: '#FFF'
 *  }
 *
 * The above will tween each property in `targets`. The `to` values are set in the root of
 * the config.
 *
 * @member {object} animation - anime.js instance.
 * @member {boolean} animationIsPlaying - Control if animation is playing.
 */
AFRAME.registerComponent('animation', {
  schema: {
    autoplay: {default: true},
    delay: {default: 0},
    dir: {default: ''},
    dur: {default: 1000},
    easing: {default: 'easeInQuad'},
    elasticity: {default: 400},
    enabled: {default: true},
    from: {default: ''},
    loop: {
      default: 0,
      parse: function (value) {
        // Boolean or integer.
        if (value === true || value === 'true') { return true; }
        if (value === false || value === 'false') { return false; }
        return parseInt(value, 10);
      }
    },
    property: {default: ''},
    startEvents: {type: 'array'},
    pauseEvents: {type: 'array'},
    resumeEvents: {type: 'array'},
    to: {default: ''},
    type: {default: ''},
    isRawProperty: {default: false}
  },

  multiple: true,

  init: function () {
    var self = this;

    this.eventDetail = {name: this.attrName};
    this.time = 0;

    this.animation = null;
    this.animationIsPlaying = false;
    this.onStartEvent = this.onStartEvent.bind(this);
    this.beginAnimation = this.beginAnimation.bind(this);
    this.pauseAnimation = this.pauseAnimation.bind(this);
    this.resumeAnimation = this.resumeAnimation.bind(this);

    this.fromColor = {};
    this.toColor = {};
    this.targets = {};
    this.targetsArray = [];

    this.updateConfigForDefault = this.updateConfigForDefault.bind(this);
    this.updateConfigForRawColor = this.updateConfigForRawColor.bind(this);

    this.config = {
      complete: function () {
        self.animationIsPlaying = false;
        self.el.emit('animationcomplete', self.eventDetail);
      }
    };
  },

  update: function (oldData) {
    var config = this.config;
    var data = this.data;

    this.animationIsPlaying = false;

    if (oldData.enabled && !this.data.enabled) {
      this.animationIsPlaying = false;
      return;
    }

    if (!data.property) { return; }

    // Base config.
    config.autoplay = false;
    config.direction = data.dir;
    config.duration = data.dur;
    config.easing = data.easing;
    config.elasticity = data.elasticity;
    config.loop = data.loop;

    // Start new animation.
    this.createAndStartAnimation();
  },

  tick: function (t, dt) {
    if (!this.animationIsPlaying) { return; }
    this.time += dt;
    this.animation.tick(this.time);
  },

  remove: function () {
    this.pauseAnimation();
    this.removeEventListeners();
  },

  pause: function () {
    this.paused = true;
    this.pausedWasPlaying = this.animationIsPlaying;
    this.pauseAnimation();
    this.removeEventListeners();
  },

  /**
   * `play` handler only for resuming scene.
   */
  play: function () {
    if (!this.paused) { return; }
    this.paused = false;
    this.addEventListeners();
    if (this.pausedWasPlaying) {
      this.resumeAnimation();
      this.pausedWasPlaying = false;
    }
  },

  /**
   * Start animation from scratch.
   */
  createAndStartAnimation: function () {
    var data = this.data;

    this.updateConfig();
    this.animationIsPlaying = false;
    this.animation = anime(this.config);

    this.removeEventListeners();
    this.addEventListeners();

    // Wait for start events for animation.
    if (!data.autoplay || data.startEvents && data.startEvents.length) { return; }

    // Delay animation.
    if (data.delay) {
      setTimeout(this.beginAnimation, data.delay);
      return;
    }

    // Play animation.
    this.beginAnimation();
  },

  /**
   * This is before animation start (including from startEvents).
   * Set to initial state (config.from, time = 0, seekTime = 0).
   */
  beginAnimation: function () {
    this.updateConfig();
    this.time = 0;
    this.animationIsPlaying = true;
    this.stopRelatedAnimations();
    this.el.emit('animationbegin', this.eventDetail);
  },

  pauseAnimation: function () {
    this.animationIsPlaying = false;
  },

  resumeAnimation: function () {
    this.animationIsPlaying = true;
  },

  /**
   * startEvents callback.
   */
  onStartEvent: function () {
    if (!this.data.enabled) { return; }

    this.updateConfig();
    if (this.animation) {
      this.animation.pause();
    }
    this.animation = anime(this.config);

    // Include the delay before each start event.
    if (this.data.delay) {
      setTimeout(this.beginAnimation, this.data.delay);
      return;
    }
    this.beginAnimation();
  },

  /**
   * rawProperty: true and type: color;
   */
  updateConfigForRawColor: function () {
    var config = this.config;
    var data = this.data;
    var el = this.el;
    var from;
    var key;
    var to;

    if (this.waitComponentInitRawProperty(this.updateConfigForRawColor)) {
      return;
    }

    from = data.from || getRawProperty(el, data.property);
    to = data.to;

    // Use r/g/b vector for color type.
    this.setColorConfig(from, to);
    from = this.fromColor;
    to = this.toColor;

    this.targetsArray.length = 0;
    this.targetsArray.push(from);
    config.targets = this.targetsArray;
    for (key in to) { config[key] = to[key]; }

    config.update = (function () {
      var lastValue = {};
      lastValue.r = from.r;
      lastValue.g = from.g;
      lastValue.b = from.b;

      return function (anim) {
        var value;
        value = anim.animatables[0].target;
        // For animation timeline.
          if (value.r === lastValue.r &&
              value.g === lastValue.g &&
              value.b === lastValue.b) { return; }

        setRawProperty(el, data.property, value, data.type);
      };
    })();
  },

  /**
   * Stuff property into generic `property` key.
   */
  updateConfigForDefault: function () {
    var config = this.config;
    var data = this.data;
    var el = this.el;
    var from;
    var key;
    var isBoolean;
    var isNumber;
    var to;

    if (this.waitComponentInitRawProperty(this.updateConfigForDefault)) {
      return;
    }

    from = data.from || (
      isRawProperty(data)
        ? getRawProperty(el, data.property)
        : getComponentProperty(el, data.property)
    );
    to = data.to;

    isNumber = !isNaN(from || to);
    if (isNumber) {
      from = parseFloat(from);
      to = parseFloat(to);
    } else {
      from = from ? from.toString() : from;
      to = to ? to.toString() : to;
    }

    // Convert booleans to integer to allow boolean flipping.
    isBoolean = to === 'true' || to === 'false';
    if (isBoolean) {
      from = data.from === 'true' ? 1 : 0;
      to = data.to === 'true' ? 1 : 0;
    }

    this.targets.aframeProperty = from;
    config.targets = this.targets;
    config.aframeProperty = to;
    config.update = (function () {
      var lastValue = from;
      return function (anim) {
        var value;
        value = anim.animatables[0].target.aframeProperty;

        // Need to do a last value check for animation timeline since all the tweening
        // begins simultaenously even if the value has not changed. Also better for perf
        // anyways.
        if (value === lastValue) { return; }
        lastValue = value;

        if (isBoolean) {
          value = value >= 1 ? true : false;
        }

        if (isRawProperty(data)) {
          setRawProperty(el, data.property, value, data.type);
        } else {
          setComponentProperty(el, data.property, value);
        }
      };
    })();
  },

  /**
   * Extend x/y/z/w onto the config.
   * Update vector by modifying object3D.
   */
  updateConfigForVector: function () {
    var config = this.config;
    var data = this.data;
    var el = this.el;
    var key;
    var from;
    var to;

    // Parse coordinates.
    from = data.from
      ? AFRAME.utils.coordinates.parse(data.from)  // If data.from defined, use that.
      : getComponentProperty(el, data.property);  // If data.from not defined, get on the fly.
    to = AFRAME.utils.coordinates.parse(data.to);

    // Animate rotation through radians.
    if (data.property === PROP_ROTATION) {
      toRadians(from);
      toRadians(to);
    }

    // Set to and from.
    this.targetsArray.length = 0;
    this.targetsArray.push(from);
    config.targets = this.targetsArray;
    for (key in to) { config[key] = to[key]; }

    // If animating object3D transformation, run more optimized updater.
    if (data.property === PROP_POSITION || data.property === PROP_ROTATION ||
        data.property === PROP_SCALE) {
      config.update = (function () {
        var lastValue = {};
        lastValue.x = from.x;
        lastValue.y = from.y;
        lastValue.z = from.z;

        return function (anim) {
          var value = anim.animatables[0].target;
          // For animation timeline.
          if (value.x === lastValue.x &&
              value.y === lastValue.y &&
              value.z === lastValue.z) { return; }
          lastValue.x = value.x;
          lastValue.y = value.y;
          lastValue.z = value.z;
          el.object3D[data.property].set(value.x, value.y, value.z);
        };
      })();
      return;
    }

    // Animating some vector.
    config.update = (function () {
      var lastValue = {};
      lastValue.x = from.x;
      lastValue.y = from.y;
      lastValue.z = from.z;

      return function (anim) {
        var value = anim.animations[0].target;
        // For animation timeline.
        if (value.x === lastValue.x &&
            value.y === lastValue.y &&
            value.z === lastValue.z) { return; }
        lastValue.x = value.x;
        lastValue.y = value.y;
        lastValue.z = value.z;
        setComponentProperty(el, data.property, value);
      }
    })();
  },

  /**
   * Update the config before each run.
   */
  updateConfig: function () {
    var propType;

    // Route config type.
    propType = getPropertyType(this.el, this.data.property);
    if (isRawProperty(this.data) && this.data.type === TYPE_COLOR) {
      this.updateConfigForRawColor();
    } else if (propType === 'vec2' || propType === 'vec3' || propType === 'vec4') {
      this.updateConfigForVector();
    } else {
      this.updateConfigForDefault();
    }
  },

  /**
   * Wait for component to initialize.
   */
  waitComponentInitRawProperty: function (cb) {
    var componentName;
    var data = this.data;
    var el = this.el;
    var self = this;

    if (data.from) { return false; }

    if (!data.property.startsWith(STRING_COMPONENTS)) { return false; }

    componentName = splitDot(data.property)[1];
    if (el.components[componentName]) { return false; }

    el.addEventListener('componentinitialized', function wait (evt) {
      if (evt.detail.name !== componentName) { return; }
      cb();
      // Since the config was created async, create the animation now since we missed it
      // earlier.
      self.animation = anime(self.config);
      el.removeEventListener('componentinitialized', wait);
    });
    return true;
  },

  /**
   * Make sure two animations on the same property don't fight each other.
   * e.g., animation__mouseenter="property: material.opacity"
   *       animation__mouseleave="property: material.opacity"
   */
  stopRelatedAnimations: function () {
    var component;
    var componentName;
    for (componentName in this.el.components) {
      component = this.el.components[componentName];
      if (componentName === this.attrName) { continue; }
      if (component.name !== 'animation') { continue; }
      if (!component.animationIsPlaying) { continue; }
      if (component.data.property !== this.data.property) { continue; }
      component.animationIsPlaying = false;
    }
  },

  addEventListeners: function () {
    var data = this.data;
    var el = this.el;
    addEventListeners(el, data.startEvents, this.onStartEvent);
    addEventListeners(el, data.pauseEvents, this.pauseAnimation);
    addEventListeners(el, data.resumeEvents, this.resumeAnimation);
  },

  removeEventListeners: function () {
    var data = this.data;
    var el = this.el;
    removeEventListeners(el, data.startEvents, this.onStartEvent);
    removeEventListeners(el, data.pauseEvents, this.pauseAnimation);
    removeEventListeners(el, data.resumeEvents, this.resumeAnimation);
  },

  setColorConfig: function (from, to) {
    colorHelperFrom.set(from);
    colorHelperTo.set(to);
    from = this.fromColor;
    to = this.toColor;
    from.r = colorHelperFrom.r;
    from.g = colorHelperFrom.g;
    from.b = colorHelperFrom.b;
    to.r = colorHelperTo.r;
    to.g = colorHelperTo.g;
    to.b = colorHelperTo.b;
  }
});

/**
 * Given property name, check schema to see what type we are animating.
 * We just care whether the property is a vector.
 */
function getPropertyType (el, property) {
  var component;
  var componentName;
  var split;
  var propertyName;

  split = property.split('.');
  componentName = split[0];
  propertyName = split[1];
  component = el.components[componentName] || AFRAME.components[componentName];

  // Primitives.
  if (!component) { return null; }

  // Dynamic schema. We only care about vectors anyways.
  if (propertyName && !component.schema[propertyName]) { return null; }

  // Multi-prop.
  if (propertyName) { return component.schema[propertyName].type; }

  // Single-prop.
  return component.schema.type;
}

/**
 * Convert object to radians.
 */
function toRadians (obj) {
  obj.x = THREE.Math.degToRad(obj.x);
  obj.y = THREE.Math.degToRad(obj.y);
  obj.z = THREE.Math.degToRad(obj.z);
}

function addEventListeners (el, eventNames, handler) {
  var i;
  for (i = 0; i < eventNames.length; i++) {
    el.addEventListener(eventNames[i], handler);
  }
}

function removeEventListeners (el, eventNames, handler) {
  var i;
  for (i = 0; i < eventNames.length; i++) {
    el.removeEventListener(eventNames[i], handler);
  }
}

function getRawProperty (el, path) {
  var i;
  var split;
  var value;
  split = splitDot(path);
  value = el;
  for (i = 0; i < split.length; i++) {
    value = value[split[i]];
  }
  return value;
}

function setRawProperty (el, path, value, type) {
  var i;
  var split;
  var propertyName;
  var targetValue;

  // Walk.
  split = splitDot(path);
  targetValue = el;
  for (i = 0; i < split.length - 1; i++) { targetValue = targetValue[split[i]]; }
  propertyName = split[split.length - 1];

  // Raw color.
  if (type === TYPE_COLOR) {
    if ('r' in targetValue[propertyName]) {
      targetValue[propertyName].r = value.r;
      targetValue[propertyName].g = value.g;
      targetValue[propertyName].b = value.b;
    } else {
      targetValue[propertyName].x = value.r;
      targetValue[propertyName].y = value.g;
      targetValue[propertyName].z = value.b;
    }
    return;
  }

  targetValue[propertyName] = value;
}

function splitDot (path) {
  if (path in splitCache) { return splitCache[path]; }
  splitCache[path] = path.split('.');
  return splitCache[path];
}

function isRawProperty (data) {
  return data.isRawProperty || data.property.startsWith(STRING_COMPONENTS) ||
         data.property.startsWith(STRING_OBJECT3D);
}


/***/ }),
/* 139 */
/***/ (function(module, exports) {

/* global AFRAME, THREE */
if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

/**
 * Cubemap component for A-Frame.
 */
AFRAME.registerComponent('cubemap', {
  schema: {
    folder: {
      type: 'string'
    },
    edgeLength: {
      type: 'int',
      default: 5000
    },
    ext: {
      type: 'string',
      default: 'jpg'
    },
    transparent: {
      type: 'boolean',
      default: false
    }
  },

  /**
   * Called when component is attached and when component data changes.
   * Generally modifies the entity based on the data.
   */
  update: function (oldData) {
    // entity data
    var el = this.el;
    var data = this.data;

    // Path to the folder containing the 6 cubemap images
    var srcPath = data.folder;

    // Cubemap image files must follow this naming scheme
    // from: http://threejs.org/docs/index.html#Reference/Textures/CubeTexture
    var urls = [
      'posx', 'negx',
      'posy', 'negy',
      'posz', 'negz'
    ];
    // Apply extension
    urls = urls.map(function(val) {
      return val + "." + data.ext;
    });

    // Code that follows is adapted from "Skybox and environment map in Three.js" by Roman Liutikov
    // http://blog.romanliutikov.com/post/58705840698/skybox-and-environment-map-in-threejs

    var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib

    // Create shader material
    var skyBoxShader = new THREE.ShaderMaterial({
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: shader.uniforms,
      depthWrite: false,
      side: THREE.BackSide,
      transparent: data.transparent
    });

    // Set skybox dimensions
    var edgeLength = data.edgeLength;
    var skyBoxGeometry = new THREE.CubeGeometry(edgeLength, edgeLength, edgeLength);

    // Create loader, set folder path, and load cubemap textures
    var loader = new THREE.CubeTextureLoader();
    loader.setPath(srcPath);
    loader.load(urls, function(texture) {
      // Clone ShaderMaterial (necessary for multiple cubemaps)
      var skyBoxMaterial = skyBoxShader.clone();
      skyBoxMaterial.uniforms['tCube'].value = texture; // Apply cubemap textures to shader uniforms

      // Set entity's object3D
      el.setObject3D('cubemap', new THREE.Mesh(skyBoxGeometry, skyBoxMaterial));
    });

  },

  /**
   * Called when a component is removed (e.g., via removeAttribute).
   * Generally undoes all modifications to the entity.
   */
  remove: function () {
    this.el.removeObject3D('cubemap');
  }
});


/***/ }),
/* 140 */
/***/ (function(module, exports) {

/* global AFRAME */
var styleParser = AFRAME.utils.styleParser;

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

AFRAME.registerComponent('event-set', {
  schema: {
    default: '',
    parse: function (value) {
      return styleParser.parse(value);
    }
  },

  multiple: true,

  init: function () {
    this.eventHandler = null;
    this.eventName = null;
  },

  update: function (oldData) {
    this.removeEventListener();
    this.updateEventListener();
    this.addEventListener();
  },

  remove: function () {
    this.removeEventListener();
  },

  pause: function () {
    this.removeEventListener();
  },

  play: function () {
    this.addEventListener();
  },

  /**
   * Update source-of-truth event listener registry.
   * Does not actually attach event listeners yet.
   */
  updateEventListener: function () {
    var data = this.data;
    var el = this.el;
    var event;
    var target;
    var targetEl;

    // Set event listener using `_event`.
    event = data._event || this.id;
    target = data._target;

    // Decide the target to `setAttribute` on.
    targetEl = target ? el.sceneEl.querySelector(target) : el;

    this.eventName = event;
    this.eventHandler = function handler () {
      var propName;
      // Set attributes.
      for (propName in data) {
        if (propName === '_event' || propName === '_target') { continue; }
        AFRAME.utils.entity.setComponentProperty.call(this, targetEl, propName,
                                                      data[propName]);
      }
    };
  },

  addEventListener: function () {
    this.el.addEventListener(this.eventName, this.eventHandler);
  },

  removeEventListener: function () {
    this.el.removeEventListener(this.eventName, this.eventHandler);
  }
});


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/* global AFRAME */

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

/**
 * Haptics component for A-Frame.
 */
AFRAME.registerComponent('haptics', {
  dependencies: ['tracked-controls'],

  schema: {
    actuatorIndex: {default: 0},
    dur: {default: 100},
    enabled: {default: true},
    events: {type: 'array'},
    eventsFrom: {type: 'string'},
    force: {default: 1}
  },

  multiple: true,

  init: function () {
    var data = this.data;
    var i;
    var self = this;

    this.callPulse = function () { self.pulse(); };

    if (this.el.components['tracked-controls'].controller) {
      this.gamepad = this.el.components['tracked-controls'].controller;
      if (!this.gamepad || !this.gamepad.hapticActuators.length) { return; }
      this.addEventListeners();
    } else {
      this.el.addEventListener('controllerconnected', function init () {
        setTimeout(function () {
          self.gamepad = self.el.components['tracked-controls'].controller;
          if (!self.gamepad || !self.gamepad.hapticActuators.length) { return; }
          self.addEventListeners();
        }, 150);
      });
    }
  },

  remove: function () {
    this.removeEventListeners();
  },

  pulse: function (force, dur) {
    var actuator;
    var data = this.data;
    if (!data.enabled || !this.gamepad || !this.gamepad.hapticActuators) { return; }
    actuator = this.gamepad.hapticActuators[data.actuatorIndex];
    actuator.pulse(force || data.force, dur || data.dur);
  },

  addEventListeners: function () {
    var data = this.data;
    var i;
    var listenTarget;

    listenTarget = data.eventsFrom ? document.querySelector(data.eventsFrom) : this.el;
    for (i = 0; i < data.events.length; i++) {
      listenTarget.addEventListener(data.events[i], this.callPulse);
    }
  },

  removeEventListeners: function () {
    var data = this.data;
    var i;
    var listenTarget;

    listenTarget = data.eventsFrom ? document.querySelector(data.eventsFrom) : this.el;
    for (i = 0; i < data.events.length; i++) {
      listenTarget.removeEventListener(data.events[i], this.callPulse);
    }
  }
});


/***/ }),
/* 142 */
/***/ (function(module, exports) {

var positions = [];
var positionHelper = new THREE.Vector3();

/**
 * Layout component for A-Frame.
 * Some layouts adapted from http://www.vb-helper.com/tutorial_platonic_solids.html
 */
AFRAME.registerComponent('layout', {
  schema: {
    angle: {type: 'number', default: false, min: 0, max: 360, if: {type: ['circle']}},
    columns: {default: 1, min: 0, if: {type: ['box']}},
    margin: {default: 1, min: 0, if: {type: ['box', 'line']}},
    marginColumn: {default: 1, min: 0, if: {type: ['box']}},
    marginRow: {default: 1, min: 0, if: {type: ['box']}},
    orderAttribute: {default: ''},
    plane: {default: 'xy'},
    radius: {default: 1, min: 0, if: {type: ['circle', 'cube', 'dodecahedron', 'pyramid']}},
    reverse: {default: false},
    type: {default: 'line', oneOf: ['box', 'circle', 'cube', 'dodecahedron', 'line',
                                    'pyramid']},
    fill: {default: true, if: {type: ['circle']}},
    align: {default: 'end', oneOf: ['start', 'center', 'end']}
  },

  /**
   * Store initial positions in case need to reset on component removal.
   */
  init: function () {
    var self = this;
    var el = this.el;

    this.children = el.getChildEntities();
    this.initialPositions = [];

    this.children.forEach(function getInitialPositions (childEl) {
      if (childEl.hasLoaded) { return _getPositions(); }
      childEl.addEventListener('loaded', _getPositions);
      function _getPositions () {
        self.initialPositions.push(childEl.object3D.position.x);
        self.initialPositions.push(childEl.object3D.position.y);
        self.initialPositions.push(childEl.object3D.position.z);
      }
    });

    this.handleChildAttached = this.handleChildAttached.bind(this);
    this.handleChildDetached = this.handleChildDetached.bind(this);

    el.addEventListener('child-attached', this.handleChildAttached);
    el.addEventListener('child-detached', this.handleChildDetached);
  },

  /**
   * Update child entity positions.
   */
  update: function (oldData) {
    var children = this.children;
    var data = this.data;
    var definedData;
    var el = this.el;
    var numChildren;
    var positionFn;

    numChildren = children.length;

    // Calculate different positions based on layout shape.
    switch (data.type) {
      case 'box': {
        positionFn = getBoxPositions;
        break;
      }
      case 'circle': {
        positionFn = getCirclePositions;
        break;
      }
      case 'cube': {
        positionFn = getCubePositions;
        break;
      }
      case 'dodecahedron': {
        positionFn = getDodecahedronPositions;
        break;
      }
      case 'pyramid': {
        positionFn = getPyramidPositions;
        break;
      }
      default: {
        // Line.
        positionFn = getLinePositions;
      }
    }

    definedData = el.getDOMAttribute('layout');
    positions.length = 0;
    positions = positionFn(
      data, numChildren,
      typeof definedData === 'string'
        ? definedData.indexOf('margin') !== -1
        : 'margin' in definedData
    );
    if (data.reverse) { positions.reverse(); }
    setPositions(children, positions, data.orderAttribute);
  },

  /**
   * Reset positions.
   */
  remove: function () {
    this.el.removeEventListener('child-attached', this.handleChildAttached);
    this.el.removeEventListener('child-detached', this.handleChildDetached);
    setPositions(this.children, this.initialPositions);
  },

  handleChildAttached: function (evt) {
    // Only update if direct child attached.
    var el = this.el;
    if (evt.detail.el.parentNode !== el) { return; }
    this.children.push(evt.detail.el);
    this.update();
  },

  handleChildDetached: function (evt) {
    // Only update if direct child detached.
    if (this.children.indexOf(evt.detail.el) === -1) { return; }
    this.children.splice(this.children.indexOf(evt.detail.el), 1);
    this.initialPositions.splice(this.children.indexOf(evt.detail.el), 1);
    this.update();
  }
});

/**
 * Get positions for `box` layout.
 */
function getBoxPositions (data, numChildren, marginDefined) {
  var column;
  var marginColumn;
  var marginRow;
  var offsetColumn;
  var offsetRow;
  var row;
  var rows = Math.ceil(numChildren / data.columns);

  marginColumn = data.marginColumn;
  marginRow = data.marginRow;
  if (marginDefined) {
    marginColumn = data.margin;
    marginRow = data.margin;
  }

  offsetRow = getOffsetItemIndex(data.align, rows);
  offsetColumn = getOffsetItemIndex(data.align, data.columns);

  for (row = 0; row < rows; row++) {
    for (column = 0; column < data.columns; column++) {
      positionHelper.set(0, 0, 0);
      if (data.plane.indexOf('x') === 0) {
        positionHelper.x = (column - offsetColumn) * marginColumn;
      }
      if (data.plane.indexOf('y') === 0) {
        positionHelper.y = (column - offsetColumn) * marginColumn;
      }
      if (data.plane.indexOf('y') === 1) {
        positionHelper.y = (row - offsetRow) * marginRow;
      }
      if (data.plane.indexOf('z') === 1) {
        positionHelper.z = (row - offsetRow) * marginRow;
      }
      pushPositionVec3(positionHelper);
    }
  }

  return positions;
}
module.exports.getBoxPositions = getBoxPositions;

/**
 * Get positions for `circle` layout.
 */
function getCirclePositions (data, numChildren) {
  var i;
  var rad;

  for (i = 0; i < numChildren; i++) {
    rad;

    if (isNaN(data.angle)) {
      rad = i * (2 * Math.PI) / numChildren;
    } else {
      rad = i * data.angle * 0.01745329252;  // Angle to radian.
    }

    positionHelper.set(0, 0, 0);
    if (data.plane.indexOf('x') === 0) {
      positionHelper.x = data.radius * Math.cos(rad);
    }
    if (data.plane.indexOf('y') === 0) {
      positionHelper.y = data.radius * Math.cos(rad);
    }
    if (data.plane.indexOf('y') === 1) {
      positionHelper.y = data.radius * Math.sin(rad);
    }
    if (data.plane.indexOf('z') === 1) {
      positionHelper.z = data.radius * Math.sin(rad);
    }
    pushPositionVec3(positionHelper);
  }
  return positions;
}
module.exports.getCirclePositions = getCirclePositions;

/**
 * Get positions for `line` layout.
 * TODO: 3D margins.
 */
function getLinePositions (data, numChildren) {
  data.columns = numChildren;
  return getBoxPositions(data, numChildren, true);
}
module.exports.getLinePositions = getLinePositions;

/**
 * Get positions for `cube` layout.
 */
function getCubePositions (data, numChildren) {
  pushPositions(
    1, 0, 0,
    0, 1, 0,
    0, 0, 1,
    -1, 0, 0,
    0, -1, 0,
    0, 0, -1
  );
  scalePositions(data.radius / 2);
  return positions;
}
module.exports.getCubePositions = getCubePositions;

/**
 * Get positions for `dodecahedron` layout.
 */
function getDodecahedronPositions (data, numChildren) {
  var PHI = (1 + Math.sqrt(5)) / 2;
  var B = 1 / PHI;
  var C = 2 - PHI;
  var NB = -1 * B;
  var NC = -1 * C;
  pushPositions(
    -1, C, 0,
    -1, NC, 0,
    0, -1, C,
    0, -1, NC,
    0, 1, C,
    0, 1, NC,
    1, C, 0,
    1, NC, 0,
    B, B, B,
    B, B, NB,
    B, NB, B,
    B, NB, NB,
    C, 0, 1,
    C, 0, -1,
    NB, B, B,
    NB, B, NB,
    NB, NB, B,
    NB, NB, NB,
    NC, 0, 1,
    NC, 0, -1
  );
  scalePositions(data.radius / 2);
  return positions;
}
module.exports.getDodecahedronPositions = getDodecahedronPositions;

/**
 * Get positions for `pyramid` layout.
 */
function getPyramidPositions (data, numChildren) {
  var SQRT_3 = Math.sqrt(3);
  var NEG_SQRT_1_3 = -1 / Math.sqrt(3);
  var DBL_SQRT_2_3 = 2 * Math.sqrt(2 / 3);
  pushPositions(
    0, 0, SQRT_3 + NEG_SQRT_1_3,
    -1, 0, NEG_SQRT_1_3,
    1, 0, NEG_SQRT_1_3,
    0, DBL_SQRT_2_3, 0
  );
  scalePositions(data.radius / 2);
  return positions;
}
module.exports.getPyramidPositions = getPyramidPositions;

/**
 * Return the item index in a given list to calculate offsets from
 *
 * @param {string} align - One of `'start'`, `'center'`, `'end'`
 * @param {integer} numItems - Total number of items
 */
function getOffsetItemIndex (align, numItems) {
  switch (align) {
    case 'start':
      return numItems - 1;
    case 'center':
      return (numItems - 1) / 2;
    case 'end':
      return 0;
  }
}

/**
 * Multiply all coordinates by a scale factor and add translate.
 *
 * @params {array} positions - Array of coordinates in array form.
 * @returns {array} positions
 */
function scalePositions (scale) {
  var i;
  for (i = 0; i < positions.length; i++) {
    positions[i] = positions[i] * scale;
  }
};

/**
 * Set position on child entities.
 *
 * @param {array} els - Child entities to set.
 * @param {array} positions - Array of coordinates.
 */
function setPositions (els, positions, orderAttribute) {
  var i;
  var orderIndex;

  // Allow for controlling order explicitly since DOM order does not have as much
  // meaning in A-Frame.
  if (orderAttribute) {
    for (i = 0; i < els.length; i++) {
      orderIndex = parseInt(els[i].getAttribute(orderAttribute), 10) * 3;
      els[i].object3D.position.set(positions[orderIndex], positions[orderIndex + 1],
                                   positions[orderIndex + 2]);
    }
    return;
  }

  for (i = 0; i < positions.length; i += 3) {
    if (!els[i / 3]) { return; }
    els[i / 3].object3D.position.set(positions[i], positions[i + 1], positions[i + 2]);
  }
}

function pushPositions () {
  var i;
  for (i = 0; i < arguments.length; i++) {
    positions.push(i);
  }
}

function pushPositionVec3 (vec3) {
  positions.push(vec3.x);
  positions.push(vec3.y);
  positions.push(vec3.z);
}


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(155);

AFRAME.registerComponent('orbit-controls', {
  dependencies: ['camera'],

  schema: {
    autoRotate: {type: 'boolean'},
    autoRotateSpeed: {default: 2},
    dampingFactor: {default: 0.1},
    enabled: {default: true},
    enableDamping: {default: true},
    enableKeys: {default: true},
    enablePan: {default: true},
    enableRotate: {default: true},
    enableZoom: {default: true},
    initialPosition: {type: 'vec3'},
    keyPanSpeed: {default: 7},
    minAzimuthAngle: {type: 'number', default: Infinity},
    maxAzimuthAngle: {type: 'number', default: Infinity},
    maxDistance: {default: 1000},
    maxPolarAngle: {default: AFRAME.utils.device.isMobile() ? 90 : 120},
    minDistance: {default: 1},
    minPolarAngle: {default: 0},
    minZoom: {default: 0},
    panSpeed: {default: 1},
    rotateSpeed: {default: 0.05},
    screenSpacePanning: {default: false},
    target: {type: 'vec3'},
    zoomSpeed: {default: 0.5}
  },

  init: function () {
    var el = this.el;
    var oldPosition;

    this.controls = new THREE.OrbitControls(el.getObject3D('camera'),
                                            el.sceneEl.renderer.domElement);

    oldPosition = new THREE.Vector3();

    el.sceneEl.addEventListener('enter-vr', () => {
      if (!AFRAME.utils.device.checkHeadsetConnected() &&
          !AFRAME.utils.device.isMobile()) { return; }
      this.controls.enabled = false;
      if (el.hasAttribute('look-controls')) {
        el.setAttribute('look-controls', 'enabled', true);
        oldPosition.copy(el.getObject3D('camera').position);
        el.getObject3D('camera').position.set(0, 0, 0);
      }
    });

    el.sceneEl.addEventListener('exit-vr', () => {
      if (!AFRAME.utils.device.checkHeadsetConnected() &&
          !AFRAME.utils.device.isMobile()) { return; }
      this.controls.enabled = true;
      el.getObject3D('camera').position.copy(oldPosition);
      if (el.hasAttribute('look-controls')) {
        el.setAttribute('look-controls', 'enabled', false);
      }
    });

    document.body.style.cursor = 'grab';
    document.addEventListener('mousedown', () => {
      document.body.style.cursor = 'grabbing';
    });
    document.addEventListener('mouseup', () => {
      document.body.style.cursor = 'grab';
    });

    this.target = new THREE.Vector3();
    el.getObject3D('camera').position.copy(this.data.initialPosition);
  },

  update: function (oldData) {
    var controls = this.controls;
    var data = this.data;

    controls.target = this.target.copy(data.target);
    controls.autoRotate = data.autoRotate;
    controls.autoRotateSpeed = data.autoRotateSpeed;
    controls.dampingFactor = data.dampingFactor;
    controls.enabled = data.enabled;
    controls.enableDamping = data.enableDamping;
    controls.enableKeys = data.enableKeys;
    controls.enablePan = data.enablePan;
    controls.enableRotate = data.enableRotate;
    controls.enableZoom = data.enableZoom;
    controls.keyPanSpeed = data.keyPanSpeed;
    controls.maxPolarAngle = THREE.Math.degToRad(data.maxPolarAngle);
    controls.maxDistance = data.maxDistance;
    controls.minDistance = data.minDistance;
    controls.minPolarAngle = THREE.Math.degToRad(data.minPolarAngle);
    controls.minZoom = data.minZoom;
    controls.panSpeed = data.panSpeed;
    controls.rotateSpeed = data.rotateSpeed;
    controls.screenSpacePanning = data.screenSpacePanning;
    controls.zoomSpeed = data.zoomSpeed;
  },

  tick: function () {
    var controls = this.controls;
    var data = this.data;
    if (!data.enabled) { return; }
    if (controls.enabled && (controls.enableDamping || controls.autoRotate)) {
      this.controls.update();
    }
  }
});


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Particles component for A-Frame.
 *
 * ShaderParticleEngine by Squarefeet (https://github.com/squarefeet).
 */

var SPE = __webpack_require__(156);

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

AFRAME.registerComponent('particle-system', {

    schema: {
        preset: {
            type: 'string',
            default: '',
            oneOf: ['default', 'dust', 'snow', 'rain']
        },
        maxAge: {
            type: 'number'
        },
        positionSpread: {
            type: 'vec3'
        },
        type: {
            type: 'number'
        },
        rotationAxis: {
            type: 'string'
        },
        rotationAngle: {
            type: 'number'
        },
        accelerationValue: {
            type: 'vec3'
        },
        accelerationSpread: {
            type: 'vec3'
        },
        velocityValue: {
            type: 'vec3'
        },
        velocitySpread: {
            type: 'vec3'
        },
        color: {
            type: 'array'
        },
        size: {
            type: 'number'
        },
        direction: {
            type: 'number'
        },
        duration: {
            type: 'number'
        },
        particleCount: {
            type: 'number'
        },
        texture: {
            type: 'asset'
        },
        randomize: {
            type: 'boolean'
        },
        opacity: {
          type: 'number',
        },
        maxParticleCount: {
            type: 'number',
            default: 250000
        },
        blending: {
            type: 'number',
            default: THREE.AdditiveBlending,
            oneOf: [THREE.NoBlending,THREE.NormalBlending,THREE.AdditiveBlending,THREE.SubtractiveBlending,THREE.MultiplyBlending]
        },
        enabled: {
            type:'boolean',
            default:true
        }
    },


    init: function() {

        this.presets = [];

        /* preset settings can be overwritten */

        this.presets['default'] = {
            maxAge: (this.data.maxAge!==0?this.data.maxAge:6),
            positionSpread: (this.data.positionSpread.x!==0||this.data.positionSpread.y!==0||this.data.positionSpread.z!==0?this.data.positionSpread:{x:0,y:0,z:0}),
            type: (this.data.type!==0?this.data.type:SPE.distributions.BOX), /* SPE.distributions.SPHERE, SPE.distributions.DISC */
            rotationAxis: (this.data.rotationAxis!==''?this.data.rotationAxis:'x'),
            rotationAngle: (this.data.rotationAngle!==0?this.data.rotationAngle:0),
            accelerationValue: (this.data.accelerationValue.x!==0||this.data.accelerationValue.y!==0||this.data.accelerationValue.z!==0?this.data.accelerationValue:{x: 0, y: -10, z: 0}),
            accelerationSpread: (this.data.accelerationSpread.x!==0||this.data.accelerationSpread.y!==0||this.data.accelerationSpread.z!==0?this.data.accelerationSpread:{x: 10, y: 0, z: 10}),
            velocityValue: (this.data.velocityValue.x!==0||this.data.velocityValue.y!==0||this.data.velocityValue.z!==0?this.data.velocityValue:{x: 0, y: 25, z: 0}),
            velocitySpread: (this.data.velocitySpread.x!==0||this.data.velocitySpread.y!==0||this.data.velocitySpread.z!==0?this.data.velocitySpread:{x: 10, y: 7.5, z: 10}),
            color: (this.data.color.length?this.data.color:['#0000FF','#FF0000']),
            size: (this.data.size!==0?this.data.size:1),
            opacity: { value: (this.data.opacity!=0?this.data.opacity:1) },
            direction: (this.data.direction!==0?this.data.direction:1),
            duration: (this.data.duration!=0?this.data.duration:null),
            particleCount: (this.data.particleCount!==0?this.data.particleCount:1000),
            texture: (this.data.texture!==''?this.data.texture:'https://cdn.rawgit.com/IdeaSpaceVR/aframe-particle-system-component/master/dist/images/star2.png'),
            randomize: false
        };


        this.presets['dust'] = {
            maxAge: (this.data.maxAge!==0?this.data.maxAge:20),
            positionSpread: (this.data.positionSpread.x!==0||this.data.positionSpread.y!==0||this.data.positionSpread.z!==0?this.data.positionSpread:{x:100,y:100,z:100}),
            type: (this.data.type!==0?this.data.type:SPE.distributions.BOX), /* SPE.distributions.SPHERE, SPE.distributions.DISC */
            rotationAxis: (this.data.rotationAxis!==''?this.data.rotationAxis:'x'),
            rotationAngle: (this.data.rotationAngle!==0?this.data.rotationAngle:3.14),
            accelerationValue: (this.data.accelerationValue.x!==0||this.data.accelerationValue.y!==0||this.data.accelerationValue.z!==0?this.data.accelerationValue:{x: 0, y: 0, z: 0}),
            accelerationSpread: (this.data.accelerationSpread.x!==0||this.data.accelerationSpread.y!==0||this.data.accelerationSpread.z!==0?this.data.accelerationSpread:{x: 0, y: 0, z: 0}),
            velocityValue: (this.data.velocityValue.x!==0||this.data.velocityValue.y!==0||this.data.velocityValue.z!==0?this.data.velocityValue:{x: 1, y: 0.3, z: 1}),
            velocitySpread: (this.data.velocitySpread.x!==0||this.data.velocitySpread.y!==0||this.data.velocitySpread.z!==0?this.data.velocitySpread:{x: 0.5, y: 1, z: 0.5}),
            color: (this.data.color.length?this.data.color:['#FFFFFF']),
            size: (this.data.size!==0?this.data.size:1),
            opacity: { value: (this.data.opacity!=0?this.data.opacity:1) },
            direction: (this.data.direction!==0?this.data.direction:1),
            duration: (this.data.duration!=0?this.data.duration:null),
            particleCount: (this.data.particleCount!==0?this.data.particleCount:100),
            texture: (this.data.texture!==''?this.data.texture:'https://cdn.rawgit.com/IdeaSpaceVR/aframe-particle-system-component/master/dist/images/smokeparticle.png'),
            randomize: false
        };


        this.presets['snow'] = {
            maxAge: (this.data.maxAge!==0?this.data.maxAge:20),
            positionSpread: (this.data.positionSpread.x!==0||this.data.positionSpread.y!==0||this.data.positionSpread.z!==0?this.data.positionSpread:{x:100,y:100,z:100}),
            type: (this.data.type!==0?this.data.type:SPE.distributions.BOX), /* SPE.distributions.SPHERE, SPE.distributions.DISC */
            rotationAxis: (this.data.rotationAxis!==''?this.data.rotationAxis:'x'),
            rotationAngle: (this.data.rotationAngle!==0?this.data.rotationAngle:3.14),
            accelerationValue: (this.data.accelerationValue.x!==0||this.data.accelerationValue.y!==0||this.data.accelerationValue.z!==0?this.data.accelerationValue:{x: 0, y: 0, z: 0}),
            accelerationSpread: (this.data.accelerationSpread.x!==0||this.data.accelerationSpread.y!==0||this.data.accelerationSpread.z!==0?this.data.accelerationSpread:{x: 0.2, y: 0, z: 0.2}),
            velocityValue: (this.data.velocityValue.x!==0||this.data.velocityValue.y!==0||this.data.velocityValue.z!==0?this.data.velocityValue:{x: 0, y: 8, z: 0}),
            velocitySpread: (this.data.velocitySpread.x!==0||this.data.velocitySpread.y!==0||this.data.velocitySpread.z!==0?this.data.velocitySpread:{x: 2, y: 0, z: 2}),
            color: (this.data.color.length?this.data.color:['#FFFFFF']),
            size: (this.data.size!==0?this.data.size:1),
            opacity: { value: (this.data.opacity!=0?this.data.opacity:1) },
            direction: (this.data.direction!==0?this.data.direction:1),
            duration: (this.data.duration!=0?this.data.duration:null),
            particleCount: (this.data.particleCount!==0?this.data.particleCount:200),
            texture: (this.data.texture!==''?this.data.texture:'https://cdn.rawgit.com/IdeaSpaceVR/aframe-particle-system-component/master/dist/images/smokeparticle.png'),
            randomize: false
        };


        this.presets['rain'] = {
            maxAge: (this.data.maxAge!==0?this.data.maxAge:1),
            positionSpread: (this.data.positionSpread.x!==0||this.data.positionSpread.y!==0||this.data.positionSpread.z!==0?this.data.positionSpread:{x:100,y:100,z:100}),
            type: (this.data.type!==0?this.data.type:SPE.distributions.BOX), /* SPE.distributions.SPHERE, SPE.distributions.DISC */
            rotationAxis: (this.data.rotationAxis!==''?this.data.rotationAxis:'x'),
            rotationAngle: (this.data.rotationAngle!==0?this.data.rotationAngle:3.14),
            accelerationValue: (this.data.accelerationValue.x!==0||this.data.accelerationValue.y!==0||this.data.accelerationValue.z!==0?this.data.accelerationValue:{x: 0, y: 3, z: 0}),
            accelerationSpread: (this.data.accelerationSpread.x!==0||this.data.accelerationSpread.y!==0||this.data.accelerationSpread.z!==0?this.data.accelerationSpread:{x: 2, y: 1, z: 2}),
            velocityValue: (this.data.velocityValue.x!==0||this.data.velocityValue.y!==0||this.data.velocityValue.z!==0?this.data.velocityValue:{x: 0, y: 75, z: 0}),
            velocitySpread: (this.data.velocitySpread.x!==0||this.data.velocitySpread.y!==0||this.data.velocitySpread.z!==0?this.data.velocitySpread:{x: 10, y: 50, z: 10}),
            color: (this.data.color.length?this.data.color:['#FFFFFF']),
            size: (this.data.size!==0?this.data.size:0.4),
            opacity: { value: (this.data.opacity!=0?this.data.opacity:1) },
            direction: (this.data.direction!==0?this.data.direction:1),
            duration: (this.data.duration!=0?this.data.duration:null),
            particleCount: (this.data.particleCount!==0?this.data.particleCount:1000),
            texture: (this.data.texture!==''?this.data.texture:'https://cdn.rawgit.com/IdeaSpaceVR/aframe-particle-system-component/master/dist/images/raindrop.png'),
            randomize: false
        };


    },


    update: function (oldData) {

        // Remove old particle group.
        if (this.particleGroup) {
            this.el.removeObject3D('particle-system');
        }

        if (this.data.preset != '' && this.data.preset in this.presets) {

            this.initParticleSystem(this.presets[this.data.preset]);

        } else {

            this.initParticleSystem(this.presets['default']);
        }

        if(this.data.enabled === true) {
            this.startParticles()
        } else {
            this.stopParticles()
        }
    },


    tick: function(time, dt) {

        this.particleGroup.tick(dt / 1000);
    },


    remove: function() {

        // Remove particle system.
        if (!this.particleGroup) { return; }
        this.el.removeObject3D('particle-system');
    },

    startParticles: function() {
        this.particleGroup.emitters.forEach(function(em) { em.enable() });
    },

    stopParticles: function() {
        this.particleGroup.emitters.forEach(function(em) { em.disable() });
    },


    initParticleSystem: function(settings) {

        var loader = new THREE.TextureLoader();
        var particle_texture = loader.load(
            settings.texture,
            function (texture) {
                return texture;
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (xhr) {
              console.log('An error occurred');
            }
        );

        this.particleGroup = new SPE.Group({
            texture: {
                value: particle_texture
            },
            maxParticleCount: this.data.maxParticleCount,
            blending: this.data.blending
        });

        var emitter = new SPE.Emitter({
            maxAge: {
                value: settings.maxAge
            },
            type: {
                value: settings.type
            },
            position: {
                spread: new THREE.Vector3(settings.positionSpread.x, settings.positionSpread.y, settings.positionSpread.z),
                randomize: settings.randomize
                //spreadClamp: new THREE.Vector3( 2, 2, 2 ),
                //radius: 4
            },
            rotation: {
                axis: (settings.rotationAxis=='x'?new THREE.Vector3(1, 0, 0):(settings.rotationAxis=='y'?new THREE.Vector3(0, 1, 0):(settings.rotationAxis=='z'?new THREE.Vector3(0, 0, 1):new THREE.Vector3(0, 1, 0)))),
                angle: settings.rotationAngle,
                static: true
            },
            acceleration: {
                value: new THREE.Vector3(settings.accelerationValue.x, settings.accelerationValue.y, settings.accelerationValue.z),
                spread: new THREE.Vector3(settings.accelerationSpread.x, settings.accelerationSpread.y, settings.accelerationSpread.z)
            },
            velocity: {
                value: new THREE.Vector3(settings.velocityValue.x, settings.velocityValue.y, settings.velocityValue.z),
                spread: new THREE.Vector3(settings.velocitySpread.x, settings.velocitySpread.y, settings.velocitySpread.z)
            },
            color: {
                value: settings.color.map(function(c) { return new THREE.Color(c); })
            },
            size: {
                value: settings.size
            },
            /*wiggle: { value: 4, spread: 2 }, //settings.wiggle,*/
            /*drag: {
                value: settings.drag
            },*/
            direction: {
                value: settings.direction
            },
            duration: settings.duration,
            opacity: settings.opacity,
            particleCount: settings.particleCount
        });

        this.particleGroup.addEmitter(emitter);
        this.particleGroup.mesh.frustumCulled = false;
        this.el.setObject3D('particle-system', this.particleGroup.mesh);
    }
});


/***/ }),
/* 145 */
/***/ (function(module, exports) {

/* global AFRAME */

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

/**
 * Particle Player component for A-Frame.
 */
AFRAME.registerComponent('particleplayer', {
 multiple: true,
  schema: {
    src: {type: 'selector'},
    on: {default: 'init'},
    count: {default: '100%'},
    dur: {default: 1000, type: 'int'},
    loop: {default: 'false'},
    delay: {default: 0, type: 'int'},
    scale: {default: 1.0, type: 'float'},
    pscale: {default: 1.0, type: 'float'},
    protation: {type: 'vec3'},
    cache: {default: 5, type: 'int'}, // number of simultaneous particle systems
    shader: {default: 'flat', oneOf: ['flat', 'lambert', 'phong', 'standard']},
    color: {default: '#fff', type: 'color'},
    blending: {default: 'additive', oneOf: ['normal', 'additive', 'multiply', 'substractive']},
    img: {type: 'selector'},
    interpolate: {default: false}
  },

  init: function () {
    this.framedata = null;
    this.restPositions = null; // position at first frame each particle is alive
    this.restRotations = null; 
    this.numFrames = 0;
    this.numParticles = 0; // total number of particles per system
    this.count = 0; // actual number of particles to spawn per event (data.count)
    this.systems = null;
    this.cache = null;
    this.material = null;
    this.geometry = null;
    this.frame = 0;
    this.lastFrame = 0;
    this.msPerFrame = 0;
    this.useRotation = false;
    this.sprite_rotation = false;
    this.protation = false;
    this.allParticlesEl = null;

    // temporal vars for preventing gc
    this.v = new THREE.Vector3();
    this.indexPool = null;
  },

  update: function(oldData) {
    var params;
    const BLENDINGS = {
      'normal': THREE.NormalBlending,
      'additive': THREE.AdditiveBlending,
      'substractive': THREE.SubstractiveBlending,
      'multiply': THREE.MultiplyBlending
    };
    const SHADERS = {
      'flat': THREE.MeshBasicMaterial,
      'lambert': THREE.MeshLambertMaterial,
      'phong': THREE.MeshPhongMaterial,
      'standard': THREE.MeshStandardMaterial
    }
    var data = this.data;

    if (oldData.on !== data.on) {
      if (oldData.on) { this.el.removeEventListener(oldData.on, this.start)}
      if (data.on !== 'play') {
        this.el.addEventListener(data.on, this.start.bind(this));
      }
    }

    this.loadParticlesJSON(data.src, data.scale);

    this.numFrames = this.framedata.length;
    this.numParticles = this.numFrames > 0 ? this.framedata[0].length : 0;

    if (data.count[data.count.length-1] == '%') {
      this.count = Math.floor(parseInt(data.count) * this.numParticles / 100.0);
    } else { 
      this.count = parseInt(data.count); 
    }
    this.count = Math.min(this.numParticles, Math.max(0, this.count));

    this.msPerFrame = data.dur / this.numFrames;
 
    this.indexPool = new Array(this.numParticles);


    params = {
      color: new THREE.Color(data.color),
      side: THREE.DoubleSide,
      blending: BLENDINGS[data.blending],
      map: data.img ? new THREE.TextureLoader().load(data.img.src) : null,
      depthWrite: false,
      opacity: data.opacity,
      transparent: data.img || data.blending !== 'normal' || data.opacity < 1 ? true : false
    };

    if (SHADERS[data.shader] !== undefined) {
      this.material = new SHADERS[data.shader](params);
    } else {
      this.material = new SHADERS['flat'](params);
    }
    
    var ratio = data.img ? data.img.width / data.img.height : 1;
    this.geometry = new THREE.PlaneBufferGeometry(0.1 * ratio * data.pscale, 0.1 * data.pscale);

    if (!this.allParticlesEl) {
      this.allParticlesEl = document.createElement('a-entity');
      this.allParticlesEl.id = "__json-particles-" + Math.floor(Math.random()*1000);
      this.el.appendChild(this.allParticlesEl);
    }

    if (this.sprite_rotation !== false){
      this.geometry.rotateX(this.sprite_rotation.x);
      this.geometry.rotateY(this.sprite_rotation.y);
      this.geometry.rotateZ(this.sprite_rotation.z);
    }
    else {
      this.geometry.rotateX(this.data.protation.x * Math.PI / 180);
      this.geometry.rotateY(this.data.protation.y * Math.PI / 180);
      this.geometry.rotateZ(this.data.protation.z * Math.PI / 180);
    }

    this.cacheParticles(data.cache);

    if (data.on === 'init') {
      this.start();
    }
  },

  loadParticlesJSON: function (json, scale) {
    var data = JSON.parse(json.data);
    var p; // particle
    var alive;
    var frames = data.frames;
    var velOffset = data.rotation ? 3 : 0;
    var F = data.precision;
    this.restPositions = [];
    this.restRotations = []; 

    this.useRotation = data.rotation;

    if (data.sprite_rotation !== false) {
      this.sprite_rotation = new THREE.Vector3();
      this.sprite_rotation.x = data.sprite_rotation[0] / F;
      this.sprite_rotation.y = data.sprite_rotation[1] / F;
      this.sprite_rotation.z = data.sprite_rotation[2] / F;
    }
    else { this.sprite_rotation = false; }

    this.framedata = new Array(frames.length);
    for (var f = 0; f < frames.length; f++) {
      this.framedata[f] = new Array(frames[f].length);
      for (var i = 0; i < frames[f].length; i++) {
        p = frames[f][i]; // data of particle i in frame f
        alive = p !== 0;

        this.framedata[f][i] = {
          position: alive ? 
            new THREE.Vector3(p[0] / F * scale, p[1] / F * scale, p[2] / F * scale) :
            null,
          alive: alive
        };

        if (data.rotation) {
          this.framedata[f][i].rotation = alive ? 
            new THREE.Euler(p[3] / F, p[4] / F, p[5] / F) :
            null;
        }

        if (alive && this.restPositions[i] === undefined) {
          this.restPositions[i] = this.framedata[f][i].position;
          if (data.rotation) {
            this.restRotations[i] = this.framedata[f][i].rotation;
          }
        }
      }
    }
  },

  cacheParticles: function (numParticleSystems) {
    var i;
    var p;
    var allParticles;
    var loop = parseInt(this.data.loop);
    
    //remove old particles
    allParticles = this.allParticlesEl.object3D;
    while (allParticles.children.length) {
      allParticles.remove(allParticles.children[0]);
    }

    this.cache = [];

    if (isNaN(loop)) { 
      loop = this.data.loop === 'true' ? Number.MAX_VALUE : 0; 
    }

    for (i = 0; i < numParticleSystems; i++) {
      var ps = {
        active: false,
        loopTotal: loop,
        loopCount: 0,
        time: 0,
        activeParticles: new Array(this.count),
        object3D: new THREE.Object3D()
      };

      ps.object3D.visible = false;

      for (p = 0; p < this.numParticles; p++) {
        var part = new THREE.Mesh(this.geometry, this.material);
        part.visible = false;
        ps.object3D.add(part);
        if (p < this.count) {
          ps.activeParticles[p] = p;
        }
      }

      allParticles.add(ps.object3D);
      this.cache.push(ps);
    }
  },

  start: function (evt) {
    if (this.data.delay > 0) {
      setTimeout( () => this.startAfterDelay(evt), this.data.delay);
    } else {
      this.startAfterDelay(evt);
    }
  },

  startAfterDelay: function (evt) { 
    // position, rotation
    var found = -1;
    var ps;
    var id;
    var oldestTime = 0;
    var position = evt ? evt.detail['position'] : null;
    var rotation = evt ? evt.detail['rotation'] : null;

    if (!(position instanceof THREE.Vector3)) { position = new THREE.Vector3(); }
    if (!(rotation instanceof THREE.Euler)) { rotation = new THREE.Euler(); }

    // find available (or oldest) particle system
    for (var i = 0; i < this.cache.length; i++) {
      if (this.cache[i].active === false){
        found = i;
        break;
      }
      if (this.cache[i].time > oldestTime) {
        found = i;
        oldestTime = this.cache[i].time;
      }
    }

    ps = this.cache[found];

    ps.active = true;
    ps.loopCount = 1;
    ps.object3D.visible = true;
    ps.object3D.position.copy(position);
    ps.object3D.rotation.copy(rotation);
    ps.time = 0;

    this.resetParticles(ps);
  },

  doLoop: function (ps) {
    ps.loopCount++;
    ps.frame = -1;
    ps.time = 0;
    this.resetParticles(ps);
  },

  resetParticle: function (part, i) {
    part.visible = false;
    if (this.restPositions[i]) { part.position.copy(this.restPositions[i]); }
    if (this.useRotation){
      if (this.restRotations[i]) { part.rotation.copy(this.restRotations[i]); }
    } else {
      //part.lookAt(this.camera.position); // lookAt does not support rotated or translated parents! :_(
    }
  },

/**
 * When starting or finishing (looping) animation, this resets particles
 * to their initial position and, if user asked for replaying less than 100%
 * of particles, randomly choose them.
 */
  resetParticles: function (ps) {
    var i;
    var pi;
    var part;
    var rand;
    var aux;

    // no picking, just hide and reset
    if (this.count === this.numParticles) {
      for (i = 0; i < this.numParticles; i++) { 
        this.resetParticle(ps.object3D.children[i], i);
      }
      return;
    }

    // hide particles from last animation and initialize indexPool
    for (i = 0; i < this.numParticles; i++) { 
      if (i < this.count) {
        ps.object3D.children[ ps.activeParticles[i] ].visible = false;
      }
      this.indexPool[i] = i;
    }

    // scramble indexPool
    for (i = 0; i < this.count - 1; i++) { 
      rand = i + Math.floor(Math.random() * (this.numParticles - i));
      ps.activeParticles[i] = this.indexPool[rand];
      this.indexPool[rand] = this.indexPool[i];
      this.resetParticle(ps.object3D.children[ps.activeParticles[i]], i);
    }
  },

  tick: function (time, delta) {
    var j, i; // loop vars
    var ps; // current particle system
    var frame; // current particle system frame
    var particle; // current particle
    var pi; // index of current particle
    var fdata; // all particles data in current frame
    var fdataNext; // next frame (for interpolation)
    var useRotation = this.useRotation;
    var frameTime; // time in current frame (for interpolation)
    var relTime; // current particle system relative time (0-1)
    var interpolate; // whether interpolate between frames or not

    for (i = 0; i < this.cache.length; i++) {
      ps = this.cache[i];
      if (!ps.active) continue;
      
      // if the duration is so short that there's no need to interpolate, don't do it
      // even if user asked for it.
      interpolate = this.data.interpolate && this.data.dur / this.numFrames > delta;

      relTime = ps.time / this.data.dur;
      frame = relTime * this.numFrames;
      fdata = this.framedata[Math.floor(frame)];
      if (interpolate) {
        frameTime = frame - Math.floor(frame);
        fdataNext = frame < this.numFrames - 1 ? this.framedata[Math.floor(frame) + 1] : null;
      }
      for (j = 0; j < ps.activeParticles.length; j++) {
        pi = ps.activeParticles[j];
        particle = ps.object3D.children[pi];
        if (!fdata[pi].alive){
          particle.visible = false;
          continue;
        } 

        particle.visible = true;

        if (interpolate && fdataNext && fdataNext[pi].alive) {
          particle.position.lerpVectors(fdata[pi].position, fdataNext[pi].position, frameTime);
        } else {
          particle.position.copy(fdata[pi].position);
        }

        if (useRotation) {
          particle.rotation.copy(fdata[pi].rotation);
        }
      }

      ps.time += delta;
      if (ps.time >= this.data.dur) {
        if (ps.loopCount < ps.loopTotal) {
          this.el.emit('loop');
          this.doLoop(ps);
        } else {
          this.el.emit('finished');
          ps.active = false;
          ps.object3D.visible = false;
        }
        continue;
      }
    }
  }

});


/***/ }),
/* 146 */
/***/ (function(module, exports) {

/**
 * Listen to event and forward to another entity or entities.
 */
AFRAME.registerComponent('proxy-event', {
  schema: {
    captureBubbles: {default: false},
    event: {type: 'string'},
    to: {type: 'string'},
    as: {type: 'string'},
    bubbles: {default: false}
  },

  multiple: true,

  init: function () {
    var data = this.data;
    var el = this.el;
    var to;
    var self = this;

    if (data.to === 'CHILDREN') {
      to = el.querySelectorAll('*');
    } else if (data.to === 'SELF') {
      to = [el];
    } else {
      to = document.querySelectorAll(data.to);
    }

    el.addEventListener(data.event, function (evt) {
      var data = self.data;
      var i;
      if (!data.captureBubbles && evt.target !== el) { return; }
      for (i = 0; i < to.length; i++) {
        to[i].emit(data.as || data.event, null, data.bubbles);
      }
    });
  }
});


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/* global AFRAME */

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

/**
 * Slice9 component for A-Frame.
 */
AFRAME.registerComponent('slice9', {
  schema: {
    width: {default: 1, min: 0},
    height: {default: 1, min: 0},
    left: {default: 0, min: 0},
    right: {default: 0, min: 0},
    bottom: {default: 0, min: 0},
    top: {default: 0, min: 0},
    side: {default: 'front', oneOf: ['front', 'back', 'double']},
    padding: {default: 0.1, min: 0.01},
    color: {type: 'color', default: '#fff'},
    opacity: {default: 1.0, min: 0, max: 1},
    transparent: {default: true},
    debug: {default: false},
    src: {type: 'map'}
  },

  /**
   * Set if component needs multiple instancing.
   */
  multiple: false,

  /**
   * Called once when component is attached. Generally for initial setup.
   */
  init: function () {
    var data = this.data;
    var material = this.material = new THREE.MeshBasicMaterial({color: data.color, opacity: data.opacity, transparent: data.transparent, wireframe: data.debug});
    var geometry = this.geometry = new THREE.PlaneBufferGeometry(data.width, data.height, 3, 3);

    var textureLoader = new THREE.TextureLoader();
    this.plane = new THREE.Mesh(geometry, material);
    this.el.setObject3D('mesh', this.plane);
    this.textureSrc = null;
  },

  updateMap: function () {
    var src = this.data.src;

    if (src) {
      if (src === this.textureSrc) { return; }
      // Texture added or changed.
      this.textureSrc = src;
      this.el.sceneEl.systems.material.loadTexture(src, {src: src}, setMap.bind(this));
      return;
    }

    // Texture removed.
    if (!this.material.map) { return; }
    setMap(null);


    function setMap (texture) {
      this.material.map = texture;
      this.material.needsUpdate = true;
      this.regenerateMesh();
    }
  },

  regenerateMesh: function () {
    var data = this.data;
    var pos = this.geometry.attributes.position.array;
    var uvs = this.geometry.attributes.uv.array;
    var image = this.material.map.image;

    if (!image) {return;}

    /*
      0--1------------------------------2--3
      |  |                              |  |
      4--5------------------------------6--7
      |  |                              |  |
      |  |                              |  |
      |  |                              |  |
      8--9-----------------------------10--11
      |  |                              |  |
      12-13----------------------------14--15
    */
    function setPos(id, x, y) {
      pos[3 * id] = x;
      pos[3 * id + 1] = y;
    }

    function setUV(id, u, v) {
      uvs[2 * id] = u;
      uvs[2 * id + 1] = v;
    }

    // Update UVS
    var uv = {
      left: data.left / image.width,
      right: data.right / image.width,
      top: data.top / image.height,
      bottom: data.bottom / image.height
    };

    setUV(1,  uv.left,  1);
    setUV(2,  uv.right, 1);

    setUV(4,  0,        uv.bottom);
    setUV(5,  uv.left,  uv.bottom);
    setUV(6,  uv.right, uv.bottom);
    setUV(7,  1,        uv.bottom);

    setUV(8,  0,        uv.top);
    setUV(9,  uv.left,  uv.top);
    setUV(10, uv.right, uv.top);
    setUV(11, 1,        uv.top);

    setUV(13, uv.left,  0);
    setUV(14, uv.right, 0);

    // Update vertex positions
    var w2 = data.width / 2;
    var h2 = data.height / 2;
    var left = -w2 + data.padding;
    var right = w2 - data.padding;
    var top = h2 - data.padding;
    var bottom = -h2 + data.padding;

    setPos(0, -w2,    h2);
    setPos(1, left,   h2);
    setPos(2, right,  h2);
    setPos(3, w2,     h2);

    setPos(4, -w2,    top);
    setPos(5, left,   top);
    setPos(6, right,  top);
    setPos(7, w2,     top);

    setPos(8, -w2,    bottom);
    setPos(9, left,   bottom);
    setPos(10, right, bottom);
    setPos(11, w2,    bottom);

    setPos(13, left,  -h2);
    setPos(14, right, -h2);
    setPos(12, -w2,   -h2);
    setPos(15, w2,    -h2);

    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.uv.needsUpdate = true;
  },

  /**
   * Called when component is attached and when component data changes.
   * Generally modifies the entity based on the data.
   */
   update: function (oldData) {
     var data = this.data;

     this.material.color.setStyle(data.color);
     this.material.opacity = data.opacity;
     this.material.transparent = data.transparent;
     this.material.wireframe = data.debug;
     this.material.side = parseSide(data.side);

     var diff = AFRAME.utils.diff(data, oldData);
     if ('src' in diff) {
       this.updateMap();
     }
     else if ('width' in diff || 'height' in diff || 'padding' in diff || 'left' in diff || 'top' in diff || 'bottom' in diff || 'right' in diff) {
       this.regenerateMesh();
     }
   },

  /**
   * Called when a component is removed (e.g., via removeAttribute).
   * Generally undoes all modifications to the entity.
   */
  remove: function () { },

  /**
   * Called on each scene tick.
   */
  // tick: function (t) { },

  /**
   * Called when entity pauses.
   * Use to stop or remove any dynamic or background behavior such as events.
   */
  pause: function () { },

  /**
   * Called when entity resumes.
   * Use to continue or add any dynamic or background behavior such as events.
   */
  play: function () { }
});

function parseSide (side) {
  switch (side) {
    case 'back': {
      return THREE.BackSide;
    }
    case 'double': {
      return THREE.DoubleSide;
    }
    default: {
      // Including case `front`.
      return THREE.FrontSide;
    }
  }
}


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var AND = '&&';
var QUOTE_RE = /'/g;
var OR = '||';
var COMPARISONS = ['==', '===', '!=', '!=='];
var tempTokenArray = [];
var tokenArray = [];

/**
 * Select value from store. Handles boolean operations, calls `selectProperty`.
 *
 * @param {object} state - State object.
 * @param {string} selector - Dot-delimited store keys (e.g., game.player.health).
 */
function select(state, selector, bindFor, bindForKey) {
  var comparisonResult;
  var firstValue;
  var i;
  var runningBool;
  var secondValue;
  var tokens;
  var value;

  // If just single selector, then grab value.
  tokens = split(selector, /\s+/);
  if (tokens.length === 1) {
    return selectProperty(state, selector, bindFor, bindForKey);
  }

  // Evaluate comparisons.
  tokenArray.length = 0;
  copyArray(tempTokenArray, tokens);
  for (i = 0; i < tempTokenArray.length; i++) {
    if (COMPARISONS.indexOf(tempTokenArray[i]) === -1) {
      tokenArray.push(tempTokenArray[i]);
      continue;
    }

    // Comparison (color === 'red').
    // Pop previous value since that is one of comparsion value.
    firstValue = selectProperty(state, tokenArray.pop());
    // Lookup second value.
    secondValue = tempTokenArray[i + 1].replace(QUOTE_RE, '');
    // Evaluate (equals or not equals).
    firstValue = firstValue === undefined ? 'undefined' : firstValue.toString();
    secondValue = secondValue === undefined ? 'undefined' : secondValue.toString();
    comparisonResult = tempTokenArray[i].indexOf('!') === -1 ? firstValue === secondValue : firstValue !== secondValue;
    tokenArray.push(comparisonResult);
    i++;
  }

  // Was single comparison.
  if (tokenArray.length === 1) {
    return tokenArray[0];
  }

  // If has boolean expression, evaluate.
  runningBool = tokenArray[0].constructor === Boolean ? tokenArray[0] : selectProperty(state, tokenArray[0], bindFor, bindForKey);
  for (i = 1; i < tokenArray.length; i += 2) {
    if (tokenArray[i] !== OR && tokenArray[i] !== AND) {
      continue;
    }
    // Check if was evaluated comparison (bool) or a selector (string).
    tokenArray[i + 1] = tokenArray[i + 1].constructor === Boolean ? tokenArray[i + 1] : selectProperty(state, tokenArray[i + 1]);

    // Evaluate boolean.
    if (tokenArray[i] === OR) {
      runningBool = runningBool || tokenArray[i + 1];
    } else if (tokenArray[i] === AND) {
      runningBool = runningBool && tokenArray[i + 1];
    }
  }
  return runningBool;
}
module.exports.select = select;

/**
 * Does actual selecting and walking of state.
 */
function selectProperty(state, selector, bindFor, bindForKey) {
  var i;
  var originalSelector;
  var splitted;
  var value;

  // If bindFor, select the array. Then later, we filter the array.
  if (bindFor && selector.startsWith(bindFor.for)) {
    originalSelector = selector;
    selector = bindFor.in;
  }

  // Walk.
  value = state;
  splitted = split(stripNot(selector), '.');
  for (i = 0; i < splitted.length; i++) {
    if (i < splitted.length - 1 && !(splitted[i] in value)) {
      console.error('[state] Not found:', splitted, splitted[i]);
    }
    value = value[splitted[i]];
  }

  if (bindFor && originalSelector.startsWith(bindFor.for)) {
    // Simple array.
    if (!bindFor.key) {
      return value[bindForKey];
    }
    // Array of objects.
    for (i = 0; i < value.length; i++) {
      if (value[i][bindFor.key] !== bindForKey) {
        continue;
      }
      value = selectProperty(value[i], originalSelector.replace(bindFor.for + '.', ''));
      break;
    }
  }

  // Boolean.
  if (selector[0] === '!' && selector[1] === '!') {
    return !!value;
  }
  if (selector[0] === '!') {
    return !value;
  }
  return value;
}
module.exports.selectProperty = selectProperty;

function clearObject(obj) {
  for (var key in obj) {
    delete obj[key];
  }
}
module.exports.clearObject = clearObject;

/**
 * Helper to compose object of handlers, merging functions handling same action.
 */
function composeHandlers() {
  var actionName;
  var i;
  var inputHandlers = arguments;
  var outputHandlers;

  outputHandlers = {};
  for (i = 0; i < inputHandlers.length; i++) {
    for (actionName in inputHandlers[i]) {
      if (actionName in outputHandlers) {
        // Initial compose/merge functions into arrays.
        if (outputHandlers[actionName].constructor === Array) {
          outputHandlers[actionName].push(inputHandlers[i][actionName]);
        } else {
          outputHandlers[actionName] = [outputHandlers[actionName], inputHandlers[i][actionName]];
        }
      } else {
        outputHandlers[actionName] = inputHandlers[i][actionName];
      }
    }
  }

  // Compose functions specified via array.
  for (actionName in outputHandlers) {
    if (outputHandlers[actionName].constructor === Array) {
      outputHandlers[actionName] = composeFunctions.apply(this, outputHandlers[actionName]);
    }
  }

  return outputHandlers;
}
module.exports.composeHandlers = composeHandlers;

function composeFunctions() {
  var functions = arguments;
  return function () {
    var i;
    for (i = 0; i < functions.length; i++) {
      functions[i].apply(this, arguments);
    }
  };
}
module.exports.composeFunctions = composeFunctions;

var NO_WATCH_TOKENS = ['||', '&&', '!=', '!==', '==', '==='];
function parseKeysToWatch(keys, str, isBindItem) {
  var i;
  var tokens;
  tokens = str.split(/\s+/);
  for (i = 0; i < tokens.length; i++) {
    if (NO_WATCH_TOKENS.indexOf(tokens[i]) === -1 && !tokens[i].startsWith("'") && keys.indexOf(tokens[i]) === -1) {
      if (isBindItem && tokens[i] === 'item') {
        continue;
      }
      keys.push(parseKeyToWatch(tokens[i]));
    }
  }
}
module.exports.parseKeysToWatch = parseKeysToWatch;

function parseKeyToWatch(str) {
  var dotIndex;
  str = stripNot(str.trim());
  dotIndex = str.indexOf('.');
  if (dotIndex === -1) {
    return str;
  }
  return str.substring(0, str.indexOf('.'));
}

function stripNot(str) {
  if (str.indexOf('!!') === 0) {
    return str.replace('!!', '');
  } else if (str.indexOf('!') === 0) {
    return str.replace('!', '');
  }
  return str;
}

/**
 * Cached split.
 */
var SPLIT_CACHE = {};
function split(str, delimiter) {
  if (!SPLIT_CACHE[delimiter]) {
    SPLIT_CACHE[delimiter] = {};
  }
  if (SPLIT_CACHE[delimiter][str]) {
    return SPLIT_CACHE[delimiter][str];
  }
  SPLIT_CACHE[delimiter][str] = str.split(delimiter);
  return SPLIT_CACHE[delimiter][str];
}
module.exports.split = split;

function copyArray(dest, src) {
  var i;
  dest.length = 0;
  for (i = 0; i < src.length; i++) {
    dest[i] = src[i];
  }
}
module.exports.copyArray = copyArray;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(2);
var diff = __webpack_require__(3);
var lib = __webpack_require__(0);
var wrapArray = __webpack_require__(4).wrapArray;

// Singleton state definition.
var State = {
  initialState: {},
  nonBindedStateKeys: [],
  handlers: {},
  computeState: function computeState() {/* no-op */}
};

var STATE_UPDATE_EVENT = 'stateupdate';
var TYPE_OBJECT = 'object';
var WHITESPACE_REGEX = /s+/;

AFRAME.registerState = function (definition) {
  AFRAME.utils.extend(State, definition);
};

AFRAME.registerSystem('state', {
  init: function init() {
    var _this = this;

    var key;

    this.diff = {};
    this.state = AFRAME.utils.clone(State.initialState);
    this.subscriptions = [];
    this.initEventHandlers();

    // Wrap array to detect dirty.
    for (key in this.state) {
      if (this.state[key] && this.state[key].constructor === Array) {
        this.state[key].__dirty = true;
        wrapArray(this.state[key]);
      }
    }

    this.lastState = AFRAME.utils.clone(this.state);

    this.eventDetail = {
      lastState: this.lastState,
      state: this.state
    };

    this.el.addEventListener('loaded', function () {
      var i;
      // Initial compute.
      State.computeState(_this.state, '@@INIT');
      // Initial dispatch.
      for (i = 0; i < _this.subscriptions.length; i++) {
        _this.subscriptions[i].onStateUpdate(_this.state);
      }
    });
  },

  /**
   * Dispatch action.
   */
  dispatch: function dispatch(actionName, payload) {
    var i;
    var key;
    var subscription;

    // Modify state.
    State.handlers[actionName](this.state, payload);

    // Post-compute.
    State.computeState(this.state, actionName, payload);

    // Get a diff to optimize bind updates.
    for (key in this.diff) {
      delete this.diff[key];
    }
    diff(this.lastState, this.state, this.diff, State.nonBindedStateKeys);

    // Notify subscriptions / binders.
    for (i = 0; i < this.subscriptions.length; i++) {
      if (this.subscriptions[i].name === 'bind-for') {
        // For arrays and bind-for, check __dirty flag on array rather than the diff.
        if (!this.state[this.subscriptions[i].keysToWatch[0]].__dirty) {
          continue;
        }
      } else {
        if (!this.shouldUpdate(this.subscriptions[i].keysToWatch, this.diff)) {
          continue;
        }
      }

      this.subscriptions[i].onStateUpdate();
    }

    // Unset array dirty.
    for (key in this.state) {
      if (this.state[key] && this.state[key].constructor === Array) {
        this.state[key].__dirty = false;
      }
    }

    // Store last state.
    // TODO: copyState messes with the diff.
    this.copyState(this.lastState, this.state);

    // Emit.
    this.eventDetail.action = actionName;
    this.eventDetail.payload = payload;
    this.el.emit(STATE_UPDATE_EVENT, this.eventDetail);
  },

  /**
   * Store last state through a deep extend, but not for arrays.
   */
  copyState: function copyState(lastState, state, isRecursive) {
    var key;

    for (key in state) {
      // Don't copy pieces of state keys that are non-binded or untracked.
      if (!isRecursive && State.nonBindedStateKeys.indexOf(key) !== -1) {
        continue;
      }

      // Nested state.
      if (state[key] && state[key].constructor === Object) {
        if (!(key in lastState)) {
          // Clone object if destination does not exist.
          lastState[key] = AFRAME.utils.clone(state[key]);
          continue;
        }
        // Recursively copy state.
        this.copyState(lastState[key], state[key], true);
        continue;
      }

      // Copy by value.
      lastState[key] = state[key];
    }
  },

  subscribe: function subscribe(component) {
    this.subscriptions.push(component);
  },

  unsubscribe: function unsubscribe(component) {
    this.subscriptions.splice(this.subscriptions.indexOf(component), 1);
  },

  /**
   * Check if state changes were relevant to this binding. If not, don't call.
   */
  shouldUpdate: function shouldUpdate(keysToWatch, diff) {
    var stateKey;
    for (stateKey in diff) {
      if (keysToWatch.indexOf(stateKey) !== -1) {
        return true;
      }
    }
    return false;
  },

  /**
   * Proxy events to action dispatches so components can just bubble actions up as events.
   * Handlers define which actions they handle. Go through all and add event listeners.
   */
  initEventHandlers: function initEventHandlers() {
    var actionName;
    var registeredActions = [];
    var self = this;

    registerListener = registerListener.bind(this);

    // Use declared handlers to know what events to listen to.
    for (actionName in State.handlers) {
      // Only need to register one handler for each event.
      if (registeredActions.indexOf(actionName) !== -1) {
        continue;
      }
      registeredActions.push(actionName);
      registerListener(actionName);
    }

    function registerListener(actionName) {
      var _this2 = this;

      this.el.addEventListener(actionName, function (evt) {
        _this2.dispatch(actionName, evt.detail);
      });
    }
  },

  /**
   * Render template to string with item data.
   */
  renderTemplate: function () {
    // Braces, whitespace, optional item name, item key, whitespace, braces.
    var interpRegex = /{{\s*(\w*\.)?([\w.]+)\s*}}/g;

    return function (template, data, asString) {
      var match;
      var str;

      str = template;

      // Data will be null if initialize pool for bind-for.updateInPlace.
      if (data) {
        while (match = interpRegex.exec(template)) {
          str = str.replace(match[0], (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === TYPE_OBJECT ? lib.select(data, match[2]) || '' : data);
        }
      }

      // Return as string.
      if (asString) {
        return str;
      }

      // Return as DOM.
      return document.createRange().createContextualFragment(str);
    };
  }(),

  select: lib.select
});

/**
 * Bind component property to a value in state.
 *
 * bind="geometry.width: car.width""
 * bind__material="color: enemy.color; opacity: enemy.opacity"
 * bind__visible="player.visible"
 */
AFRAME.registerComponent('bind', {
  schema: {
    default: {},
    parse: function parse(value) {
      // Parse style-like object.
      var data;
      var i;
      var properties;
      var pair;

      // Using setAttribute with object, no need to parse.
      if (value.constructor === Object) {
        return value;
      }

      // Using instanced ID as component namespace for single-property component,
      // nothing to separate.
      if (value.indexOf(':') === -1) {
        return value;
      }

      // Parse style-like object as keys to values.
      data = {};
      properties = lib.split(value, ';');
      for (i = 0; i < properties.length; i++) {
        pair = lib.split(properties[i].trim(), ':');
        data[pair[0]] = pair[1].trim();
      }
      return data;
    }
  },

  multiple: true,

  init: function init() {
    var bindForEl;
    var bindForName;
    var componentId;
    var data = this.data;
    var key;

    this.keysToWatch = [];
    this.onStateUpdate = this.onStateUpdate.bind(this);
    this.system = this.el.sceneEl.systems.state;

    // Whether we are binding by namespace (e.g., bind__foo="prop1: true").
    if (this.id) {
      componentId = lib.split(this.id, '__')[0];
    }
    this.isNamespacedBind = this.id && componentId in AFRAME.components && !AFRAME.components[componentId].isSingleProp || componentId in AFRAME.systems;

    this.lastData = {};
    this.updateObj = {};

    // Subscribe to store and register handler to do data-binding to components.
    this.system.subscribe(this);

    this.rootEl = this.el.closest('[data-bind-for-key]');
    this.onStateUpdate = this.onStateUpdate.bind(this);
  },

  update: function update() {
    var bindForEl;
    var data = this.data;
    var key;
    var property;

    // Index `keysToWatch` to only update state on relevant changes.
    this.keysToWatch.length = 0;
    if (typeof data === 'string') {
      lib.parseKeysToWatch(this.keysToWatch, data);
    } else {
      for (key in data) {
        lib.parseKeysToWatch(this.keysToWatch, data[key]);
      }
    }

    // Check if any properties are part of an iteration in bind-for.
    bindForEl = this.el.closest('[bind-for]');
    if (bindForEl && bindForEl !== this.el) {
      this.bindForEl = bindForEl;
      this.bindRootEl = this.el.closest('[data-bind-for-key]');
      this.bindFor = this.bindForEl.getAttribute('bind-for');
      this.bindForKey = this.bindRootEl.getAttribute('data-bind-for-key');
      this.keysToWatch.push(this.bindFor.in);
      this.rootEl.addEventListener('bindforupdate', this.onStateUpdate);
    } else {
      this.bindFor = '';
      this.bindForKey = '';
    }

    // Update.
    this.onStateUpdate();
  },

  /**
   * Handle state update.
   */
  onStateUpdate: function onStateUpdate() {
    // Update component with the state.
    var hasKeys = false;
    var el = this.el;
    var propertyName;
    var stateSelector;
    var state;
    var tempNode;
    var value;

    if (!el.parentNode) {
      return;
    }
    if (this.isNamespacedBind) {
      lib.clearObject(this.updateObj);
    }

    state = this.system.state;

    // Update bind-for-key if necessary if simple list of strings.
    // Sort of a hack.
    if (this.bindFor && this.bindForKey !== undefined && !this.bindFor.key) {
      tempNode = el;
      while (tempNode.parentNode && tempNode.parentNode !== this.bindForEl) {
        if (tempNode.parentNode) {
          tempNode = tempNode.parentNode;
        }
      }
      this.bindForKey = parseInt(tempNode.dataset.bindForKey, 10);
    }

    // Single-property bind.
    if (_typeof(this.data) !== TYPE_OBJECT) {
      try {
        value = lib.select(state, this.data, this.bindFor, this.bindForKey);
      } catch (e) {
        throw new Error('[aframe-state-component] Key \'' + this.data + '\' not found in state.' + (' #' + this.el.getAttribute('id') + '[' + this.attrName + ']'));
      }

      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== TYPE_OBJECT && _typeof(this.lastData) !== TYPE_OBJECT && this.lastData === value) {
        return;
      }

      AFRAME.utils.entity.setComponentProperty(el, this.id, value);
      this.lastData = value;
      return;
    }

    for (propertyName in this.data) {
      // Pointer to a value in the state (e.g., `player.health`).
      stateSelector = this.data[propertyName].trim();
      try {
        value = lib.select(state, stateSelector, this.bindFor, this.bindForKey);
        if (this.bindFor && value === undefined) {
          return;
        }
      } catch (e) {
        throw new Error('[aframe-state-component] Key \'' + stateSelector + '\' not found in state.' + (' #' + this.el.getAttribute('id') + '[' + this.attrName + ']'));
      }

      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== TYPE_OBJECT && _typeof(this.lastData[propertyName]) !== TYPE_OBJECT && this.lastData[propertyName] === value) {
        continue;
      }

      // Remove component if value is `undefined`.
      if (propertyName in AFRAME.components && value === undefined) {
        el.removeAttribute(propertyName);
        return;
      }

      // Set using dot-delimited property name.
      if (this.isNamespacedBind) {
        // Batch if doing namespaced bind.
        this.updateObj[propertyName] = value;
      } else {
        AFRAME.utils.entity.setComponentProperty(el, propertyName, value);
      }

      this.lastData[propertyName] = value;
    }

    // Batch if doing namespaced bind.
    for (hasKeys in this.updateObj) {
      // See if object is empty.
    }
    if (this.isNamespacedBind && hasKeys) {
      el.setAttribute(this.id, this.updateObj);
    }
  },

  remove: function remove() {
    this.system.unsubscribe(this);
    if (this.bindForEl) {
      this.bindForEl.removeEventListener('bindforupdate', this.onStateUpdate);
    }
  }
});

/**
 * Toggle component attach and detach based on boolean value.
 *
 * bind__raycastable="isRaycastable""
 */
AFRAME.registerComponent('bind-toggle', {
  schema: { type: 'string' },

  multiple: true,

  init: function init() {
    this.system = this.el.sceneEl.systems.state;
    this.keysToWatch = [];
    this.onStateUpdate = this.onStateUpdate.bind(this);

    // Subscribe to store and register handler to do data-binding to components.
    this.system.subscribe(this);

    this.onStateUpdate();
  },

  update: function update() {
    this.keysToWatch.length = 0;
    lib.parseKeysToWatch(this.keysToWatch, this.data);
  },

  /**
   * Handle state update.
   */
  onStateUpdate: function onStateUpdate() {
    var el = this.el;
    var state;
    var value;

    state = this.system.state;

    try {
      value = lib.select(state, this.data);
    } catch (e) {
      throw new Error('[aframe-state-component] Key \'' + this.data + '\' not found in state.' + (' #' + this.el.getAttribute('id') + '[' + this.attrName + ']'));
    }

    if (value) {
      el.setAttribute(this.id, '');
    } else {
      el.removeAttribute(this.id);
    }
  },

  remove: function remove() {
    this.system.unsubscribe(this);
  }
});

module.exports = {
  composeFunctions: lib.composeFunctions,
  composeHandlers: lib.composeHandlers,
  select: lib.select
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var lib = __webpack_require__(0);

var ITEM_PREFIX_RE = /item./;
var ITEM_SELECTOR_RE = /item.(\w+)/;

/**
 * Render array from state.
 */
AFRAME.registerComponent('bind-for', {
  schema: {
    delay: { default: 0 },
    for: { type: 'string', default: 'item' },
    in: { type: 'string' },
    key: { type: 'string' },
    pool: { default: 0 },
    template: { type: 'string' },
    updateInPlace: { default: false }
  },

  init: function init() {
    // Subscribe to store and register handler to do data-binding to components.
    this.system = this.el.sceneEl.systems.state;
    this.onStateUpdate = this.onStateUpdate.bind(this);

    this.keysToWatch = [];
    this.renderedKeys = []; // Keys that are currently rendered.
    this.system.subscribe(this);

    if (this.el.children[0] && this.el.children[0].tagName === 'TEMPLATE') {
      this.template = this.el.children[0].innerHTML.trim();
    } else {
      this.template = document.querySelector(this.data.template).innerHTML.trim();
    }

    for (var _i = 0; _i < this.data.pool; _i++) {
      this.el.appendChild(this.generateFromTemplate(null, _i));
    }
  },

  update: function update() {
    this.keysToWatch[0] = lib.split(this.data.in, '.')[0];
    this.onStateUpdate();
  },

  /**
   * When items are swapped out, the old ones are removed, and new ones are added. All
   * entities will be reinitialized.
   */
  onStateUpdateNaive: function () {
    var activeKeys = [];

    return function () {
      var child;
      var data = this.data;
      var el = this.el;
      var list;
      var key;
      var keyValue;

      try {
        list = lib.select(this.system.state, data.in);
      } catch (e) {
        throw new Error('[aframe-state-component] Key \'' + data.in + '\' not found in state.' + (' #' + el.getAttribute('id') + '[' + this.attrName + ']'));
      }

      activeKeys.length = 0;
      for (var _i2 = 0; _i2 < list.length; _i2++) {
        var item = list[_i2];
        // If key not defined, use index (e.g., array of strings).
        activeKeys.push(data.key ? item[data.key].toString() : item.toString());
      }

      // Remove items by removing entities.
      var toRemoveEls = this.getElsToRemove(activeKeys, this.renderedKeys);
      for (i = 0; i < toRemoveEls.length; i++) {
        toRemoveEls[i].parentNode.removeChild(toRemoveEls[i]);
      }

      if (list.length) {
        this.renderItems(list, activeKeys, 0);
      }
    };
  }(),

  /**
   * Add or update item with delay support.
   */
  renderItems: function renderItems(list, activeKeys, i) {
    var _this = this;

    var data = this.data;
    var el = this.el;
    var itemEl;
    var item = list[i];

    // If key not defined, use index (e.g., array of strings).
    keyValue = data.key ? item[data.key].toString() : item.toString();

    if (this.renderedKeys.indexOf(keyValue) === -1) {
      // Add.
      itemEl = this.generateFromTemplate(item, i);
      el.appendChild(itemEl);
      this.renderedKeys.push(keyValue);
    } else {
      // Update.
      if (list.length && list[0].constructor === String) {
        // Update index for simple list.
        var _keyValue = data.key ? item[data.key].toString() : item.toString();
        itemEl = el.querySelector('[data-bind-for-value="' + _keyValue + '"]');
        itemEl.setAttribute('data-bind-for-key', i);
      } else {
        var bindForKey = this.getBindForKey(item, i);
        itemEl = el.querySelector('[data-bind-for-key="' + bindForKey + '"]');
      }
      itemEl.emit('bindforupdate', item, false);
    }

    if (!list[i + 1]) {
      return;
    }

    if (this.data.delay) {
      setTimeout(function () {
        _this.renderItems(list, activeKeys, i + 1);
      }, this.data.delay);
    } else {
      this.renderItems(list, activeKeys, i + 1);
    }
  },

  /**
   * When items are swapped out, this algorithm will update component values in-place using
   * bind-item.
   */
  onStateUpdateInPlace: function () {
    var activeKeys = [];

    return function () {
      var data = this.data;
      var el = this.el;
      var list;
      var key;
      var keyValue;

      try {
        list = lib.select(this.system.state, data.in);
      } catch (e) {
        throw new Error('[aframe-state-component] Key \'' + data.in + '\' not found in state.' + (' #' + el.getAttribute('id') + '[' + this.attrName + ']'));
      }

      // Calculate keys that should be active.
      activeKeys.length = 0;
      for (var _i3 = 0; _i3 < list.length; _i3++) {
        var item = list[_i3];
        keyValue = data.key ? item[data.key].toString() : item.toString();
        activeKeys.push(keyValue);
      }

      // Remove items by pooling. Do before adding.
      var toRemoveEls = this.getElsToRemove(activeKeys, this.renderedKeys);
      for (var _i4 = 0; _i4 < toRemoveEls.length; _i4++) {
        toRemoveEls[_i4].object3D.visible = false;
        toRemoveEls[_i4].setAttribute('data-bind-for-active', 'false');
        toRemoveEls[_i4].removeAttribute('data-bind-for-key');
        toRemoveEls[_i4].removeAttribute('data-bind-for-value');
        toRemoveEls[_i4].emit('bindfordeactivate', null, false);
        toRemoveEls[_i4].pause();
      }

      if (list.length) {
        this.renderItemsInPlace(list, activeKeys, 0);
      }
    };
  }(),

  /**
   * Add, takeover, or update item with delay support.
   */
  renderItemsInPlace: function renderItemsInPlace(list, activeKeys, i) {
    var _this2 = this;

    var data = this.data;
    var el = this.el;
    var itemEl;

    var item = list[i];
    var bindForKey = this.getBindForKey(item, i);
    var keyValue = data.key ? item[data.key].toString() : item.toString();

    // Add item.
    if (this.renderedKeys.indexOf(keyValue) === -1) {
      if (!el.querySelector(':scope > [data-bind-for-active="false"]')) {
        // No items available in pool. Generate new entity.
        var _itemEl = this.generateFromTemplate(item, i);
        _itemEl.addEventListener('loaded', function () {
          _itemEl.emit('bindforupdateinplace', item, false);
        });
        el.appendChild(_itemEl);
      } else {
        // Take over inactive item.
        itemEl = el.querySelector('[data-bind-for-active="false"]');
        itemEl.setAttribute('data-bind-for-key', bindForKey);
        itemEl.setAttribute('data-bind-for-value', keyValue);
        itemEl.object3D.visible = true;
        itemEl.play();
        itemEl.setAttribute('data-bind-for-active', 'true');
        itemEl.emit('bindforupdateinplace', item, false);
      }
      this.renderedKeys.push(keyValue);
    } else if (activeKeys.indexOf(keyValue) !== -1) {
      // Update item.
      if (list.length && list[0].constructor === String) {
        // Update index for simple list.
        itemEl = el.querySelector('[data-bind-for-value="' + keyValue + '"]');
        itemEl.setAttribute('data-bind-for-key', i);
      } else {
        itemEl = el.querySelector('[data-bind-for-key="' + bindForKey + '"]');
      }
      itemEl.emit('bindforupdateinplace', item, false);
    }

    if (!list[i + 1]) {
      return;
    }

    if (this.data.delay) {
      setTimeout(function () {
        _this2.renderItemsInPlace(list, activeKeys, i + 1);
      }, this.data.delay);
    } else {
      this.renderItemsInPlace(list, activeKeys, i + 1);
    }
  },

  /**
   * Generate entity from template.
   */
  generateFromTemplate: function generateFromTemplate(item, i) {
    var data = this.data;

    this.el.appendChild(this.system.renderTemplate(this.template, item));
    var newEl = this.el.children[this.el.children.length - 1];;

    // From pool.true
    if (!item) {
      newEl.setAttribute('data-bind-for-key', '');
      newEl.setAttribute('data-bind-for-active', 'false');
      return newEl;
    }

    var bindForKey = this.getBindForKey(item, i);
    newEl.setAttribute('data-bind-for-key', bindForKey);
    if (!data.key) {
      newEl.setAttribute('data-bind-for-value', item);
    }

    // Keep track of pooled and non-pooled entities if updating in place.
    newEl.setAttribute('data-bind-for-active', 'true');
    return newEl;
  },

  /**
   * Get entities marked for removal.
   *
   * @param {array} activeKeys - List of key values that should be active.
   * @param {array} renderedKeys - List of key values currently rendered.
   */
  getElsToRemove: function () {
    var toRemove = [];

    return function (activeKeys, renderedKeys) {
      var data = this.data;
      var el = this.el;

      toRemove.length = 0;
      for (var _i5 = 0; _i5 < el.children.length; _i5++) {
        if (el.children[_i5].tagName === 'TEMPLATE') {
          continue;
        }
        var key = data.key ? el.children[_i5].getAttribute('data-bind-for-key') : el.children[_i5].getAttribute('data-bind-for-value');
        if (activeKeys.indexOf(key) === -1 && renderedKeys.indexOf(key) !== -1) {
          toRemove.push(el.children[_i5]);
          renderedKeys.splice(renderedKeys.indexOf(key), 1);
        }
      }
      return toRemove;
    };
  }(),

  /**
   * Get value to use as the data-bind-for-key.
   * For items, will be value specified by `bind-for.key`.
   * For simple list, will be the index.
   */
  getBindForKey: function getBindForKey(item, i) {
    return this.data.key ? item[this.data.key].toString() : i.toString();
  },

  /**
   * Handle state update.
   */
  onStateUpdate: function onStateUpdate() {
    if (this.data.updateInPlace) {
      this.onStateUpdateInPlace();
    } else {
      this.onStateUpdateNaive();
    }
  }
});

/**
 * Handle parsing and update in-place updates under bind-for.
 */
AFRAME.registerComponent('bind-item', {
  schema: {
    type: 'string'
  },

  multiple: true,

  init: function init() {
    this.itemData = null;
    this.keysToWatch = [];
    this.prevValues = {};

    // Listen to root item for events.
    var rootEl = this.rootEl = this.el.closest('[data-bind-for-key]');
    if (!rootEl) {
      throw new Error('bind-item component must be attached to entity under a bind-for item.');
    }
    rootEl.addEventListener('bindforupdateinplace', this.updateInPlace.bind(this));
    rootEl.addEventListener('bindfordeactivate', this.deactivate.bind(this));

    this.el.sceneEl.systems.state.subscribe(this);
  },

  update: function update() {
    this.parseSelector();
  },

  /**
   * Run with bind-for tells to via event `bindforupdateinplace`, passing item data.
   */
  updateInPlace: function updateInPlace(evt) {
    var propertyMap = this.propertyMap;

    if (this.rootEl.getAttribute('data-bind-for-active') === 'false') {
      return;
    }

    if (evt) {
      this.itemData = evt.detail;
    }

    for (var property in propertyMap) {
      // Get value from item.
      var value = this.select(this.itemData, propertyMap[property]);

      // Diff against previous value.
      if (value === this.prevValues[property]) {
        continue;
      }

      // Update.
      AFRAME.utils.entity.setComponentProperty(this.el, property, value);

      this.prevValues[property] = value;
    }
  },

  onStateUpdate: function onStateUpdate() {
    this.updateInPlace();
  },

  select: function select(itemData, selector) {
    var value;

    if (selector.indexOf('=') !== -1) {
      // Interpolate.
      var match = selector.match(ITEM_SELECTOR_RE);
      if (match) {
        value = lib.select(itemData, match[0].replace(ITEM_PREFIX_RE, ''));
        selector = selector.replace(ITEM_SELECTOR_RE, "'" + value + "'");
      }

      value = lib.select(this.el.sceneEl.systems.state.state, selector);
    } else {
      // Get value from item.
      value = selector === 'item' ? itemData // Simple list.
      : lib.select(itemData, selector.replace(ITEM_PREFIX_RE, ''));
    }

    return value;
  },

  deactivate: function deactivate() {
    this.prevValues = {};
  },

  parseSelector: function parseSelector() {
    var propertyMap = this.propertyMap = {};
    this.keysToWatch.length = 0;

    var componentName = lib.split(this.id, '__')[0];

    // Different parsing for multi-prop components.
    if (componentName in AFRAME.components && !AFRAME.components[componentName].isSingleProp) {
      var propertySplitList = lib.split(this.data, ';');
      for (var _i6 = 0; _i6 < propertySplitList.length; _i6++) {
        var propertySplit = lib.split(propertySplitList[_i6], ':');
        propertyMap[this.id + '.' + propertySplit[0].trim()] = propertySplit[1].trim();
        lib.parseKeysToWatch(this.keysToWatch, propertySplit[1].trim(), true);
      }
      return;
    }

    propertyMap[this.id] = this.data;
    lib.parseKeysToWatch(this.keysToWatch, this.data, true);
  }
});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Computes the difference between two objects with ability to ignore keys.
 *
 * @param {object} a - First object to compare (e.g., oldData).
 * @param {object} b - Second object to compare (e.g., newData).
 * @returns {object}
 *   Difference object where set of keys note which values were not equal, and values are
 *   `b`'s values.
 */
module.exports = function () {
  var keys = [];

  return function (a, b, targetObject, ignoreKeys) {
    var aVal;
    var bVal;
    var bKey;
    var diff;
    var key;
    var i;
    var isComparingObjects;

    diff = targetObject || {};

    // Collect A keys.
    keys.length = 0;
    for (key in a) {
      keys.push(key);
    }

    if (!b) {
      return diff;
    }

    // Collect B keys.
    for (bKey in b) {
      if (keys.indexOf(bKey) === -1) {
        keys.push(bKey);
      }
    }

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      // Ignore specified keys.
      if (ignoreKeys && ignoreKeys.indexOf(key) !== -1) {
        continue;
      }

      aVal = a[key];
      bVal = b[key];
      isComparingObjects = aVal && bVal && aVal.constructor === Object && bVal.constructor === Object;
      if (isComparingObjects && !AFRAME.utils.deepEqual(aVal, bVal) || !isComparingObjects && aVal !== bVal) {
        diff[key] = bVal;
      }
    }
    return diff;
  };
}();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fns = ['push', 'pop', 'shift', 'unshift', 'splice'];

function wrapArray(arr) {
  var i;
  if (arr.__wrapped) {
    return;
  }
  for (i = 0; i < fns.length; i++) {
    makeCallDirty(arr, fns[i]);
  }
  arr.__wrapped = true;
}
module.exports.wrapArray = wrapArray;

function makeCallDirty(arr, fn) {
  var originalFn = arr[fn];
  arr[fn] = function () {
    originalFn.apply(arr, arguments);
    arr.__dirty = true;
  };
}

/***/ })
/******/ ]);
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/* global AFRAME */
var KEYBOARDS = __webpack_require__(157);

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

var FontFactors = {
  roboto: 17,
  aileronsemibold: 20,
  dejavu: 20.5,
  exo2bold: 20,
  exo2semibold: 20.3,
  kelsonsans: 22.8,
  monoid: 19.5,
  mozillavr: 9.5,
  sourcecodepro: 20.3
};

AFRAME.registerComponent('super-keyboard', {
  schema: {
    align: {default: 'left', oneOf: ['left', 'center', 'right']},
    blinkingSpeed: {type: 'int', default: 400},
    filters: {type: 'array'},
    // roboto aileronsemibold dejavu exo2bold exo2semibold kelsonsans monoid sourcecodepro
    font: {default: 'aileronsemibold'},
    hand: {type: 'selector'},
    imagePath: {default: '.'},
    injectToRaycasterObjects: {default: true},
    inputColor: {type: 'color', default: '#6699ff'},
    interval: {type: 'int', default: 50},
    keyBgColor: {type: 'color', default: '#000'},
    keyColor: {type: 'color', default: '#6699ff'},
    keyHoverColor: {type: 'color', default: '#1A407F'},
    keyPressColor: {type: 'color', default: '#5290F6'},
    label: {type: 'string', default: ''},
    labelColor: {type: 'color', default: '#aaa'},
    maxLength: {type: 'int', default: 0},
    model: {default: 'basic'},
    show: {default: true},
    value: {type: 'string', default: ''},
    width: {default: 0.8}
  },

  init: function () {
    this.el.addEventListener('click', this.click.bind(this));
    this.changeEventDetail = {};
    this.textInputObject = {};

    this.keys = null;
    this.focused = false;
    this.keyHover = null;
    this.prevCheckTime = null;
    this.shift = false;

    this.rawValue = this.data.value;
    this.defaultValue = this.data.value;

    this.userFilterFunc = null;
    this.intervalId = 0;

    // Create keyboard image.
    this.kbImg = document.createElement('a-entity');
    this.kbImg.classList.add('keyboardRaycastable');
    this.kbImg.classList.add('superKeyboardImage');
    this.kbImg.addEventListener('raycaster-intersected', this.hover.bind(this));
    this.kbImg.addEventListener('raycaster-intersected-cleared', this.blur.bind(this));
    this.el.appendChild(this.kbImg);

    // Create label.
    this.label = document.createElement('a-entity');
    this.label.setAttribute('text', {
      align: 'center',
      font: this.data.font,
      baseline: 'bottom',
      lineHeight: 40,
      value: this.data.label,
      color: this.data.labelColor,
      width: this.data.width,
      wrapCount: 30});
    this.el.appendChild(this.label);

    // Create input.
    this.textInput = document.createElement('a-entity');
    this.textInput.setAttribute('text', {
      align: this.data.align,
      font: this.data.font,
      value: this.data.value,
      color: this.data.inputColor,
      width: this.data.width,
      wrapCount: 20
    });
    this.el.appendChild(this.textInput);

    this.cursor = document.createElement('a-entity');
    this.cursor.object3D.position.set(0, 0, 0.001);
    this.cursor.setAttribute('material', {shader: 'flat', color: this.data.inputColor});
    this.textInput.appendChild(this.cursor);
    this.cursorUpdated = false;

    this.keyBgColor = new THREE.Color();
    this.keyHoverColor = new THREE.Color();
    this.keyPressColor = new THREE.Color();

    var self = this;
    document.addEventListener('keydown', function (ev) {
      if (ev.key === 't') {
        var ss = '';
        var s = 'abcdefghijklmopqrstuvQWIEUTGASDLIGKBXACQWETL102394676457';
        var l = Math.floor(Math.random() * 20);
        for (var i = 0; i < l; i++) ss += s[Math.floor(Math.random() * s.length)];
        self.el.setAttribute('super-keyboard', {value: ss});
      }
    });

    document.addEventListener('show', this.open.bind(this));

    this.hand = null;
    this.handListenersSet = false;
    this.raycaster = null;
  },

  update: function (oldData) {
    var kbdata = KEYBOARDS[this.data.model];
    var w = this.data.width;
    var h = this.data.width / 2;
    var w2 = w / 2;
    var h2 = h / 2;

    if (kbdata === undefined) {
      console.error('super-keyboard ERROR: model "' + this.data.model + '" undefined.');
      return;
    }

    if (!oldData || this.defaultValue !== oldData.defaultValue) {
      this.rawValue = this.data.value;
      this.defaultValue = this.data.value;
      this.updateTextInput(this.filter(this.data.value));
    } else {
      this.updateTextInput(this.filter(this.rawValue));
    }

    if (this.data.width !== oldData.width ||
        this.data.height !== oldData.height ||
        this.data.keyColor !== oldData.keyColor) {
      this.kbImg.setAttribute('geometry', {primitive: 'plane', width: w, height: h});
      this.kbImg.setAttribute('material', {
        shader: 'flat',
        src: this.data.imagePath + '/' + kbdata.img,
        color: this.data.keyColor,
        transparent: true
      });
    }

    if (this.data.label !== oldData.label ||
        this.data.labelColor !== oldData.labelColor ||
        this.data.width !== oldData.width) {
      this.label.setAttribute('text', {
        value: this.data.label, color: this.data.labelColor, width: this.data.width});
      this.label.object3D.position.set(0, 0.3 * w, -0.02);
    }

    if (this.data.width !== oldData.width ||
        this.data.keyBgColor !== oldData.keyBgColor) {
      this.initKeyColorPlane();
    }

    var inputx = this.data.align !== 'center' ? kbdata.inputOffsetX * w : 0;
    if (this.data.align === 'right') { inputx *= -1; }

    if (this.data.font !== oldData.font ||
        this.data.inputColor !== oldData.inputColor ||
        this.data.width !== oldData.width ||
        this.data.align !== oldData.align) {
      this.textInput.setAttribute('text', {
        font: this.data.font,
        color: this.data.inputColor,
        width: w,
        wrapCount: kbdata.wrapCount,
        align: this.data.align
      });
    }

    // Some hack where the inputRect is stored in the Insert key.
    for (var i = 0; i < kbdata.layout.length; i++) {
      var kdata = kbdata.layout[i];
      if (kdata.key === 'Insert') {
        this.inputRect = kdata;
      }
    }

    this.textInput.object3D.position.set(
      inputx,
      (w / 4) - (this.inputRect.y + this.inputRect.h / 2) * w / 2 + kbdata.inputOffsetY * w,
      0.002
    );

    if (this.data.width !== oldData.width) {
      this.cursor.setAttribute('geometry', {
        primitive: 'plane', width: 0.03 * w, height: 0.01 * w});
    }

    this.updateCursorPosition();
    this.setupHand();

    this.keyBgColor.set(this.data.keyBgColor);
    this.keyHoverColor.set(this.data.keyHoverColor);
    this.keyPressColor.set(this.data.keyPressColor);

    if (this.data.show) {
      this.open();
    } else {
      this.close();
    }
  },

  tick: function (time) {
    var intersection;

    if (this.prevCheckTime && (time - this.prevCheckTime < this.data.interval)) { return; }
    if (!this.prevCheckTime) {
      this.prevCheckTime = time;
      return;
    }
    if (!this.raycaster) { return; }
    if (!this.focused) { return; }

    intersection = this.raycaster.getIntersection(this.kbImg);
    if (!intersection) { return; }

    var uv = intersection.uv;
    var keys = KEYBOARDS[this.data.model].layout;
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (uv.x > k.x && uv.x < k.x + k.w && (1.0 - uv.y) > k.y && (1.0 - uv.y) < k.y + k.h) {
        if (this.keyHover !== k) {
          // Update key hover.
          this.keyHover = k;
          this.updateKeyColorPlane(this.keyHover.key, this.keyHoverColor);
        }
        break;
      }
    }
  },

  play: function () {
    if (!this.cursorUpdated) { return; }
    this.startBlinking();
  },

  pause: function () {
    this.stopBlinking();
  },

  /**
   * The plane for visual feedback when a key is hovered or clicked
   */
  initKeyColorPlane: function () {
    var keyColorPlane = this.keyColorPlane = document.createElement('a-entity');
    keyColorPlane.classList.add('superKeyboardKeyColorPlane');
    keyColorPlane.object3D.position.z = 0.001;
    keyColorPlane.object3D.visible = false;
    keyColorPlane.setAttribute('geometry', {primitive: 'plane'});
    keyColorPlane.setAttribute('material', {shader: 'flat', color: this.data.keyBgColor,
                                            transparent: true});
    keyColorPlane.addEventListener('componentinitialized', function (evt) {
      if (evt.detail.name !== 'material') { return; }
      this.getObject3D('mesh').material.blending = THREE.AdditiveBlending;
    });
    this.el.appendChild(keyColorPlane);
  },

  /**
   * Move key color plane to appropriate position, scale, and change color.
   */
  updateKeyColorPlane: function (key, color) {
    var kbdata = KEYBOARDS[this.data.model];
    var keyColorPlane = this.keyColorPlane;

    // Unset.
    if (!key) {
      keyColorPlane.object3D.visible = false;
      return;
    }

    for (var i = 0; i < kbdata.layout.length; i++) {
      var kdata = kbdata.layout[i];
      if (kdata.key !== key) { continue; }
      var w = this.data.width;
      var h = this.data.width / 2;
      var w2 = w / 2;
      var h2 = h / 2;
      var keyw = kdata.w * w;
      var keyh = kdata.h * h;
      // Size.
      keyColorPlane.object3D.scale.x = keyw;
      keyColorPlane.object3D.scale.y = keyh;
      // Position.
      keyColorPlane.object3D.position.x = kdata.x * w - w2 + keyw / 2;
      keyColorPlane.object3D.position.y = (1 - kdata.y) * h - h2 - keyh / 2;
      // Color.
      keyColorPlane.getObject3D('mesh').material.color.copy(color);
      break;
    }
    keyColorPlane.object3D.visible = true;
  },

  setupHand: function () {
    if (this.hand && this.hand.ownRaycaster) {
      this.hand.removeAttribute('raycaster');
    }
    if (this.data.hand) {
      this.hand = this.data.hand;
    } else {
      this.hand = document.querySelector([
        '[cursor]',
        '[vive-controls]',
        '[tracked-controls]',
        '[oculus-touch-controls]',
        '[windows-motion-controls]',
        '[hand-controls]',
        '[daydream-controls] [cursor] > [raycaster]'
      ].join(','));
    }

    if (!this.hand) {
      console.error('super-keyboard: no controller found. Add <a-entity> with controller or specify with super-keyboard="hand: #selectorToController".');
    } else {
      if (!this.hand.hasLoaded) {
        this.hand.addEventListener('loaded', this.setupHand.bind(this));
        return;
      }
      var raycaster = this.hand.components['raycaster'];
      var params = {};

      if (!raycaster) {
        this.hand.ownRaycaster = true;
        params.showLine = this.data.show;
        params.enabled = this.data.show;
        if (this.data.injectToRaycasterObjects) {
          params.objects = '.keyboardRaycastable';
        }
        this.hand.setAttribute('raycaster', params);
      } else {
        this.hand.ownRaycaster = false;
        if (this.data.injectToRaycasterObjects) {
          var objs = raycaster.data.objects.split(',');
          if (objs.indexOf('.keyboardRaycastable') === -1) {
            objs.push('.keyboardRaycastable');
          }
          params.objects = objs.join(',').replace(/^,/, '');
          this.hand.setAttribute('raycaster', params);
        }
      }

      this.raycaster = this.hand.components.raycaster;
    }
  },

  filter: function (str) {
    if (str === '') { return ''; }
    for (var i = 0; i < this.data.filters.length; i++) {
      switch (this.data.filters[i]) {
        case 'custom': {
          if (this.userFilterFunc) str = this.userFilterFunc(str);
          break;
        }
        case 'allupper': {
          str = str.toUpperCase();
          break;
        }
        case 'alllower': {
          str = str.toLowerCase();
          break;
        }
        case 'title': {
          str = str.split(' ').map(function (s) { return s[0].toUpperCase() + s.substr(1); }).join(' ');
          break;
        }
        case 'numbers': {
          str = str.split('').filter(function (c) { return !isNaN(parseInt(c)) || c === '.'; }).join('');
          break;
        }
        case 'first': {
          str = str[0].toUpperCase() + str.substr(1);
          break;
        }
        case 'trim': {
          str = str.trim();
          break;
        }
      }
    }
    return this.data.maxLength > 0 ? str.substr(0, this.data.maxLength) : str;
  },

  click: function (ev) {
    if (!this.keyHover) { return; }

    switch (this.keyHover.key) {
      case 'Enter': {
        this.accept();
        break;
      }
      case 'Insert': {
        return;
      }
      case 'Delete': {
        this.rawValue = this.rawValue.substr(0, this.rawValue.length - 1);
        var newValue = this.filter(this.rawValue);
        this.el.setAttribute('super-keyboard', 'value', newValue);
        this.updateTextInput(newValue);
        this.changeEventDetail.value = newValue;
        this.el.emit('superkeyboardchange', this.changeEventDetail);
        break;
      }
      case 'Shift': {
        this.shift = !this.shift;
        this.keyHover.el.setAttribute('material', 'color',
          this.shift ? this.data.keyHoverColor : this.data.keyBgColor
        );
        break;
      }
      case 'Escape': {
        this.dismiss();
        break;
      }
      default: {
        if (this.data.maxLength > 0 && this.rawValue.length > this.data.maxLength) { break; }
        this.rawValue += this.shift ? this.keyHover.key.toUpperCase() : this.keyHover.key;
        var newValue = this.filter(this.rawValue);
        this.el.setAttribute('super-keyboard', 'value', newValue);
        this.updateTextInput(newValue);
        this.changeEventDetail.value = newValue;
        this.el.emit('superkeyboardchange', this.changeEventDetail);
        break;
      }
    }

    this.updateKeyColorPlane(this.keyHover.key, this.keyPressColor);
    var self = this;
    setTimeout(function () {
      self.updateKeyColorPlane(self.keyHover.key, self.keyHoverColor);
    }, 100);
    this.updateCursorPosition();
  },

  open: function () {
    this.el.object3D.visible = true;
    if (this.hand && this.hand.ownRaycaster) {
      this.hand.setAttribute('raycaster', {showLine: true, enabled: true});
    }
  },

  close: function () {
    this.el.object3D.visible = false;
    if (this.hand && this.hand.ownRaycaster) {
      this.hand.setAttribute('raycaster', {showLine: false, enabled: false});
    }
  },

  accept: function () {
    this.el.object3D.visible = false;
    if (this.hand && this.hand.ownRaycaster) {
      this.hand.setAttribute('raycaster', {showLine: false, enabled: false});
    }
    this.el.emit('superkeyboardinput', {value: this.data.value});
    this.data.show = false;
  },

  dismiss: function () {
    this.data.value = this.defaultValue;
    this.updateTextInput();
    this.el.object3D.visible = false;
    if (this.hand && this.hand.ownRaycaster) {
      this.hand.setAttribute('raycaster', {showLine: false, enabled: false});
    }
    this.el.emit('superkeyboarddismiss');
    this.data.show = false;
  },

  blur: function (ev) {
    this.focused = false;
    if (this.keyHover && this.keyHover.key !== 'Shift') {
      this.updateKeyColorPlane(this.keyHover.key, this.keyBgColor);
    }
    this.keyHover = null;
  },

  hover: function (ev) {
    this.focused = true;
  },

  startBlinking: function () {
    this.stopBlinking();
    this.intervalId = window.setInterval(this.blink.bind(this), this.data.blinkingSpeed);
  },

  stopBlinking: function () {
    window.clearInterval(this.intervalId);
    this.intervalId = 0;
  },

  blink: function () {
    this.cursor.object3D.visible = !this.cursor.object3D.visible;
  },

  setCustomFilter: function (f) {
    this.userFilterFunc = f;
  },

  addCustomModel: function (name, model) {
    if (!name) { return; }
    KEYBOARDS[name] = model;
  },

  updateCursorPosition: function () {
    var font = this.textInput.components.text.currentFont;
    if (!font) {
      var self = this;
      this.cursor.object3D.visible = false;
      window.setTimeout(function () {
        self.updateCursorPosition();
        self.startBlinking();
      }, 700);
      return;
    }

    var w = this.data.width;
    var kbdata = KEYBOARDS[this.data.model];
    var posy = -this.inputRect.h / 2 * w / 2.4 + kbdata.inputOffsetY * w;
    var ratio = this.data.width / this.textInput.components.text.data.wrapCount;
    var pos = 0;
    var fontFactor = FontFactors[this.textInput.components.text.data.font];
    if (fontFactor === undefined) { fontFactor = 20; }
    for (var i = 0; i < this.data.value.length; i++) {
      var char = findFontChar(font.chars, this.data.value.charCodeAt(i));
      pos += char.width + char.xadvance * (char.id === 32 ? 2 : 1);
    }
    if (this.data.align === 'center') {
      pos = pos * ratio * fontFactor * 0.0011 / 2.0 + 0.02 * w;
    } else if (this.data.align === 'left') {
      pos = pos * ratio * fontFactor * 0.0011 + 0.02 * w;
      pos -= w / 2;
    } else if (this.data.align === 'right') {
      pos = -pos * ratio * fontFactor * 0.0011 - 0.02 * w;
      pos += w / 2;
    }
    this.cursor.object3D.position.set(pos, posy, 0.001);
    this.cursorUpdated = true;
  },

  updateTextInput: function (value) {
    this.textInputObject.value = value || this.data.value;
    this.textInput.setAttribute('text', this.textInputObject);
  }
});

function findFontChar (chars, code) {
  for (var i = 0; i < chars.length; i++) {
    if (chars[i].id === code) { return chars[i]; }
  }
  return null;
}


/***/ }),
/* 150 */
/***/ (function(module, exports) {

if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available.');
}

// Single audio context.
var context;

/**
 * Audio visualizer system for A-Frame. Share AnalyserNodes between components that share the
 * the `src`.
 */
AFRAME.registerSystem('audioanalyser', {
  init: function () {
    this.analysers = {};
  },

  getOrCreateAnalyser: function (data) {
    if (!context) {
      context = new AudioContext();
    }
    var analysers = this.analysers;
    var analyser = context.createAnalyser();
    var audioEl = data.src;
    var src = audioEl.getAttribute('src');

    if (analysers[src]) {
      return analysers[src];
    }

    var source = context.createMediaElementSource(audioEl);
    source.connect(analyser);
    analyser.connect(context.destination);
    analyser.smoothingTimeConstant = data.smoothingTimeConstant;
    analyser.fftSize = data.fftSize;

    // Store.
    analysers[src] = analyser;
    return analysers[src];
  }
});

/**
 * Audio visualizer component for A-Frame using AnalyserNode.
 */
AFRAME.registerComponent('audioanalyser', {
  schema: {
    enableBeatDetection: { default: true },
    enableLevels: { default: true },
    enableWaveform: { default: true },
    enableVolume: { default: true },
    fftSize: { default: 2048 },
    smoothingTimeConstant: { default: 0.8 },
    src: { type: 'selector' },
    unique: { default: false }
  },

  init: function () {
    this.analyser = null;
    this.levels = null;
    this.waveform = null;
    this.volume = 0;
  },

  update: function () {
    var data = this.data;
    var self = this;
    var system = this.system;

    if (!data.src) {
      return;
    }

    // Get or create AnalyserNode.
    if (data.unique) {
      init(system.createAnalyser(data));
    } else {
      init(system.getOrCreateAnalyser(data));
    }

    function init(analyser) {
      self.analyser = analyser;
      self.levels = new Uint8Array(self.analyser.frequencyBinCount);
      self.waveform = new Uint8Array(self.analyser.fftSize);
      self.el.emit('audioanalyser-ready', { analyser: analyser });
    }
  },

  /**
   * Update spectrum on each frame.
   */
  tick: function () {
    var data = this.data;
    if (!this.analyser) {
      return;
    }

    // Levels (frequency).
    if (data.enableLevels || data.enableVolume) {
      this.analyser.getByteFrequencyData(this.levels);
    }

    // Waveform.
    if (data.enableWaveform) {
      this.analyser.getByteTimeDomainData(this.waveform);
    }

    // Average volume.
    if (data.enableVolume || data.enableBeatDetection) {
      var sum = 0;
      for (var i = 0; i < this.levels.length; i++) {
        sum += this.levels[i];;
      }
      this.volume = sum / this.levels.length;
    }

    // Beat detection.
    if (data.enableBeatDetection) {
      var BEAT_DECAY_RATE = 0.99;
      var BEAT_HOLD = 60;
      var BEAT_MIN = 0.15; // Volume less than this is no beat.

      volume = this.volume;
      if (!this.beatCutOff) {
        this.beatCutOff = volume;
      }
      if (volume > this.beatCutOff && volume > BEAT_MIN) {
        console.log('[audioanalyser] Beat detected.');
        this.el.emit('audioanalyser-beat');
        this.beatCutOff = volume * 1.5;
        this.beatTime = 0;
      } else {
        if (this.beatTime <= BEAT_HOLD) {
          this.beatTime++;
        } else {
          this.beatCutOff *= BEAT_DECAY_RATE;
          this.beatCutOff = Math.max(this.beatCutOff, BEAT_MIN);
        }
      }
    }
  }
});

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(401);

__webpack_require__(408);

__webpack_require__(202);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52)))

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./active-color.js": 172,
	"./analyzer.js": 173,
	"./beat-loader.js": 174,
	"./console-shortcuts.js": 175,
	"./cursor-mesh.js": 176,
	"./debug-controller.js": 177,
	"./debug-cursor.js": 178,
	"./hand-swapper.js": 179,
	"./history.js": 180,
	"./keyboard-raycastable.js": 181,
	"./logoflicker.js": 182,
	"./materials.js": 183,
	"./menu-difficulty-select.js": 184,
	"./menu-selected-challenge-image.js": 185,
	"./pauser.js": 186,
	"./play-sound.js": 187,
	"./preloader.js": 188,
	"./raycastable.js": 189,
	"./recenter.js": 190,
	"./saber-controls.js": 191,
	"./search.js": 192,
	"./song-preview.js": 193,
	"./song.js": 194,
	"./stage-colors.js": 195,
	"./text-uppercase.js": 196,
	"./toggle-pause-play.js": 197,
	"./twister.js": 198
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 152;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./index.js": 201
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 153;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Provides a decorator functor for annotating functions in Component definitions so that they are automatically
 * bound and unbound from events without needing to call el.addEventListener or el.removeEventListener yourself.
 *
 * Decorations should be made in the Components definition object. Here is the simplest example:
 *
 * const {bindEvent} = require('event-binder');
 *
 * AFRAME.registerComponent("foo", {
 *   componentchanged: bindEvent( function(evt) {
 *     console.log(evt.detail);
 *   })
 * })
 *
 * By default the function will be bound to events corresponding to its property name, in this case: 'componentchanged'.
 * It will listen for events on its parent element, and will begin listening or end listening when init or remove is
 * called. However this can also be configured by passing a configuration object:
 *
 * AFRAME.registerComponent("foo", {
 *   whenSceneLoads: bindEvent( {
 *     event: "loaded",    // Event to listen for. Defaults to functions propery name.
 *     target: "a-scene",  // Selector string for which element to listen on, defaults to this.el
 *     listenIn: "init",   // Which function addEventListener is called in, defaults to 'init'
 *     removeIn: "remove", // Which function removeEventListener is called in, defaults to 'remove'
 *   }, function(evt) {
 *     console.log(evt.detail);
 *   })
 * })
 *
 * Functions will only be bound to events when a new component is created. Decorating a function with bindEvent()
 * in a components init, or tick functions for example will have no effect.
 *
 * Don't bind to arrow functions because they don't have their own this.
 *
 */

const decorate = __webpack_require__(98).decorate;

// Implements the automatic binding and unbinding of the chosen function. Wraps its listenIn and removeIn
// functions to add and remove the event listener at the correct times.
function BindToEventDecorator(_event, _target, _listenIn, _removeIn) {
  return function(propertyName, func) {
    const scope = this;
    const event = _event || propertyName;
    const target = !_target ? this.el : document.querySelector(_target);
    if (!target) {
      console.warn("Couldn't subscribe "+this.name+"."+propertyName+" to "+event+" on "+_target
        +" because querySelector returned undefined.");
      return;
    }
    const listenIn = _listenIn || "init";
    const removeIn = _removeIn || "remove";

    const listenFunc = this[listenIn];
    const removeFunc = this[removeIn];
    const boundFunc = func.bind(this);
    
    this[listenIn] = function() {
      if (listenFunc !== undefined) {
        listenFunc.apply(scope, arguments);
      }
      target.addEventListener(event, boundFunc);
    }

    this[removeIn] = function() {
      if (removeFunc !== undefined) {
        removeFunc.apply(scope, arguments);
      }
      target.removeEventListener(event, boundFunc);
    }

    return func;
  }
}

/*
 * Decorates a function with configurations for automatically binding to an event.
 *
 * @param p1 - If this is a function it will be decorated with default options and p2 is ignored. Otherwise this can be
 *   an object which fine tunes the binding.
 * @param p2 - If p1 is an object then this will be the function to bind to.
 *
 * @returns {function} Decorated function which wraps the input function.
 */
function bindEvent(p1, p2) {
  if (typeof p1 === "function") {
    return decorate(p1, BindToEventDecorator());
  } else if (typeof p1 === "object" && typeof p2 === "function") {
    return decorate(p2, BindToEventDecorator(p1.event, p1.target, p1.listenIn, p1.removeIn));
  } else {
    throw new Error("bindEvent must take: (function), or a ([object], function)")
  }
}

/*
 * Convenience function, will always bind/unbind listener in play/pause function, rather than the default init/remove
 */
function bindEventPlayPause (p1, p2) {
  if (typeof p1 === "function") {
    return decorate(p1, BindToEventDecorator(undefined, undefined, "play", "pause"));
  } else if (typeof p1 === "object" && typeof p2 === "function") {
    return decorate(p2, BindToEventDecorator(p1.event, p1.target, "play", "pause"));
  } else {
    throw new Error("bindEventPlayPause must take: (function), or a ([object], function)")
  }
}

module.exports.bindEvent = bindEvent;
module.exports.bindEventPlayPause = bindEventPlayPause;

/***/ }),
/* 155 */
/***/ (function(module, exports) {

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe

THREE.OrbitControls = function ( object, domElement ) {

	this.object = object;

	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new THREE.Vector3();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = - Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;

	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;

	};

	this.saveState = function () {

		scope.target0.copy( scope.target );
		scope.position0.copy( scope.object.position );
		scope.zoom0 = scope.object.zoom;

	};

	this.reset = function () {

		scope.target.copy( scope.target0 );
		scope.object.position.copy( scope.position0 );
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent( changeEvent );

		scope.update();

		state = STATE.NONE;

	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = function () {

		var offset = new THREE.Vector3();

		// so camera.up is the orbit axis
		var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
		var quatInverse = quat.clone().inverse();

		var lastPosition = new THREE.Vector3();
		var lastQuaternion = new THREE.Quaternion();

		return function update() {

			var position = scope.object.position;

			offset.copy( position ).sub( scope.target );

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion( quat );

			// angle from z-axis around y-axis
			spherical.setFromVector3( offset );

			if ( scope.autoRotate && state === STATE.NONE ) {

				rotateLeft( getAutoRotationAngle() );

			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

			// restrict phi to be between desired limits
			spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

			spherical.makeSafe();


			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

			// move target to panned location
			scope.target.add( panOffset );

			offset.setFromSpherical( spherical );

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion( quatInverse );

			position.copy( scope.target ).add( offset );

			scope.object.lookAt( scope.target );

			if ( scope.enableDamping === true ) {

				sphericalDelta.theta *= ( 1 - scope.dampingFactor );
				sphericalDelta.phi *= ( 1 - scope.dampingFactor );

			} else {

				sphericalDelta.set( 0, 0, 0 );

			}

			scale = 1;
			panOffset.set( 0, 0, 0 );

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if ( zoomChanged ||
				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

				scope.dispatchEvent( changeEvent );

				lastPosition.copy( scope.object.position );
				lastQuaternion.copy( scope.object.quaternion );
				zoomChanged = false;

				return true;

			}

			return false;

		};

	}();

	this.dispose = function () {

		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
		scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		window.removeEventListener( 'keydown', onKeyDown, false );

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new THREE.Spherical();
	var sphericalDelta = new THREE.Spherical();

	var scale = 1;
	var panOffset = new THREE.Vector3();
	var zoomChanged = false;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	}

	function getZoomScale() {

		return Math.pow( 0.95, scope.zoomSpeed );

	}

	function rotateLeft( angle ) {

		sphericalDelta.theta -= angle;

	}

	function rotateUp( angle ) {

		sphericalDelta.phi -= angle;

	}

	var panLeft = function () {

		var v = new THREE.Vector3();

		return function panLeft( distance, objectMatrix ) {

			v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
			v.multiplyScalar( - distance );

			panOffset.add( v );

		};

	}();

	var panUp = function () {

		var v = new THREE.Vector3();

		return function panUp( distance, objectMatrix ) {

			v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
			v.multiplyScalar( distance );

			panOffset.add( v );

		};

	}();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = function () {

		var offset = new THREE.Vector3();

		return function pan( deltaX, deltaY ) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if ( scope.object.isPerspectiveCamera ) {

				// perspective
				var position = scope.object.position;
				offset.copy( position ).sub( scope.target );
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

				// we actually don't use screenWidth, since perspective camera is fixed to screen height
				panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
				panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

			} else if ( scope.object.isOrthographicCamera ) {

				// orthographic
				panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
				panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

			} else {

				// camera neither orthographic nor perspective
				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
				scope.enablePan = false;

			}

		};

	}();

	function dollyIn( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) {

			scale /= dollyScale;

		} else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	function dollyOut( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) {

			scale *= dollyScale;

		} else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate( event ) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownDolly( event ) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownPan( event ) {

		//console.log( 'handleMouseDownPan' );

		panStart.set( event.clientX, event.clientY );

	}

	function handleMouseMoveRotate( event ) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set( event.clientX, event.clientY );
		rotateDelta.subVectors( rotateEnd, rotateStart );

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleMouseMoveDolly( event ) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set( event.clientX, event.clientY );

		dollyDelta.subVectors( dollyEnd, dollyStart );

		if ( dollyDelta.y > 0 ) {

			dollyIn( getZoomScale() );

		} else if ( dollyDelta.y < 0 ) {

			dollyOut( getZoomScale() );

		}

		dollyStart.copy( dollyEnd );

		scope.update();

	}

	function handleMouseMovePan( event ) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set( event.clientX, event.clientY );

		panDelta.subVectors( panEnd, panStart );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

		scope.update();

	}

	function handleMouseUp( event ) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel( event ) {

		// console.log( 'handleMouseWheel' );

		if ( event.deltaY < 0 ) {

			dollyOut( getZoomScale() );

		} else if ( event.deltaY > 0 ) {

			dollyIn( getZoomScale() );

		}

		scope.update();

	}

	function handleKeyDown( event ) {

		//console.log( 'handleKeyDown' );

		switch ( event.keyCode ) {

			case scope.keys.UP:
				pan( 0, scope.keyPanSpeed );
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan( 0, - scope.keyPanSpeed );
				scope.update();
				break;

			case scope.keys.LEFT:
				pan( scope.keyPanSpeed, 0 );
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan( - scope.keyPanSpeed, 0 );
				scope.update();
				break;

		}

	}

	function handleTouchStartRotate( event ) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

	}

	function handleTouchStartDolly( event ) {

		//console.log( 'handleTouchStartDolly' );

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		dollyStart.set( 0, distance );

	}

	function handleTouchStartPan( event ) {

		//console.log( 'handleTouchStartPan' );

		panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

	}

	function handleTouchMoveRotate( event ) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
		rotateDelta.subVectors( rotateEnd, rotateStart );

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleTouchMoveDolly( event ) {

		//console.log( 'handleTouchMoveDolly' );

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		dollyEnd.set( 0, distance );

		dollyDelta.subVectors( dollyEnd, dollyStart );

		if ( dollyDelta.y > 0 ) {

			dollyOut( getZoomScale() );

		} else if ( dollyDelta.y < 0 ) {

			dollyIn( getZoomScale() );

		}

		dollyStart.copy( dollyEnd );

		scope.update();

	}

	function handleTouchMovePan( event ) {

		//console.log( 'handleTouchMovePan' );

		panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		panDelta.subVectors( panEnd, panStart );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

		scope.update();

	}

	function handleTouchEnd( event ) {

		//console.log( 'handleTouchEnd' );

	}

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( event.button ) {

			case scope.mouseButtons.ORBIT:

				if ( scope.enableRotate === false ) return;

				handleMouseDownRotate( event );

				state = STATE.ROTATE;

				break;

			case scope.mouseButtons.ZOOM:

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

				break;

			case scope.mouseButtons.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseDownPan( event );

				state = STATE.PAN;

				break;

		}

		if ( state !== STATE.NONE ) {

			document.addEventListener( 'mousemove', onMouseMove, false );
			document.addEventListener( 'mouseup', onMouseUp, false );

			scope.dispatchEvent( startEvent );

		}

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( state ) {

			case STATE.ROTATE:

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

				break;

			case STATE.DOLLY:

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

				break;

			case STATE.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

				break;

		}

	}

	function onMouseUp( event ) {

		if ( scope.enabled === false ) return;

		handleMouseUp( event );

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onMouseWheel( event ) {

		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

		event.preventDefault();
		event.stopPropagation();

		scope.dispatchEvent( startEvent );

		handleMouseWheel( event );

		scope.dispatchEvent( endEvent );

	}

	function onKeyDown( event ) {

		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

		handleKeyDown( event );

	}

	function onTouchStart( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.touches.length ) {

			case 1:	// one-fingered touch: rotate

				if ( scope.enableRotate === false ) return;

				handleTouchStartRotate( event );

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:	// two-fingered touch: dolly

				if ( scope.enableZoom === false ) return;

				handleTouchStartDolly( event );

				state = STATE.TOUCH_DOLLY;

				break;

			case 3: // three-fingered touch: pan

				if ( scope.enablePan === false ) return;

				handleTouchStartPan( event );

				state = STATE.TOUCH_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.dispatchEvent( startEvent );

		}

	}

	function onTouchMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		switch ( event.touches.length ) {

			case 1: // one-fingered touch: rotate

				if ( scope.enableRotate === false ) return;
				if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

				handleTouchMoveRotate( event );

				break;

			case 2: // two-fingered touch: dolly

				if ( scope.enableZoom === false ) return;
				if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

				handleTouchMoveDolly( event );

				break;

			case 3: // three-fingered touch: pan

				if ( scope.enablePan === false ) return;
				if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

				handleTouchMovePan( event );

				break;

			default:

				state = STATE.NONE;

		}

	}

	function onTouchEnd( event ) {

		if ( scope.enabled === false ) return;

		handleTouchEnd( event );

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onContextMenu( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

	}

	//

	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

	scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

	window.addEventListener( 'keydown', onKeyDown, false );

	// force an update at start

	this.update();

};

THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

Object.defineProperties( THREE.OrbitControls.prototype, {

	center: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
			return this.target;

		}

	},

	// backward compatibility

	noZoom: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
			return ! this.enableZoom;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
			this.enableZoom = ! value;

		}

	},

	noRotate: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
			return ! this.enableRotate;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
			this.enableRotate = ! value;

		}

	},

	noPan: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
			return ! this.enablePan;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
			this.enablePan = ! value;

		}

	},

	noKeys: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
			return ! this.enableKeys;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
			this.enableKeys = ! value;

		}

	},

	staticMoving: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
			return ! this.enableDamping;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
			this.enableDamping = ! value;

		}

	},

	dynamicDampingFactor: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
			return this.dampingFactor;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
			this.dampingFactor = value;

		}

	}

} );


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* shader-particle-engine 1.0.5
 * 
 * (c) 2015 Luke Moody (http://www.github.com/squarefeet)
 *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).
 *
 * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)
 */
/**
 * @typedef {Number} distribution
 * @property {Number} SPE.distributions.BOX Values will be distributed within a box.
 * @property {Number} SPE.distributions.SPHERE Values will be distributed within a sphere.
 * @property {Number} SPE.distributions.DISC Values will be distributed within a 2D disc.
 */

/**
 * Namespace for Shader Particle Engine.
 *
 * All SPE-related code sits under this namespace.
 *
 * @type {Object}
 * @namespace
 */
var SPE = {

    /**
     * A map of supported distribution types used
     * by SPE.Emitter instances.
     *
     * These distribution types can be applied to
     * an emitter globally, which will affect the
     * `position`, `velocity`, and `acceleration`
     * value calculations for an emitter, or they
     * can be applied on a per-property basis.
     *
     * @enum {Number}
     */
    distributions: {
        /**
         * Values will be distributed within a box.
         * @type {Number}
         */
        BOX: 1,

        /**
         * Values will be distributed on a sphere.
         * @type {Number}
         */
        SPHERE: 2,

        /**
         * Values will be distributed on a 2d-disc shape.
         * @type {Number}
         */
        DISC: 3,
    },


    /**
     * Set this value to however many 'steps' you
     * want value-over-lifetime properties to have.
     *
     * It's adjustable to fix an interpolation problem:
     *
     * Assuming you specify an opacity value as [0, 1, 0]
     *      and the `valueOverLifetimeLength` is 4, then the
     *      opacity value array will be reinterpolated to
     *      be [0, 0.66, 0.66, 0].
     *   This isn't ideal, as particles would never reach
     *   full opacity.
     *
     * NOTE:
     *     This property affects the length of ALL
     *       value-over-lifetime properties for ALL
     *       emitters and ALL groups.
     *
     *     Only values >= 3 && <= 4 are allowed.
     *
     * @type {Number}
     */
    valueOverLifetimeLength: 4
};

// Module loader support:
if ( true ) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (SPE),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
else if ( typeof exports !== 'undefined' && typeof module !== 'undefined' ) {
    module.exports = SPE;
}

/**
 * A helper class for TypedArrays.
 *
 * Allows for easy resizing, assignment of various component-based
 * types (Vector2s, Vector3s, Vector4s, Mat3s, Mat4s),
 * as well as Colors (where components are `r`, `g`, `b`),
 * Numbers, and setting from other TypedArrays.
 *
 * @author Luke Moody
 * @constructor
 * @param {Function} TypedArrayConstructor The constructor to use (Float32Array, Uint8Array, etc.)
 * @param {Number} size                 The size of the array to create
 * @param {Number} componentSize        The number of components per-value (ie. 3 for a vec3, 9 for a Mat3, etc.)
 * @param {Number} indexOffset          The index in the array from which to start assigning values. Default `0` if none provided
 */
SPE.TypedArrayHelper = function( TypedArrayConstructor, size, componentSize, indexOffset ) {
    'use strict';

    this.componentSize = componentSize || 1;
    this.size = ( size || 1 );
    this.TypedArrayConstructor = TypedArrayConstructor || Float32Array;
    this.array = new TypedArrayConstructor( size * this.componentSize );
    this.indexOffset = indexOffset || 0;
};

SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;

/**
 * Sets the size of the internal array.
 *
 * Delegates to `this.shrink` or `this.grow` depending on size
 * argument's relation to the current size of the internal array.
 *
 * Note that if the array is to be shrunk, data will be lost.
 *
 * @param {Number} size The new size of the array.
 */
SPE.TypedArrayHelper.prototype.setSize = function( size, noComponentMultiply ) {
    'use strict';

    var currentArraySize = this.array.length;

    if ( !noComponentMultiply ) {
        size = size * this.componentSize;
    }

    if ( size < currentArraySize ) {
        return this.shrink( size );
    }
    else if ( size > currentArraySize ) {
        return this.grow( size );
    }
    else {
        console.info( 'TypedArray is already of size:', size + '.', 'Will not resize.' );
    }
};

/**
 * Shrinks the internal array.
 *
 * @param  {Number} size The new size of the typed array. Must be smaller than `this.array.length`.
 * @return {SPE.TypedArrayHelper}      Instance of this class.
 */
SPE.TypedArrayHelper.prototype.shrink = function( size ) {
    'use strict';

    this.array = this.array.subarray( 0, size );
    this.size = size;
    return this;
};

/**
 * Grows the internal array.
 * @param  {Number} size The new size of the typed array. Must be larger than `this.array.length`.
 * @return {SPE.TypedArrayHelper}      Instance of this class.
 */
SPE.TypedArrayHelper.prototype.grow = function( size ) {
    'use strict';

    var existingArray = this.array,
        newArray = new this.TypedArrayConstructor( size );

    newArray.set( existingArray );
    this.array = newArray;
    this.size = size;

    return this;
};


/**
 * Perform a splice operation on this array's buffer.
 * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.
 * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.
 * @returns {Object} The SPE.TypedArrayHelper instance.
 */
SPE.TypedArrayHelper.prototype.splice = function( start, end ) {
    'use strict';
    start *= this.componentSize;
    end *= this.componentSize;

    var data = [],
        array = this.array,
        size = array.length;

    for ( var i = 0; i < size; ++i ) {
        if ( i < start || i >= end ) {
            data.push( array[ i ] );
        }
        // array[ i ] = 0;
    }

    this.setFromArray( 0, data );

    return this;
};


/**
 * Copies from the given TypedArray into this one, using the index argument
 * as the start position. Alias for `TypedArray.set`. Will automatically resize
 * if the given source array is of a larger size than the internal array.
 *
 * @param {Number} index      The start position from which to copy into this array.
 * @param {TypedArray} array The array from which to copy; the source array.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setFromArray = function( index, array ) {
    'use strict';

    var sourceArraySize = array.length,
        newSize = index + sourceArraySize;

    if ( newSize > this.array.length ) {
        this.grow( newSize );
    }
    else if ( newSize < this.array.length ) {
        this.shrink( newSize );
    }

    this.array.set( array, this.indexOffset + index );

    return this;
};

/**
 * Set a Vector2 value at `index`.
 *
 * @param {Number} index The index at which to set the vec2 values from.
 * @param {Vector2} vec2  Any object that has `x` and `y` properties.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setVec2 = function( index, vec2 ) {
    'use strict';

    return this.setVec2Components( index, vec2.x, vec2.y );
};

/**
 * Set a Vector2 value using raw components.
 *
 * @param {Number} index The index at which to set the vec2 values from.
 * @param {Number} x     The Vec2's `x` component.
 * @param {Number} y     The Vec2's `y` component.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setVec2Components = function( index, x, y ) {
    'use strict';

    var array = this.array,
        i = this.indexOffset + ( index * this.componentSize );

    array[ i ] = x;
    array[ i + 1 ] = y;
    return this;
};

/**
 * Set a Vector3 value at `index`.
 *
 * @param {Number} index The index at which to set the vec3 values from.
 * @param {Vector3} vec2  Any object that has `x`, `y`, and `z` properties.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setVec3 = function( index, vec3 ) {
    'use strict';

    return this.setVec3Components( index, vec3.x, vec3.y, vec3.z );
};

/**
 * Set a Vector3 value using raw components.
 *
 * @param {Number} index The index at which to set the vec3 values from.
 * @param {Number} x     The Vec3's `x` component.
 * @param {Number} y     The Vec3's `y` component.
 * @param {Number} z     The Vec3's `z` component.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setVec3Components = function( index, x, y, z ) {
    'use strict';

    var array = this.array,
        i = this.indexOffset + ( index * this.componentSize );

    array[ i ] = x;
    array[ i + 1 ] = y;
    array[ i + 2 ] = z;
    return this;
};

/**
 * Set a Vector4 value at `index`.
 *
 * @param {Number} index The index at which to set the vec4 values from.
 * @param {Vector4} vec2  Any object that has `x`, `y`, `z`, and `w` properties.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setVec4 = function( index, vec4 ) {
    'use strict';

    return this.setVec4Components( index, vec4.x, vec4.y, vec4.z, vec4.w );
};

/**
 * Set a Vector4 value using raw components.
 *
 * @param {Number} index The index at which to set the vec4 values from.
 * @param {Number} x     The Vec4's `x` component.
 * @param {Number} y     The Vec4's `y` component.
 * @param {Number} z     The Vec4's `z` component.
 * @param {Number} w     The Vec4's `w` component.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setVec4Components = function( index, x, y, z, w ) {
    'use strict';

    var array = this.array,
        i = this.indexOffset + ( index * this.componentSize );

    array[ i ] = x;
    array[ i + 1 ] = y;
    array[ i + 2 ] = z;
    array[ i + 3 ] = w;
    return this;
};

/**
 * Set a Matrix3 value at `index`.
 *
 * @param {Number} index The index at which to set the matrix values from.
 * @param {Matrix3} mat3 The 3x3 matrix to set from. Must have a TypedArray property named `elements` to copy from.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setMat3 = function( index, mat3 ) {
    'use strict';

    return this.setFromArray( this.indexOffset + ( index * this.componentSize ), mat3.elements );
};

/**
 * Set a Matrix4 value at `index`.
 *
 * @param {Number} index The index at which to set the matrix values from.
 * @param {Matrix4} mat3 The 4x4 matrix to set from. Must have a TypedArray property named `elements` to copy from.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setMat4 = function( index, mat4 ) {
    'use strict';

    return this.setFromArray( this.indexOffset + ( index * this.componentSize ), mat4.elements );
};

/**
 * Set a Color value at `index`.
 *
 * @param {Number} index The index at which to set the vec3 values from.
 * @param {Color} color  Any object that has `r`, `g`, and `b` properties.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setColor = function( index, color ) {
    'use strict';

    return this.setVec3Components( index, color.r, color.g, color.b );
};

/**
 * Set a Number value at `index`.
 *
 * @param {Number} index The index at which to set the vec3 values from.
 * @param {Number} numericValue  The number to assign to this index in the array.
 * @return {SPE.TypedArrayHelper} Instance of this class.
 */
SPE.TypedArrayHelper.prototype.setNumber = function( index, numericValue ) {
    'use strict';

    this.array[ this.indexOffset + ( index * this.componentSize ) ] = numericValue;
    return this;
};

/**
 * Returns the value of the array at the given index, taking into account
 * the `indexOffset` property of this class.
 *
 * Note that this function ignores the component size and will just return a
 * single value.
 *
 * @param  {Number} index The index in the array to fetch.
 * @return {Number}       The value at the given index.
 */
SPE.TypedArrayHelper.prototype.getValueAtIndex = function( index ) {
    'use strict';

    return this.array[ this.indexOffset + index ];
};

/**
 * Returns the component value of the array at the given index, taking into account
 * the `indexOffset` property of this class.
 *
 * If the componentSize is set to 3, then it will return a new TypedArray
 * of length 3.
 *
 * @param  {Number} index The index in the array to fetch.
 * @return {TypedArray}       The component value at the given index.
 */
SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function( index ) {
    'use strict';

    return this.array.subarray( this.indexOffset + ( index * this.componentSize ) );
};

/**
 * A helper to handle creating and updating a THREE.BufferAttribute instance.
 *
 * @author  Luke Moody
 * @constructor
 * @param {String} type          The buffer attribute type. See SPE.ShaderAttribute.typeSizeMap for valid values.
 * @param {Boolean=} dynamicBuffer Whether this buffer attribute should be marked as dynamic or not.
 * @param {Function=} arrayType     A reference to a TypedArray constructor. Defaults to Float32Array if none provided.
 */
SPE.ShaderAttribute = function( type, dynamicBuffer, arrayType ) {
    'use strict';

    var typeMap = SPE.ShaderAttribute.typeSizeMap;

    this.type = typeof type === 'string' && typeMap.hasOwnProperty( type ) ? type : 'f';
    this.componentSize = typeMap[ this.type ];
    this.arrayType = arrayType || Float32Array;
    this.typedArray = null;
    this.bufferAttribute = null;
    this.dynamicBuffer = !!dynamicBuffer;

    this.updateMin = 0;
    this.updateMax = 0;
};

SPE.ShaderAttribute.constructor = SPE.ShaderAttribute;

/**
 * A map of uniform types to their component size.
 * @enum {Number}
 */
SPE.ShaderAttribute.typeSizeMap = {
    /**
     * Float
     * @type {Number}
     */
    f: 1,

    /**
     * Vec2
     * @type {Number}
     */
    v2: 2,

    /**
     * Vec3
     * @type {Number}
     */
    v3: 3,

    /**
     * Vec4
     * @type {Number}
     */
    v4: 4,

    /**
     * Color
     * @type {Number}
     */
    c: 3,

    /**
     * Mat3
     * @type {Number}
     */
    m3: 9,

    /**
     * Mat4
     * @type {Number}
     */
    m4: 16
};

/**
 * Calculate the minimum and maximum update range for this buffer attribute using
 * component size independant min and max values.
 *
 * @param {Number} min The start of the range to mark as needing an update.
 * @param {Number} max The end of the range to mark as needing an update.
 */
SPE.ShaderAttribute.prototype.setUpdateRange = function( min, max ) {
    'use strict';

    this.updateMin = Math.min( min * this.componentSize, this.updateMin * this.componentSize );
    this.updateMax = Math.max( max * this.componentSize, this.updateMax * this.componentSize );
};

/**
 * Calculate the number of indices that this attribute should mark as needing
 * updating. Also marks the attribute as needing an update.
 */
SPE.ShaderAttribute.prototype.flagUpdate = function() {
    'use strict';

    var attr = this.bufferAttribute,
        range = attr.updateRange;

    range.offset = this.updateMin;
    range.count = Math.min( ( this.updateMax - this.updateMin ) + this.componentSize, this.typedArray.array.length );
    // console.log( range.offset, range.count, this.typedArray.array.length );
    // console.log( 'flagUpdate:', range.offset, range.count );
    attr.needsUpdate = true;
};



/**
 * Reset the index update counts for this attribute
 */
SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
    'use strict';

    this.updateMin = 0;
    this.updateMax = 0;
};

SPE.ShaderAttribute.prototype.resetDynamic = function() {
    'use strict';
    this.bufferAttribute.dynamic = this.dynamicBuffer;
};

/**
 * Perform a splice operation on this attribute's buffer.
 * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.
 * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.
 */
SPE.ShaderAttribute.prototype.splice = function( start, end ) {
    'use strict';

    this.typedArray.splice( start, end );

    // Reset the reference to the attribute's typed array
    // since it has probably changed.
    this.forceUpdateAll();
};

SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
    'use strict';

    this.bufferAttribute.array = this.typedArray.array;
    this.bufferAttribute.updateRange.offset = 0;
    this.bufferAttribute.updateRange.count = -1;
    this.bufferAttribute.dynamic = false;
    this.bufferAttribute.needsUpdate = true;
};

/**
 * Make sure this attribute has a typed array associated with it.
 *
 * If it does, then it will ensure the typed array is of the correct size.
 *
 * If not, a new SPE.TypedArrayHelper instance will be created.
 *
 * @param  {Number} size The size of the typed array to create or update to.
 */
SPE.ShaderAttribute.prototype._ensureTypedArray = function( size ) {
    'use strict';

    // Condition that's most likely to be true at the top: no change.
    if ( this.typedArray !== null && this.typedArray.size === size * this.componentSize ) {
        return;
    }

    // Resize the array if we need to, telling the TypedArrayHelper to
    // ignore it's component size when evaluating size.
    else if ( this.typedArray !== null && this.typedArray.size !== size ) {
        this.typedArray.setSize( size );
    }

    // This condition should only occur once in an attribute's lifecycle.
    else if ( this.typedArray === null ) {
        this.typedArray = new SPE.TypedArrayHelper( this.arrayType, size, this.componentSize );
    }
};


/**
 * Creates a THREE.BufferAttribute instance if one doesn't exist already.
 *
 * Ensures a typed array is present by calling _ensureTypedArray() first.
 *
 * If a buffer attribute exists already, then it will be marked as needing an update.
 *
 * @param  {Number} size The size of the typed array to create if one doesn't exist, or resize existing array to.
 */
SPE.ShaderAttribute.prototype._createBufferAttribute = function( size ) {
    'use strict';

    // Make sure the typedArray is present and correct.
    this._ensureTypedArray( size );

    // Don't create it if it already exists, but do
    // flag that it needs updating on the next render
    // cycle.
    if ( this.bufferAttribute !== null ) {
        this.bufferAttribute.array = this.typedArray.array;
        this.bufferAttribute.needsUpdate = true;
        return;
    }

    this.bufferAttribute = new THREE.BufferAttribute( this.typedArray.array, this.componentSize );
    this.bufferAttribute.dynamic = this.dynamicBuffer;
};

/**
 * Returns the length of the typed array associated with this attribute.
 * @return {Number} The length of the typed array. Will be 0 if no typed array has been created yet.
 */
SPE.ShaderAttribute.prototype.getLength = function() {
    'use strict';

    if ( this.typedArray === null ) {
        return 0;
    }

    return this.typedArray.array.length;
};

SPE.shaderChunks = {
    // Register color-packing define statements.
    defines: [
        '#define PACKED_COLOR_SIZE 256.0',
        '#define PACKED_COLOR_DIVISOR 255.0'
    ].join( '\n' ),

    // All uniforms used by vertex / fragment shaders
    uniforms: [
        'uniform float deltaTime;',
        'uniform float runTime;',
        'uniform sampler2D texture;',
        'uniform vec4 textureAnimation;',
        'uniform float scale;',
    ].join( '\n' ),

    // All attributes used by the vertex shader.
    //
    // Note that some attributes are squashed into other ones:
    //
    // * Drag is acceleration.w
    attributes: [
        'attribute vec4 acceleration;',
        'attribute vec3 velocity;',
        'attribute vec4 rotation;',
        'attribute vec3 rotationCenter;',
        'attribute vec4 params;',
        'attribute vec4 size;',
        'attribute vec4 angle;',
        'attribute vec4 color;',
        'attribute vec4 opacity;'
    ].join( '\n' ),

    //
    varyings: [
        'varying vec4 vColor;',
        '#ifdef SHOULD_ROTATE_TEXTURE',
        '    varying float vAngle;',
        '#endif',

        '#ifdef SHOULD_CALCULATE_SPRITE',
        '    varying vec4 vSpriteSheet;',
        '#endif'
    ].join( '\n' ),


    // Branch-avoiding comparison fns
    // - http://theorangeduck.com/page/avoiding-shader-conditionals
    branchAvoidanceFunctions: [
        'float when_gt(float x, float y) {',
        '    return max(sign(x - y), 0.0);',
        '}',

        'float when_lt(float x, float y) {',
        '    return min( max(1.0 - sign(x - y), 0.0), 1.0 );',
        '}',

        'float when_eq( float x, float y ) {',
        '    return 1.0 - abs( sign( x - y ) );',
        '}',

        'float when_ge(float x, float y) {',
        '  return 1.0 - when_lt(x, y);',
        '}',

        'float when_le(float x, float y) {',
        '  return 1.0 - when_gt(x, y);',
        '}',

        // Branch-avoiding logical operators
        // (to be used with above comparison fns)
        'float and(float a, float b) {',
        '    return a * b;',
        '}',

        'float or(float a, float b) {',
        '    return min(a + b, 1.0);',
        '}',
    ].join( '\n' ),


    // From:
    // - http://stackoverflow.com/a/12553149
    // - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader
    unpackColor: [
        'vec3 unpackColor( in float hex ) {',
        '   vec3 c = vec3( 0.0 );',

        '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',
        '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',
        '   float b = mod( hex, PACKED_COLOR_SIZE );',

        '   c.r = r / PACKED_COLOR_DIVISOR;',
        '   c.g = g / PACKED_COLOR_DIVISOR;',
        '   c.b = b / PACKED_COLOR_DIVISOR;',

        '   return c;',
        '}',
    ].join( '\n' ),

    unpackRotationAxis: [
        'vec3 unpackRotationAxis( in float hex ) {',
        '   vec3 c = vec3( 0.0 );',

        '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',
        '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',
        '   float b = mod( hex, PACKED_COLOR_SIZE );',

        '   c.r = r / PACKED_COLOR_DIVISOR;',
        '   c.g = g / PACKED_COLOR_DIVISOR;',
        '   c.b = b / PACKED_COLOR_DIVISOR;',

        '   c *= vec3( 2.0 );',
        '   c -= vec3( 1.0 );',

        '   return c;',
        '}',
    ].join( '\n' ),

    floatOverLifetime: [
        'float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {',
        '    highp float value = 0.0;',
        '    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );',
        '    float fIndex = 0.0;',
        '    float shouldApplyValue = 0.0;',

        // This might look a little odd, but it's faster in the testing I've done than using branches.
        // Uses basic maths to avoid branching.
        //
        // Take a look at the branch-avoidance functions defined above,
        // and be sure to check out The Orange Duck site where I got this
        // from (link above).

        // Fix for static emitters (age is always zero).
        '    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );',
        '',
        '    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {',
        '       fIndex = float( i );',
        '       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );',
        '       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );',
        '    }',
        '',
        '    return value;',
        '}',
    ].join( '\n' ),

    colorOverLifetime: [
        'vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {',
        '    vec3 value = vec3( 0.0 );',
        '    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );',
        '    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );',
        '    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );',
        '    return value;',
        '}',
    ].join( '\n' ),

    paramFetchingFunctions: [
        'float getAlive() {',
        '   return params.x;',
        '}',

        'float getAge() {',
        '   return params.y;',
        '}',

        'float getMaxAge() {',
        '   return params.z;',
        '}',

        'float getWiggle() {',
        '   return params.w;',
        '}',
    ].join( '\n' ),

    forceFetchingFunctions: [
        'vec4 getPosition( in float age ) {',
        '   return modelViewMatrix * vec4( position, 1.0 );',
        '}',

        'vec3 getVelocity( in float age ) {',
        '   return velocity * age;',
        '}',

        'vec3 getAcceleration( in float age ) {',
        '   return acceleration.xyz * age;',
        '}',
    ].join( '\n' ),


    rotationFunctions: [
        // Huge thanks to:
        // - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
        '#ifdef SHOULD_ROTATE_PARTICLES',
        '   mat4 getRotationMatrix( in vec3 axis, in float angle) {',
        '       axis = normalize(axis);',
        '       float s = sin(angle);',
        '       float c = cos(angle);',
        '       float oc = 1.0 - c;',
        '',
        '       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',
        '                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',
        '                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',
        '                   0.0,                                0.0,                                0.0,                                1.0);',
        '   }',
        '',
        '   vec3 getRotation( in vec3 pos, in float positionInTime ) {',
        '      if( rotation.y == 0.0 ) {',
        '           return pos;',
        '      }',
        '',
        '      vec3 axis = unpackRotationAxis( rotation.x );',
        '      vec3 center = rotationCenter;',
        '      vec3 translated;',
        '      mat4 rotationMatrix;',

        '      float angle = 0.0;',
        '      angle += when_eq( rotation.z, 0.0 ) * rotation.y;',
        '      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );',
        '      translated = rotationCenter - pos;',
        '      rotationMatrix = getRotationMatrix( axis, angle );',
        '      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );',
        '   }',
        '#endif'
    ].join( '\n' ),


    // Fragment chunks
    rotateTexture: [
        '    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );',
        '',
        '    #ifdef SHOULD_ROTATE_TEXTURE',
        '       float x = gl_PointCoord.x - 0.5;',
        '       float y = 1.0 - gl_PointCoord.y - 0.5;',
        '       float c = cos( -vAngle );',
        '       float s = sin( -vAngle );',

        '       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );',
        '    #endif',
        '',

        // Spritesheets overwrite angle calculations.
        '    #ifdef SHOULD_CALCULATE_SPRITE',
        '        float framesX = vSpriteSheet.x;',
        '        float framesY = vSpriteSheet.y;',
        '        float columnNorm = vSpriteSheet.z;',
        '        float rowNorm = vSpriteSheet.w;',

        '        vUv.x = gl_PointCoord.x * framesX + columnNorm;',
        '        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);',
        '    #endif',

        '',
        '    vec4 rotatedTexture = texture2D( texture, vUv );',
    ].join( '\n' )
};

SPE.shaders = {
    vertex: [
        SPE.shaderChunks.defines,
        SPE.shaderChunks.uniforms,
        SPE.shaderChunks.attributes,
        SPE.shaderChunks.varyings,

        THREE.ShaderChunk.common,
        THREE.ShaderChunk.logdepthbuf_pars_vertex,
        THREE.ShaderChunk.fog_pars_vertex,
        
        SPE.shaderChunks.branchAvoidanceFunctions,
        SPE.shaderChunks.unpackColor,
        SPE.shaderChunks.unpackRotationAxis,
        SPE.shaderChunks.floatOverLifetime,
        SPE.shaderChunks.colorOverLifetime,
        SPE.shaderChunks.paramFetchingFunctions,
        SPE.shaderChunks.forceFetchingFunctions,
        SPE.shaderChunks.rotationFunctions,


        'void main() {',


        //
        // Setup...
        //
        '    highp float age = getAge();',
        '    highp float alive = getAlive();',
        '    highp float maxAge = getMaxAge();',
        '    highp float positionInTime = (age / maxAge);',
        '    highp float isAlive = when_gt( alive, 0.0 );',

        '    #ifdef SHOULD_WIGGLE_PARTICLES',
        '        float wiggleAmount = positionInTime * getWiggle();',
        '        float wiggleSin = isAlive * sin( wiggleAmount );',
        '        float wiggleCos = isAlive * cos( wiggleAmount );',
        '    #endif',

        //
        // Forces
        //

        // Get forces & position
        '    vec3 vel = getVelocity( age );',
        '    vec3 accel = getAcceleration( age );',
        '    vec3 force = vec3( 0.0 );',
        '    vec3 pos = vec3( position );',

        // Calculate the required drag to apply to the forces.
        '    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;',

        // Integrate forces...
        '    force += vel;',
        '    force *= drag;',
        '    force += accel * age;',
        '    pos += force;',


        // Wiggly wiggly wiggle!
        '    #ifdef SHOULD_WIGGLE_PARTICLES',
        '        pos.x += wiggleSin;',
        '        pos.y += wiggleCos;',
        '        pos.z += wiggleSin;',
        '    #endif',


        // Rotate the emitter around it's central point
        '    #ifdef SHOULD_ROTATE_PARTICLES',
        '        pos = getRotation( pos, positionInTime );',
        '    #endif',

        // Convert pos to a world-space value
        '    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );',

        // Determine point size.
        '    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;',

        // Determine perspective
        '    #ifdef HAS_PERSPECTIVE',
        '        float perspective = scale / length( mvPos.xyz );',
        '    #else',
        '        float perspective = 1.0;',
        '    #endif',

        // Apply perpective to pointSize value
        '    float pointSizePerspective = pointSize * perspective;',


        //
        // Appearance
        //

        // Determine color and opacity for this particle
        '    #ifdef COLORIZE',
        '       vec3 c = isAlive * getColorOverLifetime(',
        '           positionInTime,',
        '           unpackColor( color.x ),',
        '           unpackColor( color.y ),',
        '           unpackColor( color.z ),',
        '           unpackColor( color.w )',
        '       );',
        '    #else',
        '       vec3 c = vec3(1.0);',
        '    #endif',

        '    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );',

        // Assign color to vColor varying.
        '    vColor = vec4( c, o );',

        // Determine angle
        '    #ifdef SHOULD_ROTATE_TEXTURE',
        '        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );',
        '    #endif',

        // If this particle is using a sprite-sheet as a texture, we'll have to figure out
        // what frame of the texture the particle is using at it's current position in time.
        '    #ifdef SHOULD_CALCULATE_SPRITE',
        '        float framesX = textureAnimation.x;',
        '        float framesY = textureAnimation.y;',
        '        float loopCount = textureAnimation.w;',
        '        float totalFrames = textureAnimation.z;',
        '        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );',

        '        float column = floor(mod( frameNumber, framesX ));',
        '        float row = floor( (frameNumber - column) / framesX );',

        '        float columnNorm = column / framesX;',
        '        float rowNorm = row / framesY;',

        '        vSpriteSheet.x = 1.0 / framesX;',
        '        vSpriteSheet.y = 1.0 / framesY;',
        '        vSpriteSheet.z = columnNorm;',
        '        vSpriteSheet.w = rowNorm;',
        '    #endif',

        //
        // Write values
        //

        // Set PointSize according to size at current point in time.
        '    gl_PointSize = pointSizePerspective;',
        '    gl_Position = projectionMatrix * mvPos;',

        THREE.ShaderChunk.logdepthbuf_vertex,
        THREE.ShaderChunk.fog_vertex,
        
        '}'
    ].join( '\n' ),

    fragment: [
        SPE.shaderChunks.uniforms,

        THREE.ShaderChunk.common,
        THREE.ShaderChunk.fog_pars_fragment,
        THREE.ShaderChunk.logdepthbuf_pars_fragment,

        SPE.shaderChunks.varyings,

        SPE.shaderChunks.branchAvoidanceFunctions,

        'void main() {',
        '    vec3 outgoingLight = vColor.xyz;',
        '    ',
        '    #ifdef ALPHATEST',
        '       if ( vColor.w < float(ALPHATEST) ) discard;',
        '    #endif',

        SPE.shaderChunks.rotateTexture,

        THREE.ShaderChunk.logdepthbuf_fragment,

        '    outgoingLight = vColor.xyz * rotatedTexture.xyz;',
		'    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );',
        
        THREE.ShaderChunk.fog_fragment,

        '}'
    ].join( '\n' )
};

/**
 * A bunch of utility functions used throughout the library.
 * @namespace
 * @type {Object}
 */
SPE.utils = {
    /**
     * A map of types used by `SPE.utils.ensureTypedArg` and
     * `SPE.utils.ensureArrayTypedArg` to compare types against.
     *
     * @enum {String}
     */
    types: {
        /**
         * Boolean type.
         * @type {String}
         */
        BOOLEAN: 'boolean',

        /**
         * String type.
         * @type {String}
         */
        STRING: 'string',

        /**
         * Number type.
         * @type {String}
         */
        NUMBER: 'number',

        /**
         * Object type.
         * @type {String}
         */
        OBJECT: 'object'
    },

    /**
     * Given a value, a type, and a default value to fallback to,
     * ensure the given argument adheres to the type requesting,
     * returning the default value if type check is false.
     *
     * @param  {(boolean|string|number|object)} arg          The value to perform a type-check on.
     * @param  {String} type         The type the `arg` argument should adhere to.
     * @param  {(boolean|string|number|object)} defaultValue A default value to fallback on if the type check fails.
     * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.
     */
    ensureTypedArg: function( arg, type, defaultValue ) {
        'use strict';

        if ( typeof arg === type ) {
            return arg;
        }
        else {
            return defaultValue;
        }
    },

    /**
     * Given an array of values, a type, and a default value,
     * ensure the given array's contents ALL adhere to the provided type,
     * returning the default value if type check fails.
     *
     * If the given value to check isn't an Array, delegates to SPE.utils.ensureTypedArg.
     *
     * @param  {Array|boolean|string|number|object} arg          The array of values to check type of.
     * @param  {String} type         The type that should be adhered to.
     * @param  {(boolean|string|number|object)} defaultValue A default fallback value.
     * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.
     */
    ensureArrayTypedArg: function( arg, type, defaultValue ) {
        'use strict';

        // If the argument being checked is an array, loop through
        // it and ensure all the values are of the correct type,
        // falling back to the defaultValue if any aren't.
        if ( Array.isArray( arg ) ) {
            for ( var i = arg.length - 1; i >= 0; --i ) {
                if ( typeof arg[ i ] !== type ) {
                    return defaultValue;
                }
            }

            return arg;
        }

        // If the arg isn't an array then just fallback to
        // checking the type.
        return this.ensureTypedArg( arg, type, defaultValue );
    },

    /**
     * Ensures the given value is an instance of a constructor function.
     *
     * @param  {Object} arg          The value to check instance of.
     * @param  {Function} instance     The constructor of the instance to check against.
     * @param  {Object} defaultValue A default fallback value if instance check fails
     * @return {Object}              The given value if type check passes, or the default value if it fails.
     */
    ensureInstanceOf: function( arg, instance, defaultValue ) {
        'use strict';

        if ( instance !== undefined && arg instanceof instance ) {
            return arg;
        }
        else {
            return defaultValue;
        }
    },

    /**
     * Given an array of values, ensure the instances of all items in the array
     * matches the given instance constructor falling back to a default value if
     * the check fails.
     *
     * If given value isn't an Array, delegates to `SPE.utils.ensureInstanceOf`.
     *
     * @param  {Array|Object} arg          The value to perform the instanceof check on.
     * @param  {Function} instance     The constructor of the instance to check against.
     * @param  {Object} defaultValue A default fallback value if instance check fails
     * @return {Object}              The given value if type check passes, or the default value if it fails.
     */
    ensureArrayInstanceOf: function( arg, instance, defaultValue ) {
        'use strict';

        // If the argument being checked is an array, loop through
        // it and ensure all the values are of the correct type,
        // falling back to the defaultValue if any aren't.
        if ( Array.isArray( arg ) ) {
            for ( var i = arg.length - 1; i >= 0; --i ) {
                if ( instance !== undefined && arg[ i ] instanceof instance === false ) {
                    return defaultValue;
                }
            }

            return arg;
        }

        // If the arg isn't an array then just fallback to
        // checking the type.
        return this.ensureInstanceOf( arg, instance, defaultValue );
    },

    /**
     * Ensures that any "value-over-lifetime" properties of an emitter are
     * of the correct length (as dictated by `SPE.valueOverLifetimeLength`).
     *
     * Delegates to `SPE.utils.interpolateArray` for array resizing.
     *
     * If properties aren't arrays, then property values are put into one.
     *
     * @param  {Object} property  The property of an SPE.Emitter instance to check compliance of.
     * @param  {Number} minLength The minimum length of the array to create.
     * @param  {Number} maxLength The maximum length of the array to create.
     */
    ensureValueOverLifetimeCompliance: function( property, minLength, maxLength ) {
        'use strict';

        minLength = minLength || 3;
        maxLength = maxLength || 3;

        // First, ensure both properties are arrays.
        if ( Array.isArray( property._value ) === false ) {
            property._value = [ property._value ];
        }

        if ( Array.isArray( property._spread ) === false ) {
            property._spread = [ property._spread ];
        }

        var valueLength = this.clamp( property._value.length, minLength, maxLength ),
            spreadLength = this.clamp( property._spread.length, minLength, maxLength ),
            desiredLength = Math.max( valueLength, spreadLength );

        if ( property._value.length !== desiredLength ) {
            property._value = this.interpolateArray( property._value, desiredLength );
        }

        if ( property._spread.length !== desiredLength ) {
            property._spread = this.interpolateArray( property._spread, desiredLength );
        }
    },

    /**
     * Performs linear interpolation (lerp) on an array.
     *
     * For example, lerping [1, 10], with a `newLength` of 10 will produce [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].
     *
     * Delegates to `SPE.utils.lerpTypeAgnostic` to perform the actual
     * interpolation.
     *
     * @param  {Array} srcArray  The array to lerp.
     * @param  {Number} newLength The length the array should be interpolated to.
     * @return {Array}           The interpolated array.
     */
    interpolateArray: function( srcArray, newLength ) {
        'use strict';

        var sourceLength = srcArray.length,
            newArray = [ typeof srcArray[ 0 ].clone === 'function' ? srcArray[ 0 ].clone() : srcArray[ 0 ] ],
            factor = ( sourceLength - 1 ) / ( newLength - 1 );


        for ( var i = 1; i < newLength - 1; ++i ) {
            var f = i * factor,
                before = Math.floor( f ),
                after = Math.ceil( f ),
                delta = f - before;

            newArray[ i ] = this.lerpTypeAgnostic( srcArray[ before ], srcArray[ after ], delta );
        }

        newArray.push(
            typeof srcArray[ sourceLength - 1 ].clone === 'function' ?
            srcArray[ sourceLength - 1 ].clone() :
            srcArray[ sourceLength - 1 ]
        );

        return newArray;
    },

    /**
     * Clamp a number to between the given min and max values.
     * @param  {Number} value The number to clamp.
     * @param  {Number} min   The minimum value.
     * @param  {Number} max   The maximum value.
     * @return {Number}       The clamped number.
     */
    clamp: function( value, min, max ) {
        'use strict';

        return Math.max( min, Math.min( value, max ) );
    },

    /**
     * If the given value is less than the epsilon value, then return
     * a randomised epsilon value if specified, or just the epsilon value if not.
     * Works for negative numbers as well as positive.
     *
     * @param  {Number} value     The value to perform the operation on.
     * @param  {Boolean} randomise Whether the value should be randomised.
     * @return {Number}           The result of the operation.
     */
    zeroToEpsilon: function( value, randomise ) {
        'use strict';

        var epsilon = 0.00001,
            result = value;

        result = randomise ? Math.random() * epsilon * 10 : epsilon;

        if ( value < 0 && value > -epsilon ) {
            result = -result;
        }

        // if ( value === 0 ) {
        //     result = randomise ? Math.random() * epsilon * 10 : epsilon;
        // }
        // else if ( value > 0 && value < epsilon ) {
        //     result = randomise ? Math.random() * epsilon * 10 : epsilon;
        // }
        // else if ( value < 0 && value > -epsilon ) {
        //     result = -( randomise ? Math.random() * epsilon * 10 : epsilon );
        // }

        return result;
    },

    /**
     * Linearly interpolates two values of various types. The given values
     * must be of the same type for the interpolation to work.
     * @param  {(number|Object)} start The start value of the lerp.
     * @param  {(number|object)} end   The end value of the lerp.
     * @param  {Number} delta The delta posiiton of the lerp operation. Ideally between 0 and 1 (inclusive).
     * @return {(number|object|undefined)}       The result of the operation. Result will be undefined if
     *                                               the start and end arguments aren't a supported type, or
     *                                               if their types do not match.
     */
    lerpTypeAgnostic: function( start, end, delta ) {
        'use strict';

        var types = this.types,
            out;

        if ( typeof start === types.NUMBER && typeof end === types.NUMBER ) {
            return start + ( ( end - start ) * delta );
        }
        else if ( start instanceof THREE.Vector2 && end instanceof THREE.Vector2 ) {
            out = start.clone();
            out.x = this.lerp( start.x, end.x, delta );
            out.y = this.lerp( start.y, end.y, delta );
            return out;
        }
        else if ( start instanceof THREE.Vector3 && end instanceof THREE.Vector3 ) {
            out = start.clone();
            out.x = this.lerp( start.x, end.x, delta );
            out.y = this.lerp( start.y, end.y, delta );
            out.z = this.lerp( start.z, end.z, delta );
            return out;
        }
        else if ( start instanceof THREE.Vector4 && end instanceof THREE.Vector4 ) {
            out = start.clone();
            out.x = this.lerp( start.x, end.x, delta );
            out.y = this.lerp( start.y, end.y, delta );
            out.z = this.lerp( start.z, end.z, delta );
            out.w = this.lerp( start.w, end.w, delta );
            return out;
        }
        else if ( start instanceof THREE.Color && end instanceof THREE.Color ) {
            out = start.clone();
            out.r = this.lerp( start.r, end.r, delta );
            out.g = this.lerp( start.g, end.g, delta );
            out.b = this.lerp( start.b, end.b, delta );
            return out;
        }
        else {
            console.warn( 'Invalid argument types, or argument types do not match:', start, end );
        }
    },

    /**
     * Perform a linear interpolation operation on two numbers.
     * @param  {Number} start The start value.
     * @param  {Number} end   The end value.
     * @param  {Number} delta The position to interpolate to.
     * @return {Number}       The result of the lerp operation.
     */
    lerp: function( start, end, delta ) {
        'use strict';
        return start + ( ( end - start ) * delta );
    },

    /**
     * Rounds a number to a nearest multiple.
     *
     * @param  {Number} n        The number to round.
     * @param  {Number} multiple The multiple to round to.
     * @return {Number}          The result of the round operation.
     */
    roundToNearestMultiple: function( n, multiple ) {
        'use strict';

        var remainder = 0;

        if ( multiple === 0 ) {
            return n;
        }

        remainder = Math.abs( n ) % multiple;

        if ( remainder === 0 ) {
            return n;
        }

        if ( n < 0 ) {
            return -( Math.abs( n ) - remainder );
        }

        return n + multiple - remainder;
    },

    /**
     * Check if all items in an array are equal. Uses strict equality.
     *
     * @param  {Array} array The array of values to check equality of.
     * @return {Boolean}       Whether the array's values are all equal or not.
     */
    arrayValuesAreEqual: function( array ) {
        'use strict';

        for ( var i = 0; i < array.length - 1; ++i ) {
            if ( array[ i ] !== array[ i + 1 ] ) {
                return false;
            }
        }

        return true;
    },

    // colorsAreEqual: function() {
    //     var colors = Array.prototype.slice.call( arguments ),
    //         numColors = colors.length;

    //     for ( var i = 0, color1, color2; i < numColors - 1; ++i ) {
    //         color1 = colors[ i ];
    //         color2 = colors[ i + 1 ];

    //         if (
    //             color1.r !== color2.r ||
    //             color1.g !== color2.g ||
    //             color1.b !== color2.b
    //         ) {
    //             return false
    //         }
    //     }

    //     return true;
    // },


    /**
     * Given a start value and a spread value, create and return a random
     * number.
     * @param  {Number} base   The start value.
     * @param  {Number} spread The size of the random variance to apply.
     * @return {Number}        A randomised number.
     */
    randomFloat: function( base, spread ) {
        'use strict';
        return base + spread * ( Math.random() - 0.5 );
    },



    /**
     * Given an SPE.ShaderAttribute instance, and various other settings,
     * assign values to the attribute's array in a `vec3` format.
     *
     * @param  {Object} attribute   The instance of SPE.ShaderAttribute to save the result to.
     * @param  {Number} index       The offset in the attribute's TypedArray to save the result from.
     * @param  {Object} base        THREE.Vector3 instance describing the start value.
     * @param  {Object} spread      THREE.Vector3 instance describing the random variance to apply to the start value.
     * @param  {Object} spreadClamp THREE.Vector3 instance describing the multiples to clamp the randomness to.
     */
    randomVector3: function( attribute, index, base, spread, spreadClamp ) {
        'use strict';

        var x = base.x + ( Math.random() * spread.x - ( spread.x * 0.5 ) ),
            y = base.y + ( Math.random() * spread.y - ( spread.y * 0.5 ) ),
            z = base.z + ( Math.random() * spread.z - ( spread.z * 0.5 ) );

        // var x = this.randomFloat( base.x, spread.x ),
        // y = this.randomFloat( base.y, spread.y ),
        // z = this.randomFloat( base.z, spread.z );

        if ( spreadClamp ) {
            x = -spreadClamp.x * 0.5 + this.roundToNearestMultiple( x, spreadClamp.x );
            y = -spreadClamp.y * 0.5 + this.roundToNearestMultiple( y, spreadClamp.y );
            z = -spreadClamp.z * 0.5 + this.roundToNearestMultiple( z, spreadClamp.z );
        }

        attribute.typedArray.setVec3Components( index, x, y, z );
    },

    /**
     * Given an SPE.Shader attribute instance, and various other settings,
     * assign Color values to the attribute.
     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
     * @param  {Object} base      THREE.Color instance describing the start color.
     * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.
     */
    randomColor: function( attribute, index, base, spread ) {
        'use strict';

        var r = base.r + ( Math.random() * spread.x ),
            g = base.g + ( Math.random() * spread.y ),
            b = base.b + ( Math.random() * spread.z );

        r = this.clamp( r, 0, 1 );
        g = this.clamp( g, 0, 1 );
        b = this.clamp( b, 0, 1 );


        attribute.typedArray.setVec3Components( index, r, g, b );
    },


    randomColorAsHex: ( function() {
        'use strict';

        var workingColor = new THREE.Color();

        /**
         * Assigns a random color value, encoded as a hex value in decimal
         * format, to a SPE.ShaderAttribute instance.
         * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
         * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
         * @param  {Object} base      THREE.Color instance describing the start color.
         * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.
         */
        return function( attribute, index, base, spread ) {
            var numItems = base.length,
                colors = [];

            for ( var i = 0; i < numItems; ++i ) {
                var spreadVector = spread[ i ];

                workingColor.copy( base[ i ] );

                workingColor.r += ( Math.random() * spreadVector.x ) - ( spreadVector.x * 0.5 );
                workingColor.g += ( Math.random() * spreadVector.y ) - ( spreadVector.y * 0.5 );
                workingColor.b += ( Math.random() * spreadVector.z ) - ( spreadVector.z * 0.5 );

                workingColor.r = this.clamp( workingColor.r, 0, 1 );
                workingColor.g = this.clamp( workingColor.g, 0, 1 );
                workingColor.b = this.clamp( workingColor.b, 0, 1 );

                colors.push( workingColor.getHex() );
            }

            attribute.typedArray.setVec4Components( index, colors[ 0 ], colors[ 1 ], colors[ 2 ], colors[ 3 ] );
        };
    }() ),

    /**
     * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the
     * given values onto a sphere.
     *
     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
     * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.
     * @param  {Number} radius            The radius of the sphere to project onto.
     * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result
     * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the sphere.
     * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.
     */
    randomVector3OnSphere: function(
        attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp
    ) {
        'use strict';

        var depth = 2 * Math.random() - 1,
            t = 6.2832 * Math.random(),
            r = Math.sqrt( 1 - depth * depth ),
            rand = this.randomFloat( radius, radiusSpread ),
            x = 0,
            y = 0,
            z = 0;


        if ( radiusSpreadClamp ) {
            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;
        }



        // Set position on sphere
        x = r * Math.cos( t ) * rand;
        y = r * Math.sin( t ) * rand;
        z = depth * rand;

        // Apply radius scale to this position
        x *= radiusScale.x;
        y *= radiusScale.y;
        z *= radiusScale.z;

        // Translate to the base position.
        x += base.x;
        y += base.y;
        z += base.z;

        // Set the values in the typed array.
        attribute.typedArray.setVec3Components( index, x, y, z );
    },

    seededRandom: function( seed ) {
        var x = Math.sin( seed ) * 10000;
        return x - ( x | 0 );
    },



    /**
     * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the
     * given values onto a 2d-disc.
     *
     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
     * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.
     * @param  {Number} radius            The radius of the sphere to project onto.
     * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result
     * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the disc. The z-component is ignored.
     * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.
     */
    randomVector3OnDisc: function( attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {
        'use strict';

        var t = 6.2832 * Math.random(),
            rand = Math.abs( this.randomFloat( radius, radiusSpread ) ),
            x = 0,
            y = 0,
            z = 0;

        if ( radiusSpreadClamp ) {
            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;
        }

        // Set position on sphere
        x = Math.cos( t ) * rand;
        y = Math.sin( t ) * rand;

        // Apply radius scale to this position
        x *= radiusScale.x;
        y *= radiusScale.y;

        // Translate to the base position.
        x += base.x;
        y += base.y;
        z += base.z;

        // Set the values in the typed array.
        attribute.typedArray.setVec3Components( index, x, y, z );
    },

    randomDirectionVector3OnSphere: ( function() {
        'use strict';

        var v = new THREE.Vector3();

        /**
         * Given an SPE.ShaderAttribute instance, create a direction vector from the given
         * position, using `speed` as the magnitude. Values are saved to the attribute.
         *
         * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.
         * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.
         * @param  {Number} posX            The particle's x coordinate.
         * @param  {Number} posY            The particle's y coordinate.
         * @param  {Number} posZ            The particle's z coordinate.
         * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.
         * @param  {Number} speed           The magnitude to apply to the vector.
         * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.
         */
        return function( attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread ) {
            v.copy( emitterPosition );

            v.x -= posX;
            v.y -= posY;
            v.z -= posZ;

            v.normalize().multiplyScalar( -this.randomFloat( speed, speedSpread ) );

            attribute.typedArray.setVec3Components( index, v.x, v.y, v.z );
        };
    }() ),


    randomDirectionVector3OnDisc: ( function() {
        'use strict';

        var v = new THREE.Vector3();

        /**
         * Given an SPE.ShaderAttribute instance, create a direction vector from the given
         * position, using `speed` as the magnitude. Values are saved to the attribute.
         *
         * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.
         * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.
         * @param  {Number} posX            The particle's x coordinate.
         * @param  {Number} posY            The particle's y coordinate.
         * @param  {Number} posZ            The particle's z coordinate.
         * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.
         * @param  {Number} speed           The magnitude to apply to the vector.
         * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.
         */
        return function( attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread ) {
            v.copy( emitterPosition );

            v.x -= posX;
            v.y -= posY;
            v.z -= posZ;

            v.normalize().multiplyScalar( -this.randomFloat( speed, speedSpread ) );

            attribute.typedArray.setVec3Components( index, v.x, v.y, 0 );
        };
    }() ),

    getPackedRotationAxis: ( function() {
        'use strict';

        var v = new THREE.Vector3(),
            vSpread = new THREE.Vector3(),
            c = new THREE.Color(),
            addOne = new THREE.Vector3( 1, 1, 1 );

        /**
         * Given a rotation axis, and a rotation axis spread vector,
         * calculate a randomised rotation axis, and pack it into
         * a hexadecimal value represented in decimal form.
         * @param  {Object} axis       THREE.Vector3 instance describing the rotation axis.
         * @param  {Object} axisSpread THREE.Vector3 instance describing the amount of randomness to apply to the rotation axis.
         * @return {Number}            The packed rotation axis, with randomness.
         */
        return function( axis, axisSpread ) {
            v.copy( axis ).normalize();
            vSpread.copy( axisSpread ).normalize();

            v.x += ( -axisSpread.x * 0.5 ) + ( Math.random() * axisSpread.x );
            v.y += ( -axisSpread.y * 0.5 ) + ( Math.random() * axisSpread.y );
            v.z += ( -axisSpread.z * 0.5 ) + ( Math.random() * axisSpread.z );

            // v.x = Math.abs( v.x );
            // v.y = Math.abs( v.y );
            // v.z = Math.abs( v.z );

            v.normalize().add( addOne ).multiplyScalar( 0.5 );

            c.setRGB( v.x, v.y, v.z );

            return c.getHex();
        };
    }() )
};

/**
 * An SPE.Group instance.
 * @typedef {Object} Group
 * @see SPE.Group
 */

/**
 * A map of options to configure an SPE.Group instance.
 * @typedef {Object} GroupOptions
 *
 * @property {Object} texture An object describing the texture used by the group.
 *
 * @property {Object} texture.value An instance of THREE.Texture.
 *
 * @property {Object=} texture.frames A THREE.Vector2 instance describing the number
 *                                    of frames on the x- and y-axis of the given texture.
 *                                    If not provided, the texture will NOT be treated as
 *                                    a sprite-sheet and as such will NOT be animated.
 *
 * @property {Number} [texture.frameCount=texture.frames.x * texture.frames.y] The total number of frames in the sprite-sheet.
 *                                                                   Allows for sprite-sheets that don't fill the entire
 *                                                                   texture.
 *
 * @property {Number} texture.loop The number of loops through the sprite-sheet that should
 *                                 be performed over the course of a single particle's lifetime.
 *
 * @property {Number} fixedTimeStep If no `dt` (or `deltaTime`) value is passed to this group's
 *                                  `tick()` function, this number will be used to move the particle
 *                                  simulation forward. Value in SECONDS.
 *
 * @property {Boolean} hasPerspective Whether the distance a particle is from the camera should affect
 *                                    the particle's size.
 *
 * @property {Boolean} colorize Whether the particles in this group should be rendered with color, or
 *                              whether the only color of particles will come from the provided texture.
 *
 * @property {Number} blending One of Three.js's blending modes to apply to this group's `ShaderMaterial`.
 *
 * @property {Boolean} transparent Whether these particle's should be rendered with transparency.
 *
 * @property {Number} alphaTest Sets the alpha value to be used when running an alpha test on the `texture.value` property. Value between 0 and 1.
 *
 * @property {Boolean} depthWrite Whether rendering the group has any effect on the depth buffer.
 *
 * @property {Boolean} depthTest Whether to have depth test enabled when rendering this group.
 *
 * @property {Boolean} fog Whether this group's particles should be affected by their scene's fog.
 *
 * @property {Number} scale The scale factor to apply to this group's particle sizes. Useful for
 *                          setting particle sizes to be relative to renderer size.
 */


/**
 * The SPE.Group class. Creates a new group, containing a material, geometry, and mesh.
 *
 * @constructor
 * @param {GroupOptions} options A map of options to configure the group instance.
 */
SPE.Group = function( options ) {
    'use strict';

    var utils = SPE.utils,
        types = utils.types;

    // Ensure we have a map of options to play with
    options = utils.ensureTypedArg( options, types.OBJECT, {} );
    options.texture = utils.ensureTypedArg( options.texture, types.OBJECT, {} );

    // Assign a UUID to this instance
    this.uuid = THREE.Math.generateUUID();

    // If no `deltaTime` value is passed to the `SPE.Group.tick` function,
    // the value of this property will be used to advance the simulation.
    this.fixedTimeStep = utils.ensureTypedArg( options.fixedTimeStep, types.NUMBER, 0.016 );

    // Set properties used in the uniforms map, starting with the
    // texture stuff.
    this.texture = utils.ensureInstanceOf( options.texture.value, THREE.Texture, null );
    this.textureFrames = utils.ensureInstanceOf( options.texture.frames, THREE.Vector2, new THREE.Vector2( 1, 1 ) );
    this.textureFrameCount = utils.ensureTypedArg( options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y );
    this.textureLoop = utils.ensureTypedArg( options.texture.loop, types.NUMBER, 1 );
    this.textureFrames.max( new THREE.Vector2( 1, 1 ) );

    this.hasPerspective = utils.ensureTypedArg( options.hasPerspective, types.BOOLEAN, true );
    this.colorize = utils.ensureTypedArg( options.colorize, types.BOOLEAN, true );

    this.maxParticleCount = utils.ensureTypedArg( options.maxParticleCount, types.NUMBER, null );


    // Set properties used to define the ShaderMaterial's appearance.
    this.blending = utils.ensureTypedArg( options.blending, types.NUMBER, THREE.AdditiveBlending );
    this.transparent = utils.ensureTypedArg( options.transparent, types.BOOLEAN, true );
    this.alphaTest = parseFloat( utils.ensureTypedArg( options.alphaTest, types.NUMBER, 0.0 ) );
    this.depthWrite = utils.ensureTypedArg( options.depthWrite, types.BOOLEAN, false );
    this.depthTest = utils.ensureTypedArg( options.depthTest, types.BOOLEAN, true );
    this.fog = utils.ensureTypedArg( options.fog, types.BOOLEAN, true );
    this.scale = utils.ensureTypedArg( options.scale, types.NUMBER, 300 );

    // Where emitter's go to curl up in a warm blanket and live
    // out their days.
    this.emitters = [];
    this.emitterIDs = [];

    // Create properties for use by the emitter pooling functions.
    this._pool = [];
    this._poolCreationSettings = null;
    this._createNewWhenPoolEmpty = 0;

    // Whether all attributes should be forced to updated
    // their entire buffer contents on the next tick.
    //
    // Used when an emitter is removed.
    this._attributesNeedRefresh = false;
    this._attributesNeedDynamicReset = false;

    this.particleCount = 0;


    // Map of uniforms to be applied to the ShaderMaterial instance.
    this.uniforms = {
        texture: {
            type: 't',
            value: this.texture
        },
        textureAnimation: {
            type: 'v4',
            value: new THREE.Vector4(
                this.textureFrames.x,
                this.textureFrames.y,
                this.textureFrameCount,
                Math.max( Math.abs( this.textureLoop ), 1.0 )
            )
        },
        fogColor: {
            type: 'c',
            value: null
        },
        fogNear: {
            type: 'f',
            value: 10
        },
        fogFar: {
            type: 'f',
            value: 200
        },
        fogDensity: {
            type: 'f',
            value: 0.5
        },
        deltaTime: {
            type: 'f',
            value: 0
        },
        runTime: {
            type: 'f',
            value: 0
        },
        scale: {
            type: 'f',
            value: this.scale
        }
    };

    // Add some defines into the mix...
    this.defines = {
        HAS_PERSPECTIVE: this.hasPerspective,
        COLORIZE: this.colorize,
        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,

        SHOULD_ROTATE_TEXTURE: false,
        SHOULD_ROTATE_PARTICLES: false,
        SHOULD_WIGGLE_PARTICLES: false,

        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
    };

    // Map of all attributes to be applied to the particles.
    //
    // See SPE.ShaderAttribute for a bit more info on this bit.
    this.attributes = {
        position: new SPE.ShaderAttribute( 'v3', true ),
        acceleration: new SPE.ShaderAttribute( 'v4', true ), // w component is drag
        velocity: new SPE.ShaderAttribute( 'v3', true ),
        rotation: new SPE.ShaderAttribute( 'v4', true ),
        rotationCenter: new SPE.ShaderAttribute( 'v3', true ),
        params: new SPE.ShaderAttribute( 'v4', true ), // Holds (alive, age, delay, wiggle)
        size: new SPE.ShaderAttribute( 'v4', true ),
        angle: new SPE.ShaderAttribute( 'v4', true ),
        color: new SPE.ShaderAttribute( 'v4', true ),
        opacity: new SPE.ShaderAttribute( 'v4', true )
    };

    this.attributeKeys = Object.keys( this.attributes );
    this.attributeCount = this.attributeKeys.length;

    // Create the ShaderMaterial instance that'll help render the
    // particles.
    this.material = new THREE.ShaderMaterial( {
        uniforms: this.uniforms,
        vertexShader: SPE.shaders.vertex,
        fragmentShader: SPE.shaders.fragment,
        blending: this.blending,
        transparent: this.transparent,
        alphaTest: this.alphaTest,
        depthWrite: this.depthWrite,
        depthTest: this.depthTest,
        defines: this.defines,
        fog: this.fog
    } );

    // Create the BufferGeometry and Points instances, ensuring
    // the geometry and material are given to the latter.
    this.geometry = new THREE.BufferGeometry();
    this.mesh = new THREE.Points( this.geometry, this.material );

    if ( this.maxParticleCount === null ) {
        console.warn( 'SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.' );
    }
};

SPE.Group.constructor = SPE.Group;


SPE.Group.prototype._updateDefines = function() {
    'use strict';

    var emitters = this.emitters,
        i = emitters.length - 1,
        emitter,
        defines = this.defines;

    for ( i; i >= 0; --i ) {
        emitter = emitters[ i ];

        // Only do angle calculation if there's no spritesheet defined.
        //
        // Saves calculations being done and then overwritten in the shaders.
        if ( !defines.SHOULD_CALCULATE_SPRITE ) {
            defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(
                Math.max.apply( null, emitter.angle.value ),
                Math.max.apply( null, emitter.angle.spread )
            );
        }

        defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(
            emitter.rotation.angle,
            emitter.rotation.angleSpread
        );

        defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(
            emitter.wiggle.value,
            emitter.wiggle.spread
        );
    }

    this.material.needsUpdate = true;
};

SPE.Group.prototype._applyAttributesToGeometry = function() {
    'use strict';

    var attributes = this.attributes,
        geometry = this.geometry,
        geometryAttributes = geometry.attributes,
        attribute,
        geometryAttribute;

    // Loop through all the shader attributes and assign (or re-assign)
    // typed array buffers to each one.
    for ( var attr in attributes ) {
        if ( attributes.hasOwnProperty( attr ) ) {
            attribute = attributes[ attr ];
            geometryAttribute = geometryAttributes[ attr ];

            // Update the array if this attribute exists on the geometry.
            //
            // This needs to be done because the attribute's typed array might have
            // been resized and reinstantiated, and might now be looking at a
            // different ArrayBuffer, so reference needs updating.
            if ( geometryAttribute ) {
                geometryAttribute.array = attribute.typedArray.array;
            }

            // // Add the attribute to the geometry if it doesn't already exist.
            else {
                geometry.addAttribute( attr, attribute.bufferAttribute );
            }

            // Mark the attribute as needing an update the next time a frame is rendered.
            attribute.bufferAttribute.needsUpdate = true;
        }
    }

    // Mark the draw range on the geometry. This will ensure
    // only the values in the attribute buffers that are
    // associated with a particle will be used in THREE's
    // render cycle.
    this.geometry.setDrawRange( 0, this.particleCount );
};

/**
 * Adds an SPE.Emitter instance to this group, creating particle values and
 * assigning them to this group's shader attributes.
 *
 * @param {Emitter} emitter The emitter to add to this group.
 */
SPE.Group.prototype.addEmitter = function( emitter ) {
    'use strict';

    // Ensure an actual emitter instance is passed here.
    //
    // Decided not to throw here, just in case a scene's
    // rendering would be paused. Logging an error instead
    // of stopping execution if exceptions aren't caught.
    if ( emitter instanceof SPE.Emitter === false ) {
        console.error( '`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter );
        return;
    }

    // If the emitter already exists as a member of this group, then
    // stop here, we don't want to add it again.
    else if ( this.emitterIDs.indexOf( emitter.uuid ) > -1 ) {
        console.error( 'Emitter already exists in this group. Will not add again.' );
        return;
    }

    // And finally, if the emitter is a member of another group,
    // don't add it to this group.
    else if ( emitter.group !== null ) {
        console.error( 'Emitter already belongs to another group. Will not add to requested group.' );
        return;
    }

    var attributes = this.attributes,
        start = this.particleCount,
        end = start + emitter.particleCount;

    // Update this group's particle count.
    this.particleCount = end;

    // Emit a warning if the emitter being added will exceed the buffer sizes specified.
    if ( this.maxParticleCount !== null && this.particleCount > this.maxParticleCount ) {
        console.warn( 'SPE.Group: maxParticleCount exceeded. Requesting', this.particleCount, 'particles, can support only', this.maxParticleCount );
    }


    // Set the `particlesPerSecond` value (PPS) on the emitter.
    // It's used to determine how many particles to release
    // on a per-frame basis.
    emitter._calculatePPSValue( emitter.maxAge._value + emitter.maxAge._spread );
    emitter._setBufferUpdateRanges( this.attributeKeys );

    // Store the offset value in the TypedArray attributes for this emitter.
    emitter._setAttributeOffset( start );

    // Save a reference to this group on the emitter so it knows
    // where it belongs.
    emitter.group = this;

    // Store reference to the attributes on the emitter for
    // easier access during the emitter's tick function.
    emitter.attributes = this.attributes;



    // Ensure the attributes and their BufferAttributes exist, and their
    // TypedArrays are of the correct size.
    for ( var attr in attributes ) {
        if ( attributes.hasOwnProperty( attr ) ) {
            // When creating a buffer, pass through the maxParticle count
            // if one is specified.
            attributes[ attr ]._createBufferAttribute(
                this.maxParticleCount !== null ?
                this.maxParticleCount :
                this.particleCount
            );
        }
    }

    // Loop through each particle this emitter wants to have, and create the attributes values,
    // storing them in the TypedArrays that each attribute holds.
    for ( var i = start; i < end; ++i ) {
        emitter._assignPositionValue( i );
        emitter._assignForceValue( i, 'velocity' );
        emitter._assignForceValue( i, 'acceleration' );
        emitter._assignAbsLifetimeValue( i, 'opacity' );
        emitter._assignAbsLifetimeValue( i, 'size' );
        emitter._assignAngleValue( i );
        emitter._assignRotationValue( i );
        emitter._assignParamsValue( i );
        emitter._assignColorValue( i );
    }

    // Update the geometry and make sure the attributes are referencing
    // the typed arrays properly.
    this._applyAttributesToGeometry();

    // Store this emitter in this group's emitter's store.
    this.emitters.push( emitter );
    this.emitterIDs.push( emitter.uuid );

    // Update certain flags to enable shader calculations only if they're necessary.
    this._updateDefines( emitter );

    // Update the material since defines might have changed
    this.material.needsUpdate = true;
    this.geometry.needsUpdate = true;
    this._attributesNeedRefresh = true;

    // Return the group to enable chaining.
    return this;
};

/**
 * Removes an SPE.Emitter instance from this group. When called,
 * all particle's belonging to the given emitter will be instantly
 * removed from the scene.
 *
 * @param {Emitter} emitter The emitter to add to this group.
 */
SPE.Group.prototype.removeEmitter = function( emitter ) {
    'use strict';

    var emitterIndex = this.emitterIDs.indexOf( emitter.uuid );

    // Ensure an actual emitter instance is passed here.
    //
    // Decided not to throw here, just in case a scene's
    // rendering would be paused. Logging an error instead
    // of stopping execution if exceptions aren't caught.
    if ( emitter instanceof SPE.Emitter === false ) {
        console.error( '`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter );
        return;
    }

    // Issue an error if the emitter isn't a member of this group.
    else if ( emitterIndex === -1 ) {
        console.error( 'Emitter does not exist in this group. Will not remove.' );
        return;
    }

    // Kill all particles by marking them as dead
    // and their age as 0.
    var start = emitter.attributeOffset,
        end = start + emitter.particleCount,
        params = this.attributes.params.typedArray;

    // Set alive and age to zero.
    for ( var i = start; i < end; ++i ) {
        params.array[ i * 4 ] = 0.0;
        params.array[ i * 4 + 1 ] = 0.0;
    }

    // Remove the emitter from this group's "store".
    this.emitters.splice( emitterIndex, 1 );
    this.emitterIDs.splice( emitterIndex, 1 );

    // Remove this emitter's attribute values from all shader attributes.
    // The `.splice()` call here also marks each attribute's buffer
    // as needing to update it's entire contents.
    for ( var attr in this.attributes ) {
        if ( this.attributes.hasOwnProperty( attr ) ) {
            this.attributes[ attr ].splice( start, end );
        }
    }

    // Ensure this group's particle count is correct.
    this.particleCount -= emitter.particleCount;

    // Call the emitter's remove method.
    emitter._onRemove();

    // Set a flag to indicate that the attribute buffers should
    // be updated in their entirety on the next frame.
    this._attributesNeedRefresh = true;
};


/**
 * Fetch a single emitter instance from the pool.
 * If there are no objects in the pool, a new emitter will be
 * created if specified.
 *
 * @return {Emitter|null}
 */
SPE.Group.prototype.getFromPool = function() {
    'use strict';

    var pool = this._pool,
        createNew = this._createNewWhenPoolEmpty;

    if ( pool.length ) {
        return pool.pop();
    }
    else if ( createNew ) {
        return new SPE.Emitter( this._poolCreationSettings );
    }

    return null;
};


/**
 * Release an emitter into the pool.
 *
 * @param  {ShaderParticleEmitter} emitter
 * @return {Group} This group instance.
 */
SPE.Group.prototype.releaseIntoPool = function( emitter ) {
    'use strict';

    if ( emitter instanceof SPE.Emitter === false ) {
        console.error( 'Argument is not instanceof SPE.Emitter:', emitter );
        return;
    }

    emitter.reset();
    this._pool.unshift( emitter );

    return this;
};


/**
 * Get the pool array
 *
 * @return {Array}
 */
SPE.Group.prototype.getPool = function() {
    'use strict';
    return this._pool;
};


/**
 * Add a pool of emitters to this particle group
 *
 * @param {Number} numEmitters      The number of emitters to add to the pool.
 * @param {EmitterOptions|Array} emitterOptions  An object, or array of objects, describing the options to pass to each emitter.
 * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?
 * @return {Group} This group instance.
 */
SPE.Group.prototype.addPool = function( numEmitters, emitterOptions, createNew ) {
    'use strict';

    var emitter;

    // Save relevant settings and flags.
    this._poolCreationSettings = emitterOptions;
    this._createNewWhenPoolEmpty = !!createNew;

    // Create the emitters, add them to this group and the pool.
    for ( var i = 0; i < numEmitters; ++i ) {
        if ( Array.isArray( emitterOptions ) ) {
            emitter = new SPE.Emitter( emitterOptions[ i ] );
        }
        else {
            emitter = new SPE.Emitter( emitterOptions );
        }
        this.addEmitter( emitter );
        this.releaseIntoPool( emitter );
    }

    return this;
};



SPE.Group.prototype._triggerSingleEmitter = function( pos ) {
    'use strict';

    var emitter = this.getFromPool(),
        self = this;

    if ( emitter === null ) {
        console.log( 'SPE.Group pool ran out.' );
        return;
    }

    // TODO:
    // - Make sure buffers are update with thus new position.
    if ( pos instanceof THREE.Vector3 ) {
        emitter.position.value.copy( pos );

        // Trigger the setter for this property to force an
        // update to the emitter's position attribute.
        emitter.position.value = emitter.position.value;
    }

    emitter.enable();

    setTimeout( function() {
        emitter.disable();
        self.releaseIntoPool( emitter );
    }, ( Math.max( emitter.duration, ( emitter.maxAge.value + emitter.maxAge.spread ) ) ) * 1000 );

    return this;
};


/**
 * Set a given number of emitters as alive, with an optional position
 * vector3 to move them to.
 *
 * @param  {Number} numEmitters The number of emitters to activate
 * @param  {Object} [position=undefined] A THREE.Vector3 instance describing the position to activate the emitter(s) at.
 * @return {Group} This group instance.
 */
SPE.Group.prototype.triggerPoolEmitter = function( numEmitters, position ) {
    'use strict';

    if ( typeof numEmitters === 'number' && numEmitters > 1 ) {
        for ( var i = 0; i < numEmitters; ++i ) {
            this._triggerSingleEmitter( position );
        }
    }
    else {
        this._triggerSingleEmitter( position );
    }

    return this;
};



SPE.Group.prototype._updateUniforms = function( dt ) {
    'use strict';

    this.uniforms.runTime.value += dt;
    this.uniforms.deltaTime.value = dt;
};

SPE.Group.prototype._resetBufferRanges = function() {
    'use strict';

    var keys = this.attributeKeys,
        i = this.attributeCount - 1,
        attrs = this.attributes;

    for ( i; i >= 0; --i ) {
        attrs[ keys[ i ] ].resetUpdateRange();
    }
};


SPE.Group.prototype._updateBuffers = function( emitter ) {
    'use strict';

    var keys = this.attributeKeys,
        i = this.attributeCount - 1,
        attrs = this.attributes,
        emitterRanges = emitter.bufferUpdateRanges,
        key,
        emitterAttr,
        attr;

    for ( i; i >= 0; --i ) {
        key = keys[ i ];
        emitterAttr = emitterRanges[ key ];
        attr = attrs[ key ];
        attr.setUpdateRange( emitterAttr.min, emitterAttr.max );
        attr.flagUpdate();
    }
};


/**
 * Simulate all the emitter's belonging to this group, updating
 * attribute values along the way.
 * @param  {Number} [dt=Group's `fixedTimeStep` value] The number of seconds to simulate the group's emitters for (deltaTime)
 */
SPE.Group.prototype.tick = function( dt ) {
    'use strict';

    var emitters = this.emitters,
        numEmitters = emitters.length,
        deltaTime = dt || this.fixedTimeStep,
        keys = this.attributeKeys,
        i,
        attrs = this.attributes;

    // Update uniform values.
    this._updateUniforms( deltaTime );

    // Reset buffer update ranges on the shader attributes.
    this._resetBufferRanges();


    // If nothing needs updating, then stop here.
    if (
        numEmitters === 0 &&
        this._attributesNeedRefresh === false &&
        this._attributesNeedDynamicReset === false
    ) {
        return;
    }

    // Loop through each emitter in this group and
    // simulate it, then update the shader attribute
    // buffers.
    for ( var i = 0, emitter; i < numEmitters; ++i ) {
        emitter = emitters[ i ];
        emitter.tick( deltaTime );
        this._updateBuffers( emitter );
    }

    // If the shader attributes have been refreshed,
    // then the dynamic properties of each buffer
    // attribute will need to be reset back to
    // what they should be.
    if ( this._attributesNeedDynamicReset === true ) {
        i = this.attributeCount - 1;

        for ( i; i >= 0; --i ) {
            attrs[ keys[ i ] ].resetDynamic();
        }

        this._attributesNeedDynamicReset = false;
    }

    // If this group's shader attributes need a full refresh
    // then mark each attribute's buffer attribute as
    // needing so.
    if ( this._attributesNeedRefresh === true ) {
        i = this.attributeCount - 1;

        for ( i; i >= 0; --i ) {
            attrs[ keys[ i ] ].forceUpdateAll();
        }

        this._attributesNeedRefresh = false;
        this._attributesNeedDynamicReset = true;
    }
};


/**
 * Dipose the geometry and material for the group.
 *
 * @return {Group} Group instance.
 */
SPE.Group.prototype.dispose = function() {
    'use strict';
    this.geometry.dispose();
    this.material.dispose();
    return this;
};

/**
 * An SPE.Emitter instance.
 * @typedef {Object} Emitter
 * @see SPE.Emitter
 */

/**
 * A map of options to configure an SPE.Emitter instance.
 *
 * @typedef {Object} EmitterOptions
 *
 * @property {distribution} [type=BOX] The default distribution this emitter should use to control
 *                         its particle's spawn position and force behaviour.
 *                         Must be an SPE.distributions.* value.
 *
 *
 * @property {Number} [particleCount=100] The total number of particles this emitter will hold. NOTE: this is not the number
 *                                  of particles emitted in a second, or anything like that. The number of particles
 *                                  emitted per-second is calculated by particleCount / maxAge (approximately!)
 *
 * @property {Number|null} [duration=null] The duration in seconds that this emitter should live for. If not specified, the emitter
 *                                         will emit particles indefinitely.
 *                                         NOTE: When an emitter is older than a specified duration, the emitter is NOT removed from
 *                                         it's group, but rather is just marked as dead, allowing it to be reanimated at a later time
 *                                         using `SPE.Emitter.prototype.enable()`.
 *
 * @property {Boolean} [isStatic=false] Whether this emitter should be not be simulated (true).
 * @property {Boolean} [activeMultiplier=1] A value between 0 and 1 describing what percentage of this emitter's particlesPerSecond should be
 *                                          emitted, where 0 is 0%, and 1 is 100%.
 *                                          For example, having an emitter with 100 particles, a maxAge of 2, yields a particlesPerSecond
 *                                          value of 50. Setting `activeMultiplier` to 0.5, then, will only emit 25 particles per second (0.5 = 50%).
 *                                          Values greater than 1 will emulate a burst of particles, causing the emitter to run out of particles
 *                                          before it's next activation cycle.
 *
 * @property {Boolean} [direction=1] The direction of the emitter. If value is `1`, emitter will start at beginning of particle's lifecycle.
 *                                   If value is `-1`, emitter will start at end of particle's lifecycle and work it's way backwards.
 *
 * @property {Object} [maxAge={}] An object describing the particle's maximum age in seconds.
 * @property {Number} [maxAge.value=2] A number between 0 and 1 describing the amount of maxAge to apply to all particles.
 * @property {Number} [maxAge.spread=0] A number describing the maxAge variance on a per-particle basis.
 *
 *
 * @property {Object} [position={}] An object describing this emitter's position.
 * @property {Object} [position.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base position.
 * @property {Object} [position.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's position variance on a per-particle basis.
 *                                                          Note that when using a SPHERE or DISC distribution, only the x-component
 *                                                          of this vector is used.
 * @property {Object} [position.spreadClamp=new THREE.Vector3()] A THREE.Vector3 instance describing the numeric multiples the particle's should
 *                                                               be spread out over.
 *                                                               Note that when using a SPHERE or DISC distribution, only the x-component
 *                                                               of this vector is used.
 * @property {Number} [position.radius=10] This emitter's base radius.
 * @property {Object} [position.radiusScale=new THREE.Vector3()] A THREE.Vector3 instance describing the radius's scale in all three axes. Allows a SPHERE or DISC to be squashed or stretched.
 * @property {distribution} [position.distribution=value of the `type` option.] A specific distribution to use when radiusing particles. Overrides the `type` option.
 * @property {Boolean} [position.randomise=false] When a particle is re-spawned, whether it's position should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [velocity={}] An object describing this particle velocity.
 * @property {Object} [velocity.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base velocity.
 * @property {Object} [velocity.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's velocity variance on a per-particle basis.
 *                                                          Note that when using a SPHERE or DISC distribution, only the x-component
 *                                                          of this vector is used.
 * @property {distribution} [velocity.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's velocity. Overrides the `type` option.
 * @property {Boolean} [velocity.randomise=false] When a particle is re-spawned, whether it's velocity should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [acceleration={}] An object describing this particle's acceleration.
 * @property {Object} [acceleration.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base acceleration.
 * @property {Object} [acceleration.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's acceleration variance on a per-particle basis.
 *                           Note that when using a SPHERE or DISC distribution, only the x-component
 *                           of this vector is used.
 * @property {distribution} [acceleration.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's acceleration. Overrides the `type` option.
 * @property {Boolean} [acceleration.randomise=false] When a particle is re-spawned, whether it's acceleration should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [drag={}] An object describing this particle drag. Drag is applied to both velocity and acceleration values.
 * @property {Number} [drag.value=0] A number between 0 and 1 describing the amount of drag to apply to all particles.
 * @property {Number} [drag.spread=0] A number describing the drag variance on a per-particle basis.
 * @property {Boolean} [drag.randomise=false] When a particle is re-spawned, whether it's drag should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [wiggle={}] This is quite a fun one! The values of this object will determine whether a particle will wiggle, or jiggle, or wave,
 *                                or shimmy, or waggle, or... Well you get the idea. The wiggle is calculated over-time, meaning that a particle will
 *                                start off with no wiggle, and end up wiggling about with the distance of the `value` specified by the time it dies.
 *                                It's quite handy to simulate fire embers, or similar effects where the particle's position should slightly change over
 *                                time, and such change isn't easily controlled by rotation, velocity, or acceleration. The wiggle is a combination of sin and cos calculations, so is circular in nature.
 * @property {Number} [wiggle.value=0] A number describing the amount of wiggle to apply to all particles. It's measured in distance.
 * @property {Number} [wiggle.spread=0] A number describing the wiggle variance on a per-particle basis.
 *
 *
 * @property {Object} [rotation={}] An object describing this emitter's rotation. It can either be static, or set to rotate from 0radians to the value of `rotation.value`
 *                                  over a particle's lifetime. Rotation values affect both a particle's position and the forces applied to it.
 * @property {Object} [rotation.axis=new THREE.Vector3(0, 1, 0)] A THREE.Vector3 instance describing this emitter's axis of rotation.
 * @property {Object} [rotation.axisSpread=new THREE.Vector3()] A THREE.Vector3 instance describing the amount of variance to apply to the axis of rotation on
 *                                                              a per-particle basis.
 * @property {Number} [rotation.angle=0] The angle of rotation, given in radians. If `rotation.static` is true, the emitter will start off rotated at this angle, and stay as such.
 *                                       Otherwise, the particles will rotate from 0radians to this value over their lifetimes.
 * @property {Number} [rotation.angleSpread=0] The amount of variance in each particle's rotation angle.
 * @property {Boolean} [rotation.static=false] Whether the rotation should be static or not.
 * @property {Object} [rotation.center=The value of `position.value`] A THREE.Vector3 instance describing the center point of rotation.
 * @property {Boolean} [rotation.randomise=false] When a particle is re-spawned, whether it's rotation should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [color={}] An object describing a particle's color. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
 *                               given to describe specific value changes over a particle's lifetime.
 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of THREE.Color instances are given, then the array will be interpolated to
 *                               have a length matching the value of SPE.valueOverLifetimeLength.
 * @property {Object} [color.value=new THREE.Color()] Either a single THREE.Color instance, or an array of THREE.Color instances to describe the color of a particle over it's lifetime.
 * @property {Object} [color.spread=new THREE.Vector3()] Either a single THREE.Vector3 instance, or an array of THREE.Vector3 instances to describe the color variance of a particle over it's lifetime.
 * @property {Boolean} [color.randomise=false] When a particle is re-spawned, whether it's color should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [opacity={}] An object describing a particle's opacity. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
 *                               given to describe specific value changes over a particle's lifetime.
 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to
 *                               have a length matching the value of SPE.valueOverLifetimeLength.
 * @property {Number} [opacity.value=1] Either a single number, or an array of numbers to describe the opacity of a particle over it's lifetime.
 * @property {Number} [opacity.spread=0] Either a single number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.
 * @property {Boolean} [opacity.randomise=false] When a particle is re-spawned, whether it's opacity should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [size={}] An object describing a particle's size. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
 *                               given to describe specific value changes over a particle's lifetime.
 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to
 *                               have a length matching the value of SPE.valueOverLifetimeLength.
 * @property {Number} [size.value=1] Either a single number, or an array of numbers to describe the size of a particle over it's lifetime.
 * @property {Number} [size.spread=0] Either a single number, or an array of numbers to describe the size variance of a particle over it's lifetime.
 * @property {Boolean} [size.randomise=false] When a particle is re-spawned, whether it's size should be re-randomised or not. Can incur a performance hit.
 *
 *
 * @property {Object} [angle={}] An object describing a particle's angle. The angle is a 2d-rotation, measured in radians, applied to the particle's texture.
 *                               NOTE: if a particle's texture is a sprite-sheet, this value IS IGNORED.
 *                               This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
 *                               given to describe specific value changes over a particle's lifetime.
 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to
 *                               have a length matching the value of SPE.valueOverLifetimeLength.
 * @property {Number} [angle.value=0] Either a single number, or an array of numbers to describe the angle of a particle over it's lifetime.
 * @property {Number} [angle.spread=0] Either a single number, or an array of numbers to describe the angle variance of a particle over it's lifetime.
 * @property {Boolean} [angle.randomise=false] When a particle is re-spawned, whether it's angle should be re-randomised or not. Can incur a performance hit.
 *
 */

/**
 * The SPE.Emitter class.
 *
 * @constructor
 *
 * @param {EmitterOptions} options A map of options to configure the emitter.
 */
SPE.Emitter = function( options ) {
    'use strict';

    var utils = SPE.utils,
        types = utils.types,
        lifetimeLength = SPE.valueOverLifetimeLength;

    // Ensure we have a map of options to play with,
    // and that each option is in the correct format.
    options = utils.ensureTypedArg( options, types.OBJECT, {} );
    options.position = utils.ensureTypedArg( options.position, types.OBJECT, {} );
    options.velocity = utils.ensureTypedArg( options.velocity, types.OBJECT, {} );
    options.acceleration = utils.ensureTypedArg( options.acceleration, types.OBJECT, {} );
    options.radius = utils.ensureTypedArg( options.radius, types.OBJECT, {} );
    options.drag = utils.ensureTypedArg( options.drag, types.OBJECT, {} );
    options.rotation = utils.ensureTypedArg( options.rotation, types.OBJECT, {} );
    options.color = utils.ensureTypedArg( options.color, types.OBJECT, {} );
    options.opacity = utils.ensureTypedArg( options.opacity, types.OBJECT, {} );
    options.size = utils.ensureTypedArg( options.size, types.OBJECT, {} );
    options.angle = utils.ensureTypedArg( options.angle, types.OBJECT, {} );
    options.wiggle = utils.ensureTypedArg( options.wiggle, types.OBJECT, {} );
    options.maxAge = utils.ensureTypedArg( options.maxAge, types.OBJECT, {} );

    if ( options.onParticleSpawn ) {
        console.warn( 'onParticleSpawn has been removed. Please set properties directly to alter values at runtime.' );
    }

    this.uuid = THREE.Math.generateUUID();

    this.type = utils.ensureTypedArg( options.type, types.NUMBER, SPE.distributions.BOX );

    // Start assigning properties...kicking it off with props that DON'T support values over
    // lifetimes.
    //
    // Btw, values over lifetimes are just the new way of referring to *Start, *Middle, and *End.
    this.position = {
        _value: utils.ensureInstanceOf( options.position.value, THREE.Vector3, new THREE.Vector3() ),
        _spread: utils.ensureInstanceOf( options.position.spread, THREE.Vector3, new THREE.Vector3() ),
        _spreadClamp: utils.ensureInstanceOf( options.position.spreadClamp, THREE.Vector3, new THREE.Vector3() ),
        _distribution: utils.ensureTypedArg( options.position.distribution, types.NUMBER, this.type ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false ),
        _radius: utils.ensureTypedArg( options.position.radius, types.NUMBER, 10 ),
        _radiusScale: utils.ensureInstanceOf( options.position.radiusScale, THREE.Vector3, new THREE.Vector3( 1, 1, 1 ) ),
        _distributionClamp: utils.ensureTypedArg( options.position.distributionClamp, types.NUMBER, 0 ),
    };

    this.velocity = {
        _value: utils.ensureInstanceOf( options.velocity.value, THREE.Vector3, new THREE.Vector3() ),
        _spread: utils.ensureInstanceOf( options.velocity.spread, THREE.Vector3, new THREE.Vector3() ),
        _distribution: utils.ensureTypedArg( options.velocity.distribution, types.NUMBER, this.type ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };

    this.acceleration = {
        _value: utils.ensureInstanceOf( options.acceleration.value, THREE.Vector3, new THREE.Vector3() ),
        _spread: utils.ensureInstanceOf( options.acceleration.spread, THREE.Vector3, new THREE.Vector3() ),
        _distribution: utils.ensureTypedArg( options.acceleration.distribution, types.NUMBER, this.type ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };

    this.drag = {
        _value: utils.ensureTypedArg( options.drag.value, types.NUMBER, 0 ),
        _spread: utils.ensureTypedArg( options.drag.spread, types.NUMBER, 0 ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };

    this.wiggle = {
        _value: utils.ensureTypedArg( options.wiggle.value, types.NUMBER, 0 ),
        _spread: utils.ensureTypedArg( options.wiggle.spread, types.NUMBER, 0 )
    };

    this.rotation = {
        _axis: utils.ensureInstanceOf( options.rotation.axis, THREE.Vector3, new THREE.Vector3( 0.0, 1.0, 0.0 ) ),
        _axisSpread: utils.ensureInstanceOf( options.rotation.axisSpread, THREE.Vector3, new THREE.Vector3() ),
        _angle: utils.ensureTypedArg( options.rotation.angle, types.NUMBER, 0 ),
        _angleSpread: utils.ensureTypedArg( options.rotation.angleSpread, types.NUMBER, 0 ),
        _static: utils.ensureTypedArg( options.rotation.static, types.BOOLEAN, false ),
        _center: utils.ensureInstanceOf( options.rotation.center, THREE.Vector3, this.position._value.clone() ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };


    this.maxAge = {
        _value: utils.ensureTypedArg( options.maxAge.value, types.NUMBER, 2 ),
        _spread: utils.ensureTypedArg( options.maxAge.spread, types.NUMBER, 0 )
    };



    // The following properties can support either single values, or an array of values that change
    // the property over a particle's lifetime (value over lifetime).
    this.color = {
        _value: utils.ensureArrayInstanceOf( options.color.value, THREE.Color, new THREE.Color() ),
        _spread: utils.ensureArrayInstanceOf( options.color.spread, THREE.Vector3, new THREE.Vector3() ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };

    this.opacity = {
        _value: utils.ensureArrayTypedArg( options.opacity.value, types.NUMBER, 1 ),
        _spread: utils.ensureArrayTypedArg( options.opacity.spread, types.NUMBER, 0 ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };

    this.size = {
        _value: utils.ensureArrayTypedArg( options.size.value, types.NUMBER, 1 ),
        _spread: utils.ensureArrayTypedArg( options.size.spread, types.NUMBER, 0 ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };

    this.angle = {
        _value: utils.ensureArrayTypedArg( options.angle.value, types.NUMBER, 0 ),
        _spread: utils.ensureArrayTypedArg( options.angle.spread, types.NUMBER, 0 ),
        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )
    };


    // Assign renaining option values.
    this.particleCount = utils.ensureTypedArg( options.particleCount, types.NUMBER, 100 );
    this.duration = utils.ensureTypedArg( options.duration, types.NUMBER, null );
    this.isStatic = utils.ensureTypedArg( options.isStatic, types.BOOLEAN, false );
    this.activeMultiplier = utils.ensureTypedArg( options.activeMultiplier, types.NUMBER, 1 );
    this.direction = utils.ensureTypedArg( options.direction, types.NUMBER, 1 );

    // Whether this emitter is alive or not.
    this.alive = utils.ensureTypedArg( options.alive, types.BOOLEAN, true );


    // The following properties are set internally and are not
    // user-controllable.
    this.particlesPerSecond = 0;

    // The current particle index for which particles should
    // be marked as active on the next update cycle.
    this.activationIndex = 0;

    // The offset in the typed arrays this emitter's
    // particle's values will start at
    this.attributeOffset = 0;

    // The end of the range in the attribute buffers
    this.attributeEnd = 0;



    // Holds the time the emitter has been alive for.
    this.age = 0.0;

    // Holds the number of currently-alive particles
    this.activeParticleCount = 0.0;

    // Holds a reference to this emitter's group once
    // it's added to one.
    this.group = null;

    // Holds a reference to this emitter's group's attributes object
    // for easier access.
    this.attributes = null;

    // Holds a reference to the params attribute's typed array
    // for quicker access.
    this.paramsArray = null;

    // A set of flags to determine whether particular properties
    // should be re-randomised when a particle is reset.
    //
    // If a `randomise` property is given, this is preferred.
    // Otherwise, it looks at whether a spread value has been
    // given.
    //
    // It allows randomization to be turned off as desired. If
    // all randomization is turned off, then I'd expect a performance
    // boost as no attribute buffers (excluding the `params`)
    // would have to be re-passed to the GPU each frame (since nothing
    // except the `params` attribute would have changed).
    this.resetFlags = {
        // params: utils.ensureTypedArg( options.maxAge.randomise, types.BOOLEAN, !!options.maxAge.spread ) ||
        //     utils.ensureTypedArg( options.wiggle.randomise, types.BOOLEAN, !!options.wiggle.spread ),
        position: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false ) ||
            utils.ensureTypedArg( options.radius.randomise, types.BOOLEAN, false ),
        velocity: utils.ensureTypedArg( options.velocity.randomise, types.BOOLEAN, false ),
        acceleration: utils.ensureTypedArg( options.acceleration.randomise, types.BOOLEAN, false ) ||
            utils.ensureTypedArg( options.drag.randomise, types.BOOLEAN, false ),
        rotation: utils.ensureTypedArg( options.rotation.randomise, types.BOOLEAN, false ),
        rotationCenter: utils.ensureTypedArg( options.rotation.randomise, types.BOOLEAN, false ),
        size: utils.ensureTypedArg( options.size.randomise, types.BOOLEAN, false ),
        color: utils.ensureTypedArg( options.color.randomise, types.BOOLEAN, false ),
        opacity: utils.ensureTypedArg( options.opacity.randomise, types.BOOLEAN, false ),
        angle: utils.ensureTypedArg( options.angle.randomise, types.BOOLEAN, false )
    };

    this.updateFlags = {};
    this.updateCounts = {};

    // A map to indicate which emitter parameters should update
    // which attribute.
    this.updateMap = {
        maxAge: 'params',
        position: 'position',
        velocity: 'velocity',
        acceleration: 'acceleration',
        drag: 'acceleration',
        wiggle: 'params',
        rotation: 'rotation',
        size: 'size',
        color: 'color',
        opacity: 'opacity',
        angle: 'angle'
    };

    for ( var i in this.updateMap ) {
        if ( this.updateMap.hasOwnProperty( i ) ) {
            this.updateCounts[ this.updateMap[ i ] ] = 0.0;
            this.updateFlags[ this.updateMap[ i ] ] = false;
            this._createGetterSetters( this[ i ], i );
        }
    }

    this.bufferUpdateRanges = {};
    this.attributeKeys = null;
    this.attributeCount = 0;


    // Ensure that the value-over-lifetime property objects above
    // have value and spread properties that are of the same length.
    //
    // Also, for now, make sure they have a length of 3 (min/max arguments here).
    utils.ensureValueOverLifetimeCompliance( this.color, lifetimeLength, lifetimeLength );
    utils.ensureValueOverLifetimeCompliance( this.opacity, lifetimeLength, lifetimeLength );
    utils.ensureValueOverLifetimeCompliance( this.size, lifetimeLength, lifetimeLength );
    utils.ensureValueOverLifetimeCompliance( this.angle, lifetimeLength, lifetimeLength );
};

SPE.Emitter.constructor = SPE.Emitter;

SPE.Emitter.prototype._createGetterSetters = function( propObj, propName ) {
    'use strict';

    var self = this;

    for ( var i in propObj ) {
        if ( propObj.hasOwnProperty( i ) ) {

            var name = i.replace( '_', '' );

            Object.defineProperty( propObj, name, {
                get: ( function( prop ) {
                    return function() {
                        return this[ prop ];
                    };
                }( i ) ),

                set: ( function( prop ) {
                    return function( value ) {
                        var mapName = self.updateMap[ propName ],
                            prevValue = this[ prop ],
                            length = SPE.valueOverLifetimeLength;

                        if ( prop === '_rotationCenter' ) {
                            self.updateFlags.rotationCenter = true;
                            self.updateCounts.rotationCenter = 0.0;
                        }
                        else if ( prop === '_randomise' ) {
                            self.resetFlags[ mapName ] = value;
                        }
                        else {
                            self.updateFlags[ mapName ] = true;
                            self.updateCounts[ mapName ] = 0.0;
                        }

                        self.group._updateDefines();

                        this[ prop ] = value;

                        // If the previous value was an array, then make
                        // sure the provided value is interpolated correctly.
                        if ( Array.isArray( prevValue ) ) {
                            SPE.utils.ensureValueOverLifetimeCompliance( self[ propName ], length, length );
                        }
                    };
                }( i ) )
            } );
        }
    }
};

SPE.Emitter.prototype._setBufferUpdateRanges = function( keys ) {
    'use strict';

    this.attributeKeys = keys;
    this.attributeCount = keys.length;

    for ( var i = this.attributeCount - 1; i >= 0; --i ) {
        this.bufferUpdateRanges[ keys[ i ] ] = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
    }
};

SPE.Emitter.prototype._calculatePPSValue = function( groupMaxAge ) {
    'use strict';

    var particleCount = this.particleCount;


    // Calculate the `particlesPerSecond` value for this emitter. It's used
    // when determining which particles should die and which should live to
    // see another day. Or be born, for that matter. The "God" property.
    if ( this.duration ) {
        this.particlesPerSecond = particleCount / ( groupMaxAge < this.duration ? groupMaxAge : this.duration );
    }
    else {
        this.particlesPerSecond = particleCount / groupMaxAge;
    }
};

SPE.Emitter.prototype._setAttributeOffset = function( startIndex ) {
    this.attributeOffset = startIndex;
    this.activationIndex = startIndex;
    this.activationEnd = startIndex + this.particleCount;
};


SPE.Emitter.prototype._assignValue = function( prop, index ) {
    'use strict';

    switch ( prop ) {
        case 'position':
            this._assignPositionValue( index );
            break;

        case 'velocity':
        case 'acceleration':
            this._assignForceValue( index, prop );
            break;

        case 'size':
        case 'opacity':
            this._assignAbsLifetimeValue( index, prop );
            break;

        case 'angle':
            this._assignAngleValue( index );
            break;

        case 'params':
            this._assignParamsValue( index );
            break;

        case 'rotation':
            this._assignRotationValue( index );
            break;

        case 'color':
            this._assignColorValue( index );
            break;
    }
};

SPE.Emitter.prototype._assignPositionValue = function( index ) {
    'use strict';

    var distributions = SPE.distributions,
        utils = SPE.utils,
        prop = this.position,
        attr = this.attributes.position,
        value = prop._value,
        spread = prop._spread,
        distribution = prop._distribution;

    switch ( distribution ) {
        case distributions.BOX:
            utils.randomVector3( attr, index, value, spread, prop._spreadClamp );
            break;

        case distributions.SPHERE:
            utils.randomVector3OnSphere( attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount );
            break;

        case distributions.DISC:
            utils.randomVector3OnDisc( attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x );
            break;
    }
};

SPE.Emitter.prototype._assignForceValue = function( index, attrName ) {
    'use strict';

    var distributions = SPE.distributions,
        utils = SPE.utils,
        prop = this[ attrName ],
        value = prop._value,
        spread = prop._spread,
        distribution = prop._distribution,
        pos,
        positionX,
        positionY,
        positionZ,
        i;

    switch ( distribution ) {
        case distributions.BOX:
            utils.randomVector3( this.attributes[ attrName ], index, value, spread );
            break;

        case distributions.SPHERE:
            pos = this.attributes.position.typedArray.array;
            i = index * 3;

            // Ensure position values aren't zero, otherwise no force will be
            // applied.
            // positionX = utils.zeroToEpsilon( pos[ i ], true );
            // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );
            // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );
            positionX = pos[ i ];
            positionY = pos[ i + 1 ];
            positionZ = pos[ i + 2 ];

            utils.randomDirectionVector3OnSphere(
                this.attributes[ attrName ], index,
                positionX, positionY, positionZ,
                this.position._value,
                prop._value.x,
                prop._spread.x
            );
            break;

        case distributions.DISC:
            pos = this.attributes.position.typedArray.array;
            i = index * 3;

            // Ensure position values aren't zero, otherwise no force will be
            // applied.
            // positionX = utils.zeroToEpsilon( pos[ i ], true );
            // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );
            // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );
            positionX = pos[ i ];
            positionY = pos[ i + 1 ];
            positionZ = pos[ i + 2 ];

            utils.randomDirectionVector3OnDisc(
                this.attributes[ attrName ], index,
                positionX, positionY, positionZ,
                this.position._value,
                prop._value.x,
                prop._spread.x
            );
            break;
    }

    if ( attrName === 'acceleration' ) {
        var drag = utils.clamp( utils.randomFloat( this.drag._value, this.drag._spread ), 0, 1 );
        this.attributes.acceleration.typedArray.array[ index * 4 + 3 ] = drag;
    }
};

SPE.Emitter.prototype._assignAbsLifetimeValue = function( index, propName ) {
    'use strict';

    var array = this.attributes[ propName ].typedArray,
        prop = this[ propName ],
        utils = SPE.utils,
        value;

    if ( utils.arrayValuesAreEqual( prop._value ) && utils.arrayValuesAreEqual( prop._spread ) ) {
        value = Math.abs( utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ) );
        array.setVec4Components( index, value, value, value, value );
    }
    else {
        array.setVec4Components( index,
            Math.abs( utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ) ),
            Math.abs( utils.randomFloat( prop._value[ 1 ], prop._spread[ 1 ] ) ),
            Math.abs( utils.randomFloat( prop._value[ 2 ], prop._spread[ 2 ] ) ),
            Math.abs( utils.randomFloat( prop._value[ 3 ], prop._spread[ 3 ] ) )
        );
    }
};

SPE.Emitter.prototype._assignAngleValue = function( index ) {
    'use strict';

    var array = this.attributes.angle.typedArray,
        prop = this.angle,
        utils = SPE.utils,
        value;

    if ( utils.arrayValuesAreEqual( prop._value ) && utils.arrayValuesAreEqual( prop._spread ) ) {
        value = utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] );
        array.setVec4Components( index, value, value, value, value );
    }
    else {
        array.setVec4Components( index,
            utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ),
            utils.randomFloat( prop._value[ 1 ], prop._spread[ 1 ] ),
            utils.randomFloat( prop._value[ 2 ], prop._spread[ 2 ] ),
            utils.randomFloat( prop._value[ 3 ], prop._spread[ 3 ] )
        );
    }
};

SPE.Emitter.prototype._assignParamsValue = function( index ) {
    'use strict';

    this.attributes.params.typedArray.setVec4Components( index,
        this.isStatic ? 1 : 0,
        0.0,
        Math.abs( SPE.utils.randomFloat( this.maxAge._value, this.maxAge._spread ) ),
        SPE.utils.randomFloat( this.wiggle._value, this.wiggle._spread )
    );
};

SPE.Emitter.prototype._assignRotationValue = function( index ) {
    'use strict';

    this.attributes.rotation.typedArray.setVec3Components( index,
        SPE.utils.getPackedRotationAxis( this.rotation._axis, this.rotation._axisSpread ),
        SPE.utils.randomFloat( this.rotation._angle, this.rotation._angleSpread ),
        this.rotation._static ? 0 : 1
    );

    this.attributes.rotationCenter.typedArray.setVec3( index, this.rotation._center );
};

SPE.Emitter.prototype._assignColorValue = function( index ) {
    'use strict';
    SPE.utils.randomColorAsHex( this.attributes.color, index, this.color._value, this.color._spread );
};

SPE.Emitter.prototype._resetParticle = function( index ) {
    'use strict';

    var resetFlags = this.resetFlags,
        updateFlags = this.updateFlags,
        updateCounts = this.updateCounts,
        keys = this.attributeKeys,
        key,
        updateFlag;

    for ( var i = this.attributeCount - 1; i >= 0; --i ) {
        key = keys[ i ];
        updateFlag = updateFlags[ key ];

        if ( resetFlags[ key ] === true || updateFlag === true ) {
            this._assignValue( key, index );
            this._updateAttributeUpdateRange( key, index );

            if ( updateFlag === true && updateCounts[ key ] === this.particleCount ) {
                updateFlags[ key ] = false;
                updateCounts[ key ] = 0.0;
            }
            else if ( updateFlag == true ) {
                ++updateCounts[ key ];
            }
        }
    }
};

SPE.Emitter.prototype._updateAttributeUpdateRange = function( attr, i ) {
    'use strict';

    var ranges = this.bufferUpdateRanges[ attr ];

    ranges.min = Math.min( i, ranges.min );
    ranges.max = Math.max( i, ranges.max );
};

SPE.Emitter.prototype._resetBufferRanges = function() {
    'use strict';

    var ranges = this.bufferUpdateRanges,
        keys = this.bufferUpdateKeys,
        i = this.bufferUpdateCount - 1,
        key;

    for ( i; i >= 0; --i ) {
        key = keys[ i ];
        ranges[ key ].min = Number.POSITIVE_INFINITY;
        ranges[ key ].max = Number.NEGATIVE_INFINITY;
    }
};

SPE.Emitter.prototype._onRemove = function() {
    'use strict';
    // Reset any properties of the emitter that were set by
    // a group when it was added.
    this.particlesPerSecond = 0;
    this.attributeOffset = 0;
    this.activationIndex = 0;
    this.activeParticleCount = 0;
    this.group = null;
    this.attributes = null;
    this.paramsArray = null;
    this.age = 0.0;
};

SPE.Emitter.prototype._decrementParticleCount = function() {
    'use strict';
    --this.activeParticleCount;

    // TODO:
    //  - Trigger event if count === 0.
};

SPE.Emitter.prototype._incrementParticleCount = function() {
    'use strict';
    ++this.activeParticleCount;

    // TODO:
    //  - Trigger event if count === this.particleCount.
};

SPE.Emitter.prototype._checkParticleAges = function( start, end, params, dt ) {
    'use strict';
    for ( var i = end - 1, index, maxAge, age, alive; i >= start; --i ) {
        index = i * 4;

        alive = params[ index ];

        if ( alive === 0.0 ) {
            continue;
        }

        // Increment age
        age = params[ index + 1 ];
        maxAge = params[ index + 2 ];

        if ( this.direction === 1 ) {
            age += dt;

            if ( age >= maxAge ) {
                age = 0.0;
                alive = 0.0;
                this._decrementParticleCount();
            }
        }
        else {
            age -= dt;

            if ( age <= 0.0 ) {
                age = maxAge;
                alive = 0.0;
                this._decrementParticleCount();
            }
        }

        params[ index ] = alive;
        params[ index + 1 ] = age;

        this._updateAttributeUpdateRange( 'params', i );
    }
};

SPE.Emitter.prototype._activateParticles = function( activationStart, activationEnd, params, dtPerParticle ) {
    'use strict';
    var direction = this.direction;

    for ( var i = activationStart, index, dtValue; i < activationEnd; ++i ) {
        index = i * 4;

        // Don't re-activate particles that aren't dead yet.
        // if ( params[ index ] !== 0.0 && ( this.particleCount !== 1 || this.activeMultiplier !== 1 ) ) {
        //     continue;
        // }

        if ( params[ index ] != 0.0 && this.particleCount !== 1 ) {
            continue;
        }

        // Increment the active particle count.
        this._incrementParticleCount();

        // Mark the particle as alive.
        params[ index ] = 1.0;

        // Reset the particle
        this._resetParticle( i );

        // Move each particle being activated to
        // it's actual position in time.
        //
        // This stops particles being 'clumped' together
        // when frame rates are on the lower side of 60fps
        // or not constant (a very real possibility!)
        dtValue = dtPerParticle * ( i - activationStart )
        params[ index + 1 ] = direction === -1 ? params[ index + 2 ] - dtValue : dtValue;

        this._updateAttributeUpdateRange( 'params', i );
    }
};

/**
 * Simulates one frame's worth of particles, updating particles
 * that are already alive, and marking ones that are currently dead
 * but should be alive as alive.
 *
 * If the emitter is marked as static, then this function will do nothing.
 *
 * @param  {Number} dt The number of seconds to simulate (deltaTime)
 */
SPE.Emitter.prototype.tick = function( dt ) {
    'use strict';

    if ( this.isStatic ) {
        return;
    }

    if ( this.paramsArray === null ) {
        this.paramsArray = this.attributes.params.typedArray.array;
    }

    var start = this.attributeOffset,
        end = start + this.particleCount,
        params = this.paramsArray, // vec3( alive, age, maxAge, wiggle )
        ppsDt = this.particlesPerSecond * this.activeMultiplier * dt,
        activationIndex = this.activationIndex;

    // Reset the buffer update indices.
    this._resetBufferRanges();

    // Increment age for those particles that are alive,
    // and kill off any particles whose age is over the limit.
    this._checkParticleAges( start, end, params, dt );

    // If the emitter is dead, reset the age of the emitter to zero,
    // ready to go again if required
    if ( this.alive === false ) {
        this.age = 0.0;
        return;
    }

    // If the emitter has a specified lifetime and we've exceeded it,
    // mark the emitter as dead.
    if ( this.duration !== null && this.age > this.duration ) {
        this.alive = false;
        this.age = 0.0;
        return;
    }


    var activationStart = this.particleCount === 1 ? activationIndex : ( activationIndex | 0 ),
        activationEnd = Math.min( activationStart + ppsDt, this.activationEnd ),
        activationCount = activationEnd - this.activationIndex | 0,
        dtPerParticle = activationCount > 0 ? dt / activationCount : 0;

    this._activateParticles( activationStart, activationEnd, params, dtPerParticle );

    // Move the activation window forward, soldier.
    this.activationIndex += ppsDt;

    if ( this.activationIndex > end ) {
        this.activationIndex = start;
    }


    // Increment the age of the emitter.
    this.age += dt;
};

/**
 * Resets all the emitter's particles to their start positions
 * and marks the particles as dead if the `force` argument is
 * true.
 *
 * @param  {Boolean} [force=undefined] If true, all particles will be marked as dead instantly.
 * @return {Emitter}       This emitter instance.
 */
SPE.Emitter.prototype.reset = function( force ) {
    'use strict';

    this.age = 0.0;
    this.alive = false;

    if ( force === true ) {
        var start = this.attributeOffset,
            end = start + this.particleCount,
            array = this.paramsArray,
            attr = this.attributes.params.bufferAttribute;

        for ( var i = end - 1, index; i >= start; --i ) {
            index = i * 4;

            array[ index ] = 0.0;
            array[ index + 1 ] = 0.0;
        }

        attr.updateRange.offset = 0;
        attr.updateRange.count = -1;
        attr.needsUpdate = true;
    }

    return this;
};

/**
 * Enables the emitter. If not already enabled, the emitter
 * will start emitting particles.
 *
 * @return {Emitter} This emitter instance.
 */
SPE.Emitter.prototype.enable = function() {
    'use strict';
    this.alive = true;
    return this;
};

/**
 * Disables th emitter, but does not instantly remove it's
 * particles fromt the scene. When called, the emitter will be
 * 'switched off' and just stop emitting. Any particle's alive will
 * be allowed to finish their lifecycle.
 *
 * @return {Emitter} This emitter instance.
 */
SPE.Emitter.prototype.disable = function() {
    'use strict';

    this.alive = false;
    return this;
};

/**
 * Remove this emitter from it's parent group (if it has been added to one).
 * Delgates to SPE.group.prototype.removeEmitter().
 *
 * When called, all particle's belonging to this emitter will be instantly
 * removed from the scene.
 *
 * @return {Emitter} This emitter instance.
 *
 * @see SPE.Group.prototype.removeEmitter
 */
SPE.Emitter.prototype.remove = function() {
    'use strict';
    if ( this.group !== null ) {
        this.group.removeEmitter( this );
    }
    else {
        console.error( 'Emitter does not belong to a group, cannot remove.' );
    }

    return this;
};


/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = {
  'basic': {wrapCount: 30, inputOffsetY: 0.008, inputOffsetX: 0.08, img: 'sk-basic.png', layout: [{'key': '1', 'x': 0.044, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': '2', 'x': 0.124, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': '3', 'x': 0.203, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': '4', 'x': 0.282, 'y': 0.226, 'w': 0.08, 'h': 0.152}, {'key': '5', 'x': 0.363, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': '6', 'x': 0.442, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': '7', 'x': 0.521, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': '8', 'x': 0.601, 'y': 0.226, 'w': 0.08, 'h': 0.152}, {'key': '9', 'x': 0.681, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': '0', 'x': 0.761, 'y': 0.226, 'w': 0.079, 'h': 0.152}, {'key': 'Delete', 'x': 0.846, 'y': 0.227, 'w': 0.108, 'h': 0.146}, {'key': 'Enter', 'x': 0.847, 'y': 0.526, 'w': 0.108, 'h': 0.244}, {'key': 'q', 'x': 0.044, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'w', 'x': 0.124, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'e', 'x': 0.203, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'r', 'x': 0.282, 'y': 0.377, 'w': 0.08, 'h': 0.152}, {'key': 't', 'x': 0.363, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'y', 'x': 0.442, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'u', 'x': 0.521, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'i', 'x': 0.601, 'y': 0.377, 'w': 0.08, 'h': 0.152}, {'key': 'o', 'x': 0.681, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'p', 'x': 0.761, 'y': 0.377, 'w': 0.079, 'h': 0.152}, {'key': 'l', 'x': 0.729, 'y': 0.53, 'w': 0.08, 'h': 0.154}, {'key': 'a', 'x': 0.092, 'y': 0.53, 'w': 0.08, 'h': 0.154}, {'key': 's', 'x': 0.171, 'y': 0.53, 'w': 0.08, 'h': 0.154}, {'key': 'd', 'x': 0.251, 'y': 0.53, 'w': 0.08, 'h': 0.154}, {'key': 'f', 'x': 0.331, 'y': 0.53, 'w': 0.079, 'h': 0.154}, {'key': 'g', 'x': 0.41, 'y': 0.53, 'w': 0.08, 'h': 0.154}, {'key': 'h', 'x': 0.49, 'y': 0.53, 'w': 0.079, 'h': 0.154}, {'key': 'j', 'x': 0.57, 'y': 0.53, 'w': 0.079, 'h': 0.154}, {'key': 'k', 'x': 0.649, 'y': 0.53, 'w': 0.08, 'h': 0.154}, {'key': 'z', 'x': 0.172, 'y': 0.684, 'w': 0.079, 'h': 0.154}, {'key': 'x', 'x': 0.251, 'y': 0.684, 'w': 0.08, 'h': 0.154}, {'key': 'c', 'x': 0.331, 'y': 0.684, 'w': 0.079, 'h': 0.154}, {'key': 'v', 'x': 0.41, 'y': 0.684, 'w': 0.08, 'h': 0.154}, {'key': 'b', 'x': 0.49, 'y': 0.684, 'w': 0.08, 'h': 0.154}, {'key': 'n', 'x': 0.57, 'y': 0.684, 'w': 0.079, 'h': 0.154}, {'key': 'm', 'x': 0.649, 'y': 0.684, 'w': 0.08, 'h': 0.154}, {'key': ' ', 'x': 0.27, 'y': 0.838, 'w': 0.415, 'h': 0.126}, {'key': 'Shift', 'x': 0.042, 'y': 0.827, 'w': 0.068, 'h': 0.142}, {'key': 'Escape', 'x': 0.876, 'y': 0.823, 'w': 0.078, 'h': 0.134}, {'key': 'Insert', 'x': 0.058, 'y': 0, 'w': 0.881, 'h': 0.149}]},
  'numpad': {wrapCount: 20, inputOffsetY: 0.005, inputOffsetX: 0.32, img: 'sk-numpad.png', layout: [{'key': '7', 'x': 0.313, 'y': 0.254, 'w': 0.088, 'h': 0.177}, {'key': '8', 'x': 0.401, 'y': 0.254, 'w': 0.088, 'h': 0.177}, {'key': '9', 'x': 0.49, 'y': 0.254, 'w': 0.088, 'h': 0.177}, {'key': '4', 'x': 0.313, 'y': 0.431, 'w': 0.088, 'h': 0.177}, {'key': '5', 'x': 0.401, 'y': 0.431, 'w': 0.088, 'h': 0.177}, {'key': '6', 'x': 0.49, 'y': 0.431, 'w': 0.088, 'h': 0.177}, {'key': '2', 'x': 0.401, 'y': 0.608, 'w': 0.088, 'h': 0.177}, {'key': '1', 'x': 0.313, 'y': 0.608, 'w': 0.088, 'h': 0.177}, {'key': '3', 'x': 0.49, 'y': 0.608, 'w': 0.088, 'h': 0.177}, {'key': '0', 'x': 0.313, 'y': 0.785, 'w': 0.177, 'h': 0.161}, {'key': '.', 'x': 0.49, 'y': 0.785, 'w': 0.088, 'h': 0.161}, {'key': 'Escape', 'x': 0.578, 'y': 0.785, 'w': 0.105, 'h': 0.161}, {'key': 'Enter', 'x': 0.578, 'y': 0.431, 'w': 0.105, 'h': 0.354}, {'key': 'Delete', 'x': 0.578, 'y': 0.254, 'w': 0.105, 'h': 0.177}, {'key': 'Insert', 'x': 0.294, 'y': 0.001, 'w': 0.409, 'h': 0.19}]}
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {module.exports = AlgoliaSearchCore;

var errors = __webpack_require__(53);
var exitPromise = __webpack_require__(166);
var IndexCore = __webpack_require__(159);
var store = __webpack_require__(169);

// We will always put the API KEY in the JSON body in case of too long API KEY,
// to avoid query string being too long and failing in various conditions (our server limit, browser limit,
// proxies limit)
var MAX_API_KEY_LENGTH = 500;
var RESET_APP_DATA_TIMER =
  process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) ||
  60 * 2 * 1000; // after 2 minutes reset to first host

/*
 * Algolia Search library initialization
 * https://www.algolia.com/
 *
 * @param {string} applicationID - Your applicationID, found in your dashboard
 * @param {string} apiKey - Your API key, found in your dashboard
 * @param {Object} [opts]
 * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,
 * another request will be issued after this timeout
 * @param {string} [opts.protocol='https:'] - The protocol used to query Algolia Search API.
 *                                        Set to 'http:' to force using http.
 * @param {Object|Array} [opts.hosts={
 *           read: [this.applicationID + '-dsn.algolia.net'].concat([
 *             this.applicationID + '-1.algolianet.com',
 *             this.applicationID + '-2.algolianet.com',
 *             this.applicationID + '-3.algolianet.com']
 *           ]),
 *           write: [this.applicationID + '.algolia.net'].concat([
 *             this.applicationID + '-1.algolianet.com',
 *             this.applicationID + '-2.algolianet.com',
 *             this.applicationID + '-3.algolianet.com']
 *           ]) - The hosts to use for Algolia Search API.
 *           If you provide them, you will less benefit from our HA implementation
 */
function AlgoliaSearchCore(applicationID, apiKey, opts) {
  var debug = __webpack_require__(51)('algoliasearch');

  var clone = __webpack_require__(42);
  var isArray = __webpack_require__(71);
  var map = __webpack_require__(54);

  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';

  if (opts._allowEmptyCredentials !== true && !applicationID) {
    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);
  }

  if (opts._allowEmptyCredentials !== true && !apiKey) {
    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);
  }

  this.applicationID = applicationID;
  this.apiKey = apiKey;

  this.hosts = {
    read: [],
    write: []
  };

  opts = opts || {};

  this._timeouts = opts.timeouts || {
    connect: 1 * 1000, // 500ms connect is GPRS latency
    read: 2 * 1000,
    write: 30 * 1000
  };

  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before
  if (opts.timeout) {
    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;
  }

  var protocol = opts.protocol || 'https:';
  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`
  // we also accept `http` and `https`. It's a common error.
  if (!/:$/.test(protocol)) {
    protocol = protocol + ':';
  }

  if (protocol !== 'http:' && protocol !== 'https:') {
    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');
  }

  this._checkAppIdData();

  if (!opts.hosts) {
    var defaultHosts = map(this._shuffleResult, function(hostNumber) {
      return applicationID + '-' + hostNumber + '.algolianet.com';
    });

    // no hosts given, compute defaults
    var mainSuffix = (opts.dsn === false ? '' : '-dsn') + '.algolia.net';
    this.hosts.read = [this.applicationID + mainSuffix].concat(defaultHosts);
    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);
  } else if (isArray(opts.hosts)) {
    // when passing custom hosts, we need to have a different host index if the number
    // of write/read hosts are different.
    this.hosts.read = clone(opts.hosts);
    this.hosts.write = clone(opts.hosts);
  } else {
    this.hosts.read = clone(opts.hosts.read);
    this.hosts.write = clone(opts.hosts.write);
  }

  // add protocol and lowercase hosts
  this.hosts.read = map(this.hosts.read, prepareHost(protocol));
  this.hosts.write = map(this.hosts.write, prepareHost(protocol));

  this.extraHeaders = {};

  // In some situations you might want to warm the cache
  this.cache = opts._cache || {};

  this._ua = opts._ua;
  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;
  this._useRequestCache = this._useCache && opts._useRequestCache;
  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;

  this._setTimeout = opts._setTimeout;

  debug('init done, %j', this);
}

/*
 * Get the index object initialized
 *
 * @param indexName the name of index
 * @param callback the result callback with one argument (the Index instance)
 */
AlgoliaSearchCore.prototype.initIndex = function(indexName) {
  return new IndexCore(this, indexName);
};

/**
* Add an extra field to the HTTP request
*
* @param name the header field name
* @param value the header field value
*/
AlgoliaSearchCore.prototype.setExtraHeader = function(name, value) {
  this.extraHeaders[name.toLowerCase()] = value;
};

/**
* Get the value of an extra HTTP header
*
* @param name the header field name
*/
AlgoliaSearchCore.prototype.getExtraHeader = function(name) {
  return this.extraHeaders[name.toLowerCase()];
};

/**
* Remove an extra field from the HTTP request
*
* @param name the header field name
*/
AlgoliaSearchCore.prototype.unsetExtraHeader = function(name) {
  delete this.extraHeaders[name.toLowerCase()];
};

/**
* Augment sent x-algolia-agent with more data, each agent part
* is automatically separated from the others by a semicolon;
*
* @param algoliaAgent the agent to add
*/
AlgoliaSearchCore.prototype.addAlgoliaAgent = function(algoliaAgent) {
  if (this._ua.indexOf(';' + algoliaAgent) === -1) {
    this._ua += ';' + algoliaAgent;
  }
};

/*
 * Wrapper that try all hosts to maximize the quality of service
 */
AlgoliaSearchCore.prototype._jsonRequest = function(initialOpts) {
  this._checkAppIdData();

  var requestDebug = __webpack_require__(51)('algoliasearch:' + initialOpts.url);


  var body;
  var cacheID;
  var additionalUA = initialOpts.additionalUA || '';
  var cache = initialOpts.cache;
  var client = this;
  var tries = 0;
  var usingFallback = false;
  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;
  var headers;

  if (
    this.apiKey.length > MAX_API_KEY_LENGTH &&
    initialOpts.body !== undefined &&
    (initialOpts.body.params !== undefined || // index.search()
    initialOpts.body.requests !== undefined) // client.search()
  ) {
    initialOpts.body.apiKey = this.apiKey;
    headers = this._computeRequestHeaders({
      additionalUA: additionalUA,
      withApiKey: false,
      headers: initialOpts.headers
    });
  } else {
    headers = this._computeRequestHeaders({
      additionalUA: additionalUA,
      headers: initialOpts.headers
    });
  }

  if (initialOpts.body !== undefined) {
    body = safeJSONStringify(initialOpts.body);
  }

  requestDebug('request start');
  var debugData = [];


  function doRequest(requester, reqOpts) {
    client._checkAppIdData();

    var startTime = new Date();

    if (client._useCache && !client._useRequestCache) {
      cacheID = initialOpts.url;
    }

    // as we sometime use POST requests to pass parameters (like query='aa'),
    // the cacheID must also include the body to be different between calls
    if (client._useCache && !client._useRequestCache && body) {
      cacheID += '_body_' + reqOpts.body;
    }

    // handle cache existence
    if (isCacheValidWithCurrentID(!client._useRequestCache, cache, cacheID)) {
      requestDebug('serving response from cache');

      var responseText = cache[cacheID];

      // Cache response must match the type of the original one
      return client._promise.resolve({
        body: JSON.parse(responseText),
        responseText: responseText
      });
    }

    // if we reached max tries
    if (tries >= client.hosts[initialOpts.hostType].length) {
      if (!hasFallback || usingFallback) {
        requestDebug('could not get any response');
        // then stop
        return client._promise.reject(new errors.AlgoliaSearchError(
          'Cannot connect to the AlgoliaSearch API.' +
          ' Send an email to support@algolia.com to report and resolve the issue.' +
          ' Application id was: ' + client.applicationID, {debugData: debugData}
        ));
      }

      requestDebug('switching to fallback');

      // let's try the fallback starting from here
      tries = 0;

      // method, url and body are fallback dependent
      reqOpts.method = initialOpts.fallback.method;
      reqOpts.url = initialOpts.fallback.url;
      reqOpts.jsonBody = initialOpts.fallback.body;
      if (reqOpts.jsonBody) {
        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);
      }
      // re-compute headers, they could be omitting the API KEY
      headers = client._computeRequestHeaders({
        additionalUA: additionalUA,
        headers: initialOpts.headers
      });

      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
      client._setHostIndexByType(0, initialOpts.hostType);
      usingFallback = true; // the current request is now using fallback
      return doRequest(client._request.fallback, reqOpts);
    }

    var currentHost = client._getHostByType(initialOpts.hostType);

    var url = currentHost + reqOpts.url;
    var options = {
      body: reqOpts.body,
      jsonBody: reqOpts.jsonBody,
      method: reqOpts.method,
      headers: headers,
      timeouts: reqOpts.timeouts,
      debug: requestDebug,
      forceAuthHeaders: reqOpts.forceAuthHeaders
    };

    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d',
      options.method, url, options.headers, options.timeouts);

    if (requester === client._request.fallback) {
      requestDebug('using fallback');
    }

    // `requester` is any of this._request or this._request.fallback
    // thus it needs to be called using the client as context
    return requester.call(client, url, options).then(success, tryFallback);

    function success(httpResponse) {
      // compute the status of the response,
      //
      // When in browser mode, using XDR or JSONP, we have no statusCode available
      // So we rely on our API response `status` property.
      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)
      // So we check if there's a `message` along `status` and it means it's an error
      //
      // That's the only case where we have a response.status that's not the http statusCode
      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||

        // this is important to check the request statusCode AFTER the body eventual
        // statusCode because some implementations (jQuery XDomainRequest transport) may
        // send statusCode 200 while we had an error
        httpResponse.statusCode ||

        // When in browser mode, using XDR or JSONP
        // we default to success when no error (no response.status && response.message)
        // If there was a JSON.parse() error then body is null and it fails
        httpResponse && httpResponse.body && 200;

      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j',
        httpResponse.statusCode, status, httpResponse.headers);

      var httpResponseOk = Math.floor(status / 100) === 2;

      var endTime = new Date();
      debugData.push({
        currentHost: currentHost,
        headers: removeCredentials(headers),
        content: body || null,
        contentLength: body !== undefined ? body.length : null,
        method: reqOpts.method,
        timeouts: reqOpts.timeouts,
        url: reqOpts.url,
        startTime: startTime,
        endTime: endTime,
        duration: endTime - startTime,
        statusCode: status
      });

      if (httpResponseOk) {
        if (client._useCache && !client._useRequestCache && cache) {
          cache[cacheID] = httpResponse.responseText;
        }

        return {
          responseText: httpResponse.responseText,
          body: httpResponse.body
        };
      }

      var shouldRetry = Math.floor(status / 100) !== 4;

      if (shouldRetry) {
        tries += 1;
        return retryRequest();
      }

      requestDebug('unrecoverable error');

      // no success and no retry => fail
      var unrecoverableError = new errors.AlgoliaSearchError(
        httpResponse.body && httpResponse.body.message, {debugData: debugData, statusCode: status}
      );

      return client._promise.reject(unrecoverableError);
    }

    function tryFallback(err) {
      // error cases:
      //  While not in fallback mode:
      //    - CORS not supported
      //    - network error
      //  While in fallback mode:
      //    - timeout
      //    - network error
      //    - badly formatted JSONP (script loaded, did not call our callback)
      //  In both cases:
      //    - uncaught exception occurs (TypeError)
      requestDebug('error: %s, stack: %s', err.message, err.stack);

      var endTime = new Date();
      debugData.push({
        currentHost: currentHost,
        headers: removeCredentials(headers),
        content: body || null,
        contentLength: body !== undefined ? body.length : null,
        method: reqOpts.method,
        timeouts: reqOpts.timeouts,
        url: reqOpts.url,
        startTime: startTime,
        endTime: endTime,
        duration: endTime - startTime
      });

      if (!(err instanceof errors.AlgoliaSearchError)) {
        err = new errors.Unknown(err && err.message, err);
      }

      tries += 1;

      // stop the request implementation when:
      if (
        // we did not generate this error,
        // it comes from a throw in some other piece of code
        err instanceof errors.Unknown ||

        // server sent unparsable JSON
        err instanceof errors.UnparsableJSON ||

        // max tries and already using fallback or no fallback
        tries >= client.hosts[initialOpts.hostType].length &&
        (usingFallback || !hasFallback)) {
        // stop request implementation for this command
        err.debugData = debugData;
        return client._promise.reject(err);
      }

      // When a timeout occured, retry by raising timeout
      if (err instanceof errors.RequestTimeout) {
        return retryRequestWithHigherTimeout();
      }

      return retryRequest();
    }

    function retryRequest() {
      requestDebug('retrying request');
      client._incrementHostIndex(initialOpts.hostType);
      return doRequest(requester, reqOpts);
    }

    function retryRequestWithHigherTimeout() {
      requestDebug('retrying request with higher timeout');
      client._incrementHostIndex(initialOpts.hostType);
      client._incrementTimeoutMultipler();
      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
      return doRequest(requester, reqOpts);
    }
  }

  function isCacheValidWithCurrentID(
    useRequestCache,
    currentCache,
    currentCacheID
  ) {
    return (
      client._useCache &&
      useRequestCache &&
      currentCache &&
      currentCache[currentCacheID] !== undefined
    );
  }


  function interopCallbackReturn(request, callback) {
    if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {
      request.catch(function() {
        // Release the cache on error
        delete cache[cacheID];
      });
    }

    if (typeof initialOpts.callback === 'function') {
      // either we have a callback
      request.then(function okCb(content) {
        exitPromise(function() {
          initialOpts.callback(null, callback(content));
        }, client._setTimeout || setTimeout);
      }, function nookCb(err) {
        exitPromise(function() {
          initialOpts.callback(err);
        }, client._setTimeout || setTimeout);
      });
    } else {
      // either we are using promises
      return request.then(callback);
    }
  }

  if (client._useCache && client._useRequestCache) {
    cacheID = initialOpts.url;
  }

  // as we sometime use POST requests to pass parameters (like query='aa'),
  // the cacheID must also include the body to be different between calls
  if (client._useCache && client._useRequestCache && body) {
    cacheID += '_body_' + body;
  }

  if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {
    requestDebug('serving request from cache');

    var maybePromiseForCache = cache[cacheID];

    // In case the cache is warmup with value that is not a promise
    var promiseForCache = typeof maybePromiseForCache.then !== 'function'
      ? client._promise.resolve({responseText: maybePromiseForCache})
      : maybePromiseForCache;

    return interopCallbackReturn(promiseForCache, function(content) {
      // In case of the cache request, return the original value
      return JSON.parse(content.responseText);
    });
  }

  var request = doRequest(
    client._request, {
      url: initialOpts.url,
      method: initialOpts.method,
      body: body,
      jsonBody: initialOpts.body,
      timeouts: client._getTimeoutsForRequest(initialOpts.hostType),
      forceAuthHeaders: initialOpts.forceAuthHeaders
    }
  );

  if (client._useCache && client._useRequestCache && cache) {
    cache[cacheID] = request;
  }

  return interopCallbackReturn(request, function(content) {
    // In case of the first request, return the JSON value
    return content.body;
  });
};

/*
* Transform search param object in query string
* @param {object} args arguments to add to the current query string
* @param {string} params current query string
* @return {string} the final query string
*/
AlgoliaSearchCore.prototype._getSearchParams = function(args, params) {
  if (args === undefined || args === null) {
    return params;
  }
  for (var key in args) {
    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {
      params += params === '' ? '' : '&';
      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);
    }
  }
  return params;
};

/**
 * Compute the headers for a request
 *
 * @param [string] options.additionalUA semi-colon separated string with other user agents to add
 * @param [boolean=true] options.withApiKey Send the api key as a header
 * @param [Object] options.headers Extra headers to send
 */
AlgoliaSearchCore.prototype._computeRequestHeaders = function(options) {
  var forEach = __webpack_require__(47);

  var ua = options.additionalUA ?
    this._ua + ';' + options.additionalUA :
    this._ua;

  var requestHeaders = {
    'x-algolia-agent': ua,
    'x-algolia-application-id': this.applicationID
  };

  // browser will inline headers in the url, node.js will use http headers
  // but in some situations, the API KEY will be too long (big secured API keys)
  // so if the request is a POST and the KEY is very long, we will be asked to not put
  // it into headers but in the JSON body
  if (options.withApiKey !== false) {
    requestHeaders['x-algolia-api-key'] = this.apiKey;
  }

  if (this.userToken) {
    requestHeaders['x-algolia-usertoken'] = this.userToken;
  }

  if (this.securityTags) {
    requestHeaders['x-algolia-tagfilters'] = this.securityTags;
  }

  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {
    requestHeaders[key] = value;
  });

  if (options.headers) {
    forEach(options.headers, function addToRequestHeaders(value, key) {
      requestHeaders[key] = value;
    });
  }

  return requestHeaders;
};

/**
 * Search through multiple indices at the same time
 * @param  {Object[]}   queries  An array of queries you want to run.
 * @param {string} queries[].indexName The index name you want to target
 * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`
 * @param {Object} queries[].params Any search param like hitsPerPage, ..
 * @param  {Function} callback Callback to be called
 * @return {Promise|undefined} Returns a promise if no callback given
 */
AlgoliaSearchCore.prototype.search = function(queries, opts, callback) {
  var isArray = __webpack_require__(71);
  var map = __webpack_require__(54);

  var usage = 'Usage: client.search(arrayOfQueries[, callback])';

  if (!isArray(queries)) {
    throw new Error(usage);
  }

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  } else if (opts === undefined) {
    opts = {};
  }

  var client = this;

  var postObj = {
    requests: map(queries, function prepareRequest(query) {
      var params = '';

      // allow query.query
      // so we are mimicing the index.search(query, params) method
      // {indexName:, query:, params:}
      if (query.query !== undefined) {
        params += 'query=' + encodeURIComponent(query.query);
      }

      return {
        indexName: query.indexName,
        params: client._getSearchParams(query.params, params)
      };
    })
  };

  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {
    return requestId + '=' +
      encodeURIComponent(
        '/1/indexes/' + encodeURIComponent(request.indexName) + '?' +
        request.params
      );
  }).join('&');

  var url = '/1/indexes/*/queries';

  if (opts.strategy !== undefined) {
    url += '?strategy=' + opts.strategy;
  }

  return this._jsonRequest({
    cache: this.cache,
    method: 'POST',
    url: url,
    body: postObj,
    hostType: 'read',
    fallback: {
      method: 'GET',
      url: '/1/indexes/*',
      body: {
        params: JSONPParams
      }
    },
    callback: callback
  });
};

/**
* Search for facet values
* https://www.algolia.com/doc/rest-api/search#search-for-facet-values
* This is the top-level API for SFFV.
*
* @param {object[]} queries An array of queries to run.
* @param {string} queries[].indexName Index name, name of the index to search.
* @param {object} queries[].params Query parameters.
* @param {string} queries[].params.facetName Facet name, name of the attribute to search for values in.
* Must be declared as a facet
* @param {string} queries[].params.facetQuery Query for the facet search
* @param {string} [queries[].params.*] Any search parameter of Algolia,
* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters
* Pagination is not supported. The page and hitsPerPage parameters will be ignored.
*/
AlgoliaSearchCore.prototype.searchForFacetValues = function(queries) {
  var isArray = __webpack_require__(71);
  var map = __webpack_require__(54);

  var usage = 'Usage: client.searchForFacetValues([{indexName, params: {facetName, facetQuery, ...params}}, ...queries])'; // eslint-disable-line max-len

  if (!isArray(queries)) {
    throw new Error(usage);
  }

  var client = this;

  return client._promise.all(map(queries, function performQuery(query) {
    if (
      !query ||
      query.indexName === undefined ||
      query.params.facetName === undefined ||
      query.params.facetQuery === undefined
    ) {
      throw new Error(usage);
    }

    var clone = __webpack_require__(42);
    var omit = __webpack_require__(101);

    var indexName = query.indexName;
    var params = query.params;

    var facetName = params.facetName;
    var filteredParams = omit(clone(params), function(keyName) {
      return keyName === 'facetName';
    });
    var searchParameters = client._getSearchParams(filteredParams, '');

    return client._jsonRequest({
      cache: client.cache,
      method: 'POST',
      url:
        '/1/indexes/' +
        encodeURIComponent(indexName) +
        '/facets/' +
        encodeURIComponent(facetName) +
        '/query',
      hostType: 'read',
      body: {params: searchParameters}
    });
  }));
};

/**
 * Set the extra security tagFilters header
 * @param {string|array} tags The list of tags defining the current security filters
 */
AlgoliaSearchCore.prototype.setSecurityTags = function(tags) {
  if (Object.prototype.toString.call(tags) === '[object Array]') {
    var strTags = [];
    for (var i = 0; i < tags.length; ++i) {
      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {
        var oredTags = [];
        for (var j = 0; j < tags[i].length; ++j) {
          oredTags.push(tags[i][j]);
        }
        strTags.push('(' + oredTags.join(',') + ')');
      } else {
        strTags.push(tags[i]);
      }
    }
    tags = strTags.join(',');
  }

  this.securityTags = tags;
};

/**
 * Set the extra user token header
 * @param {string} userToken The token identifying a uniq user (used to apply rate limits)
 */
AlgoliaSearchCore.prototype.setUserToken = function(userToken) {
  this.userToken = userToken;
};

/**
 * Clear all queries in client's cache
 * @return undefined
 */
AlgoliaSearchCore.prototype.clearCache = function() {
  this.cache = {};
};

/**
* Set the number of milliseconds a request can take before automatically being terminated.
* @deprecated
* @param {Number} milliseconds
*/
AlgoliaSearchCore.prototype.setRequestTimeout = function(milliseconds) {
  if (milliseconds) {
    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;
  }
};

/**
* Set the three different (connect, read, write) timeouts to be used when requesting
* @param {Object} timeouts
*/
AlgoliaSearchCore.prototype.setTimeouts = function(timeouts) {
  this._timeouts = timeouts;
};

/**
* Get the three different (connect, read, write) timeouts to be used when requesting
* @param {Object} timeouts
*/
AlgoliaSearchCore.prototype.getTimeouts = function() {
  return this._timeouts;
};

AlgoliaSearchCore.prototype._getAppIdData = function() {
  var data = store.get(this.applicationID);
  if (data !== null) this._cacheAppIdData(data);
  return data;
};

AlgoliaSearchCore.prototype._setAppIdData = function(data) {
  data.lastChange = (new Date()).getTime();
  this._cacheAppIdData(data);
  return store.set(this.applicationID, data);
};

AlgoliaSearchCore.prototype._checkAppIdData = function() {
  var data = this._getAppIdData();
  var now = (new Date()).getTime();
  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {
    return this._resetInitialAppIdData(data);
  }

  return data;
};

AlgoliaSearchCore.prototype._resetInitialAppIdData = function(data) {
  var newData = data || {};
  newData.hostIndexes = {read: 0, write: 0};
  newData.timeoutMultiplier = 1;
  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);
  return this._setAppIdData(newData);
};

AlgoliaSearchCore.prototype._cacheAppIdData = function(data) {
  this._hostIndexes = data.hostIndexes;
  this._timeoutMultiplier = data.timeoutMultiplier;
  this._shuffleResult = data.shuffleResult;
};

AlgoliaSearchCore.prototype._partialAppIdDataUpdate = function(newData) {
  var foreach = __webpack_require__(47);
  var currentData = this._getAppIdData();
  foreach(newData, function(value, key) {
    currentData[key] = value;
  });

  return this._setAppIdData(currentData);
};

AlgoliaSearchCore.prototype._getHostByType = function(hostType) {
  return this.hosts[hostType][this._getHostIndexByType(hostType)];
};

AlgoliaSearchCore.prototype._getTimeoutMultiplier = function() {
  return this._timeoutMultiplier;
};

AlgoliaSearchCore.prototype._getHostIndexByType = function(hostType) {
  return this._hostIndexes[hostType];
};

AlgoliaSearchCore.prototype._setHostIndexByType = function(hostIndex, hostType) {
  var clone = __webpack_require__(42);
  var newHostIndexes = clone(this._hostIndexes);
  newHostIndexes[hostType] = hostIndex;
  this._partialAppIdDataUpdate({hostIndexes: newHostIndexes});
  return hostIndex;
};

AlgoliaSearchCore.prototype._incrementHostIndex = function(hostType) {
  return this._setHostIndexByType(
    (this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType
  );
};

AlgoliaSearchCore.prototype._incrementTimeoutMultipler = function() {
  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);
  return this._partialAppIdDataUpdate({timeoutMultiplier: timeoutMultiplier});
};

AlgoliaSearchCore.prototype._getTimeoutsForRequest = function(hostType) {
  return {
    connect: this._timeouts.connect * this._timeoutMultiplier,
    complete: this._timeouts[hostType] * this._timeoutMultiplier
  };
};

function prepareHost(protocol) {
  return function prepare(host) {
    return protocol + '//' + host.toLowerCase();
  };
}

// Prototype.js < 1.7, a widely used library, defines a weird
// Array.prototype.toJSON function that will fail to stringify our content
// appropriately
// refs:
//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q
//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c
//   - http://stackoverflow.com/a/3148441/147079
function safeJSONStringify(obj) {
  /* eslint no-extend-native:0 */

  if (Array.prototype.toJSON === undefined) {
    return JSON.stringify(obj);
  }

  var toJSON = Array.prototype.toJSON;
  delete Array.prototype.toJSON;
  var out = JSON.stringify(obj);
  Array.prototype.toJSON = toJSON;

  return out;
}

function shuffle(array) {
  var currentIndex = array.length;
  var temporaryValue;
  var randomIndex;

  // While there remain elements to shuffle...
  while (currentIndex !== 0) {
    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}

function removeCredentials(headers) {
  var newHeaders = {};

  for (var headerName in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {
      var value;

      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {
        value = '**hidden for security purposes**';
      } else {
        value = headers[headerName];
      }

      newHeaders[headerName] = value;
    }
  }

  return newHeaders;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(137)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var buildSearchMethod = __webpack_require__(100);
var deprecate = __webpack_require__(164);
var deprecatedMessage = __webpack_require__(165);

module.exports = IndexCore;

/*
* Index class constructor.
* You should not use this method directly but use initIndex() function
*/
function IndexCore(algoliasearch, indexName) {
  this.indexName = indexName;
  this.as = algoliasearch;
  this.typeAheadArgs = null;
  this.typeAheadValueOption = null;

  // make sure every index instance has it's own cache
  this.cache = {};
}

/*
* Clear all queries in cache
*/
IndexCore.prototype.clearCache = function() {
  this.cache = {};
};

/*
* Search inside the index using XMLHttpRequest request (Using a POST query to
* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
*
* @param {string} [query] the full text query
* @param {object} [args] (optional) if set, contains an object with query parameters:
* - page: (integer) Pagination parameter used to select the page to retrieve.
*                   Page is zero-based and defaults to 0. Thus,
*                   to retrieve the 10th page you need to set page=9
* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.
* - attributesToRetrieve: a string that contains the list of object attributes
* you want to retrieve (let you minimize the answer size).
*   Attributes are separated with a comma (for example "name,address").
*   You can also use an array (for example ["name","address"]).
*   By default, all attributes are retrieved. You can also use '*' to retrieve all
*   values when an attributesToRetrieve setting is specified for your index.
* - attributesToHighlight: a string that contains the list of attributes you
*   want to highlight according to the query.
*   Attributes are separated by a comma. You can also use an array (for example ["name","address"]).
*   If an attribute has no match for the query, the raw value is returned.
*   By default all indexed text attributes are highlighted.
*   You can use `*` if you want to highlight all textual attributes.
*   Numerical attributes are not highlighted.
*   A matchLevel is returned for each highlighted attribute and can contain:
*      - full: if all the query terms were found in the attribute,
*      - partial: if only some of the query terms were found,
*      - none: if none of the query terms were found.
* - attributesToSnippet: a string that contains the list of attributes to snippet alongside
* the number of words to return (syntax is `attributeName:nbWords`).
*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).
*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).
*    By default no snippet is computed.
* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.
* Defaults to 3.
* - minWordSizefor2Typos: the minimum number of characters in a query word
* to accept two typos in this word. Defaults to 7.
* - getRankingInfo: if set to 1, the result hits will contain ranking
* information in _rankingInfo attribute.
* - aroundLatLng: search for entries around a given
* latitude/longitude (specified as two floats separated by a comma).
*   For example aroundLatLng=47.316669,5.016670).
*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)
*   and the precision for ranking with aroundPrecision
*   (for example if you set aroundPrecision=100, two objects that are distant of
*   less than 100m will be considered as identical for "geo" ranking parameter).
*   At indexing, you should specify geoloc of an object with the _geoloc attribute
*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
* - insideBoundingBox: search entries inside a given area defined by the two extreme points
* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).
*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).
*   At indexing, you should specify geoloc of an object with the _geoloc attribute
*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
* - numericFilters: a string that contains the list of numeric filters you want to
* apply separated by a comma.
*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.
*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.
*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.
*   You can also use an array (for example numericFilters: ["price>100","price<1000"]).
* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.
*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).
*   You can also use an array, for example tagFilters: ["tag1",["tag2","tag3"]]
*   means tag1 AND (tag2 OR tag3).
*   At indexing, tags should be added in the _tags** attribute
*   of objects (for example {"_tags":["tag1","tag2"]}).
* - facetFilters: filter the query by a list of facets.
*   Facets are separated by commas and each facet is encoded as `attributeName:value`.
*   For example: `facetFilters=category:Book,author:John%20Doe`.
*   You can also use an array (for example `["category:Book","author:John%20Doe"]`).
* - facets: List of object attributes that you want to use for faceting.
*   Comma separated list: `"category,author"` or array `['category','author']`
*   Only attributes that have been added in **attributesForFaceting** index setting
*   can be used in this parameter.
*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.
* - queryType: select how the query words are interpreted, it can be one of the following value:
*    - prefixAll: all query words are interpreted as prefixes,
*    - prefixLast: only the last word is interpreted as a prefix (default behavior),
*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
* - optionalWords: a string that contains the list of words that should
* be considered as optional when found in the query.
*   Comma separated and array are accepted.
* - distinct: If set to 1, enable the distinct feature (disabled by default)
* if the attributeForDistinct index setting is set.
*   This feature is similar to the SQL "distinct" keyword: when enabled
*   in a query with the distinct=1 parameter,
*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.
*   For example, if the chosen attribute is show_name and several hits have
*   the same value for show_name, then only the best
*   one is kept and others are removed.
* - restrictSearchableAttributes: List of attributes you want to use for
* textual search (must be a subset of the attributesToIndex index setting)
* either comma separated or as an array
* @param {function} [callback] the result callback called with two arguments:
*  error: null or Error('message'). If false, the content contains the error.
*  content: the server answer that contains the list of results.
*/
IndexCore.prototype.search = buildSearchMethod('query');

/*
* -- BETA --
* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to
* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
*
* @param {string} [query] the similar query
* @param {object} [args] (optional) if set, contains an object with query parameters.
*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters
*   are the two most useful to restrict the similar results and get more relevant content
*/
IndexCore.prototype.similarSearch = buildSearchMethod('similarQuery');

/*
* Browse index content. The response content will have a `cursor` property that you can use
* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.
*
* @param {string} query - The full text query
* @param {Object} [queryParameters] - Any search query parameter
* @param {Function} [callback] - The result callback called with two arguments
*   error: null or Error('message')
*   content: the server answer with the browse result
* @return {Promise|undefined} Returns a promise if no callback given
* @example
* index.browse('cool songs', {
*   tagFilters: 'public,comments',
*   hitsPerPage: 500
* }, callback);
* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
*/
IndexCore.prototype.browse = function(query, queryParameters, callback) {
  var merge = __webpack_require__(167);

  var indexObj = this;

  var page;
  var hitsPerPage;

  // we check variadic calls that are not the one defined
  // .browse()/.browse(fn)
  // => page = 0
  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {
    page = 0;
    callback = arguments[0];
    query = undefined;
  } else if (typeof arguments[0] === 'number') {
    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)
    page = arguments[0];
    if (typeof arguments[1] === 'number') {
      hitsPerPage = arguments[1];
    } else if (typeof arguments[1] === 'function') {
      callback = arguments[1];
      hitsPerPage = undefined;
    }
    query = undefined;
    queryParameters = undefined;
  } else if (typeof arguments[0] === 'object') {
    // .browse(queryParameters)/.browse(queryParameters, cb)
    if (typeof arguments[1] === 'function') {
      callback = arguments[1];
    }
    queryParameters = arguments[0];
    query = undefined;
  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {
    // .browse(query, cb)
    callback = arguments[1];
    queryParameters = undefined;
  }

  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)

  // get search query parameters combining various possible calls
  // to .browse();
  queryParameters = merge({}, queryParameters || {}, {
    page: page,
    hitsPerPage: hitsPerPage,
    query: query
  });

  var params = this.as._getSearchParams(queryParameters, '');

  return this.as._jsonRequest({
    method: 'POST',
    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',
    body: {params: params},
    hostType: 'read',
    callback: callback
  });
};

/*
* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.
*
* @param {string} query - The full text query
* @param {Object} [queryParameters] - Any search query parameter
* @param {Function} [callback] - The result callback called with two arguments
*   error: null or Error('message')
*   content: the server answer with the browse result
* @return {Promise|undefined} Returns a promise if no callback given
* @example
* index.browseFrom('14lkfsakl32', callback);
* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
*/
IndexCore.prototype.browseFrom = function(cursor, callback) {
  return this.as._jsonRequest({
    method: 'POST',
    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',
    body: {cursor: cursor},
    hostType: 'read',
    callback: callback
  });
};

/*
* Search for facet values
* https://www.algolia.com/doc/rest-api/search#search-for-facet-values
*
* @param {string} params.facetName Facet name, name of the attribute to search for values in.
* Must be declared as a facet
* @param {string} params.facetQuery Query for the facet search
* @param {string} [params.*] Any search parameter of Algolia,
* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters
* Pagination is not supported. The page and hitsPerPage parameters will be ignored.
* @param callback (optional)
*/
IndexCore.prototype.searchForFacetValues = function(params, callback) {
  var clone = __webpack_require__(42);
  var omit = __webpack_require__(101);
  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';

  if (params.facetName === undefined || params.facetQuery === undefined) {
    throw new Error(usage);
  }

  var facetName = params.facetName;
  var filteredParams = omit(clone(params), function(keyName) {
    return keyName === 'facetName';
  });
  var searchParameters = this.as._getSearchParams(filteredParams, '');

  return this.as._jsonRequest({
    method: 'POST',
    url: '/1/indexes/' +
      encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',
    hostType: 'read',
    body: {params: searchParameters},
    callback: callback
  });
};

IndexCore.prototype.searchFacet = deprecate(function(params, callback) {
  return this.searchForFacetValues(params, callback);
}, deprecatedMessage(
  'index.searchFacet(params[, callback])',
  'index.searchForFacetValues(params[, callback])'
));

IndexCore.prototype._search = function(params, url, callback, additionalUA) {
  return this.as._jsonRequest({
    cache: this.cache,
    method: 'POST',
    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',
    body: {params: params},
    hostType: 'read',
    fallback: {
      method: 'GET',
      url: '/1/indexes/' + encodeURIComponent(this.indexName),
      body: {params: params}
    },
    callback: callback,
    additionalUA: additionalUA
  });
};

/*
* Get an object from this index
*
* @param objectID the unique identifier of the object to retrieve
* @param attrs (optional) if set, contains the array of attribute names to retrieve
* @param callback (optional) the result callback called with two arguments
*  error: null or Error('message')
*  content: the object to retrieve or the error message if a failure occured
*/
IndexCore.prototype.getObject = function(objectID, attrs, callback) {
  var indexObj = this;

  if (arguments.length === 1 || typeof attrs === 'function') {
    callback = attrs;
    attrs = undefined;
  }

  var params = '';
  if (attrs !== undefined) {
    params = '?attributes=';
    for (var i = 0; i < attrs.length; ++i) {
      if (i !== 0) {
        params += ',';
      }
      params += attrs[i];
    }
  }

  return this.as._jsonRequest({
    method: 'GET',
    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,
    hostType: 'read',
    callback: callback
  });
};

/*
* Get several objects from this index
*
* @param objectIDs the array of unique identifier of objects to retrieve
*/
IndexCore.prototype.getObjects = function(objectIDs, attributesToRetrieve, callback) {
  var isArray = __webpack_require__(71);
  var map = __webpack_require__(54);

  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';

  if (!isArray(objectIDs)) {
    throw new Error(usage);
  }

  var indexObj = this;

  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {
    callback = attributesToRetrieve;
    attributesToRetrieve = undefined;
  }

  var body = {
    requests: map(objectIDs, function prepareRequest(objectID) {
      var request = {
        indexName: indexObj.indexName,
        objectID: objectID
      };

      if (attributesToRetrieve) {
        request.attributesToRetrieve = attributesToRetrieve.join(',');
      }

      return request;
    })
  };

  return this.as._jsonRequest({
    method: 'POST',
    url: '/1/indexes/*/objects',
    hostType: 'read',
    body: body,
    callback: callback
  });
};

IndexCore.prototype.as = null;
IndexCore.prototype.indexName = null;
IndexCore.prototype.typeAheadArgs = null;
IndexCore.prototype.typeAheadValueOption = null;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var AlgoliaSearchCore = __webpack_require__(158);
var createAlgoliasearch = __webpack_require__(161);

module.exports = createAlgoliasearch(AlgoliaSearchCore, '(lite) ');


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(404);
var Promise = global.Promise || __webpack_require__(403).Promise;

// This is the standalone browser build entry point
// Browser implementation of the Algolia Search JavaScript client,
// using XMLHttpRequest, XDomainRequest and JSONP as fallback
module.exports = function createAlgoliasearch(AlgoliaSearch, uaSuffix) {
  var inherits = __webpack_require__(136);
  var errors = __webpack_require__(53);
  var inlineHeaders = __webpack_require__(162);
  var jsonpRequest = __webpack_require__(163);
  var places = __webpack_require__(168);
  uaSuffix = uaSuffix || '';

  if (undefined === 'debug') {
    __webpack_require__(51).enable('algoliasearch*');
  }

  function algoliasearch(applicationID, apiKey, opts) {
    var cloneDeep = __webpack_require__(42);

    opts = cloneDeep(opts || {});

    opts._ua = opts._ua || algoliasearch.ua;

    return new AlgoliaSearchBrowser(applicationID, apiKey, opts);
  }

  algoliasearch.version = __webpack_require__(170);
  algoliasearch.ua = 'Algolia for vanilla JavaScript ' + uaSuffix + algoliasearch.version;
  algoliasearch.initPlaces = places(algoliasearch);

  // we expose into window no matter how we are used, this will allow
  // us to easily debug any website running algolia
  global.__algolia = {
    debug: __webpack_require__(51),
    algoliasearch: algoliasearch
  };

  var support = {
    hasXMLHttpRequest: 'XMLHttpRequest' in global,
    hasXDomainRequest: 'XDomainRequest' in global
  };

  if (support.hasXMLHttpRequest) {
    support.cors = 'withCredentials' in new XMLHttpRequest();
  }

  function AlgoliaSearchBrowser() {
    // call AlgoliaSearch constructor
    AlgoliaSearch.apply(this, arguments);
  }

  inherits(AlgoliaSearchBrowser, AlgoliaSearch);

  AlgoliaSearchBrowser.prototype._request = function request(url, opts) {
    return new Promise(function wrapRequest(resolve, reject) {
      // no cors or XDomainRequest, no request
      if (!support.cors && !support.hasXDomainRequest) {
        // very old browser, not supported
        reject(new errors.Network('CORS not supported'));
        return;
      }

      url = inlineHeaders(url, opts.headers);

      var body = opts.body;
      var req = support.cors ? new XMLHttpRequest() : new XDomainRequest();
      var reqTimeout;
      var timedOut;
      var connected = false;

      reqTimeout = setTimeout(onTimeout, opts.timeouts.connect);
      // we set an empty onprogress listener
      // so that XDomainRequest on IE9 is not aborted
      // refs:
      //  - https://github.com/algolia/algoliasearch-client-js/issues/76
      //  - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
      req.onprogress = onProgress;
      if ('onreadystatechange' in req) req.onreadystatechange = onReadyStateChange;
      req.onload = onLoad;
      req.onerror = onError;

      // do not rely on default XHR async flag, as some analytics code like hotjar
      // breaks it and set it to false by default
      if (req instanceof XMLHttpRequest) {
        req.open(opts.method, url, true);

        // The Analytics API never accepts Auth headers as query string
        // this option exists specifically for them.
        if (opts.forceAuthHeaders) {
          req.setRequestHeader(
            'x-algolia-application-id',
            opts.headers['x-algolia-application-id']
          );
          req.setRequestHeader(
            'x-algolia-api-key',
            opts.headers['x-algolia-api-key']
          );
        }
      } else {
        req.open(opts.method, url);
      }

      // headers are meant to be sent after open
      if (support.cors) {
        if (body) {
          if (opts.method === 'POST') {
            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests
            req.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
          } else {
            req.setRequestHeader('content-type', 'application/json');
          }
        }
        req.setRequestHeader('accept', 'application/json');
      }

      if (body) {
        req.send(body);
      } else {
        req.send();
      }

      // event object not received in IE8, at least
      // but we do not use it, still important to note
      function onLoad(/* event */) {
        // When browser does not supports req.timeout, we can
        // have both a load and timeout event, since handled by a dumb setTimeout
        if (timedOut) {
          return;
        }

        clearTimeout(reqTimeout);

        var out;

        try {
          out = {
            body: JSON.parse(req.responseText),
            responseText: req.responseText,
            statusCode: req.status,
            // XDomainRequest does not have any response headers
            headers: req.getAllResponseHeaders && req.getAllResponseHeaders() || {}
          };
        } catch (e) {
          out = new errors.UnparsableJSON({
            more: req.responseText
          });
        }

        if (out instanceof errors.UnparsableJSON) {
          reject(out);
        } else {
          resolve(out);
        }
      }

      function onError(event) {
        if (timedOut) {
          return;
        }

        clearTimeout(reqTimeout);

        // error event is trigerred both with XDR/XHR on:
        //   - DNS error
        //   - unallowed cross domain request
        reject(
          new errors.Network({
            more: event
          })
        );
      }

      function onTimeout() {
        timedOut = true;
        req.abort();

        reject(new errors.RequestTimeout());
      }

      function onConnect() {
        connected = true;
        clearTimeout(reqTimeout);
        reqTimeout = setTimeout(onTimeout, opts.timeouts.complete);
      }

      function onProgress() {
        if (!connected) onConnect();
      }

      function onReadyStateChange() {
        if (!connected && req.readyState > 1) onConnect();
      }
    });
  };

  AlgoliaSearchBrowser.prototype._request.fallback = function requestFallback(url, opts) {
    url = inlineHeaders(url, opts.headers);

    return new Promise(function wrapJsonpRequest(resolve, reject) {
      jsonpRequest(url, opts, function jsonpRequestDone(err, content) {
        if (err) {
          reject(err);
          return;
        }

        resolve(content);
      });
    });
  };

  AlgoliaSearchBrowser.prototype._promise = {
    reject: function rejectPromise(val) {
      return Promise.reject(val);
    },
    resolve: function resolvePromise(val) {
      return Promise.resolve(val);
    },
    delay: function delayPromise(ms) {
      return new Promise(function resolveOnTimeout(resolve/* , reject*/) {
        setTimeout(resolve, ms);
      });
    },
    all: function all(promises) {
      return Promise.all(promises);
    }
  };

  return algoliasearch;
};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = inlineHeaders;

var encode = __webpack_require__(407);

function inlineHeaders(url, headers) {
  if (/\?/.test(url)) {
    url += '&';
  } else {
    url += '?';
  }

  return url + encode(headers);
}


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = jsonpRequest;

var errors = __webpack_require__(53);

var JSONPCounter = 0;

function jsonpRequest(url, opts, cb) {
  if (opts.method !== 'GET') {
    cb(new Error('Method ' + opts.method + ' ' + url + ' is not supported by JSONP.'));
    return;
  }

  opts.debug('JSONP: start');

  var cbCalled = false;
  var timedOut = false;

  JSONPCounter += 1;
  var head = document.getElementsByTagName('head')[0];
  var script = document.createElement('script');
  var cbName = 'algoliaJSONP_' + JSONPCounter;
  var done = false;

  window[cbName] = function(data) {
    removeGlobals();

    if (timedOut) {
      opts.debug('JSONP: Late answer, ignoring');
      return;
    }

    cbCalled = true;

    clean();

    cb(null, {
      body: data,
      responseText: JSON.stringify(data)/* ,
      // We do not send the statusCode, there's no statusCode in JSONP, it will be
      // computed using data.status && data.message like with XDR
      statusCode*/
    });
  };

  // add callback by hand
  url += '&callback=' + cbName;

  // add body params manually
  if (opts.jsonBody && opts.jsonBody.params) {
    url += '&' + opts.jsonBody.params;
  }

  var ontimeout = setTimeout(timeout, opts.timeouts.complete);

  // script onreadystatechange needed only for
  // <= IE8
  // https://github.com/angular/angular.js/issues/4523
  script.onreadystatechange = readystatechange;
  script.onload = success;
  script.onerror = error;

  script.async = true;
  script.defer = true;
  script.src = url;
  head.appendChild(script);

  function success() {
    opts.debug('JSONP: success');

    if (done || timedOut) {
      return;
    }

    done = true;

    // script loaded but did not call the fn => script loading error
    if (!cbCalled) {
      opts.debug('JSONP: Fail. Script loaded but did not call the callback');
      clean();
      cb(new errors.JSONPScriptFail());
    }
  }

  function readystatechange() {
    if (this.readyState === 'loaded' || this.readyState === 'complete') {
      success();
    }
  }

  function clean() {
    clearTimeout(ontimeout);
    script.onload = null;
    script.onreadystatechange = null;
    script.onerror = null;
    head.removeChild(script);
  }

  function removeGlobals() {
    try {
      delete window[cbName];
      delete window[cbName + '_loaded'];
    } catch (e) {
      window[cbName] = window[cbName + '_loaded'] = undefined;
    }
  }

  function timeout() {
    opts.debug('JSONP: Script timeout');
    timedOut = true;
    clean();
    cb(new errors.RequestTimeout());
  }

  function error() {
    opts.debug('JSONP: Script error');

    if (done || timedOut) {
      return;
    }

    clean();
    cb(new errors.JSONPScriptError());
  }
}


/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = function deprecate(fn, message) {
  var warned = false;

  function deprecated() {
    if (!warned) {
      /* eslint no-console:0 */
      console.warn(message);
      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};


/***/ }),
/* 165 */
/***/ (function(module, exports) {

module.exports = function deprecatedMessage(previousUsage, newUsage) {
  var githubAnchorLink = previousUsage.toLowerCase()
    .replace(/[\.\(\)]/g, '');

  return 'algoliasearch: `' + previousUsage + '` was replaced by `' + newUsage +
    '`. Please see https://github.com/algolia/algoliasearch-client-javascript/wiki/Deprecated#' + githubAnchorLink;
};


/***/ }),
/* 166 */
/***/ (function(module, exports) {

// Parse cloud does not supports setTimeout
// We do not store a setTimeout reference in the client everytime
// We only fallback to a fake setTimeout when not available
// setTimeout cannot be override globally sadly
module.exports = function exitPromise(fn, _setTimeout) {
  _setTimeout(fn, 0);
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var foreach = __webpack_require__(47);

module.exports = function merge(destination/* , sources */) {
  var sources = Array.prototype.slice.call(arguments);

  foreach(sources, function(source) {
    for (var keyName in source) {
      if (source.hasOwnProperty(keyName)) {
        if (typeof destination[keyName] === 'object' && typeof source[keyName] === 'object') {
          destination[keyName] = merge({}, destination[keyName], source[keyName]);
        } else if (source[keyName] !== undefined) {
          destination[keyName] = source[keyName];
        }
      }
    }
  });

  return destination;
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = createPlacesClient;

var buildSearchMethod = __webpack_require__(100);

function createPlacesClient(algoliasearch) {
  return function places(appID, apiKey, opts) {
    var cloneDeep = __webpack_require__(42);

    opts = opts && cloneDeep(opts) || {};
    opts.hosts = opts.hosts || [
      'places-dsn.algolia.net',
      'places-1.algolianet.com',
      'places-2.algolianet.com',
      'places-3.algolianet.com'
    ];

    // allow initPlaces() no arguments => community rate limited
    if (arguments.length === 0 || typeof appID === 'object' || appID === undefined) {
      appID = '';
      apiKey = '';
      opts._allowEmptyCredentials = true;
    }

    var client = algoliasearch(appID, apiKey, opts);
    var index = client.initIndex('places');
    index.search = buildSearchMethod('query', '/1/places/query');
    index.getObject = function(objectID, callback) {
      return this.as._jsonRequest({
        method: 'GET',
        url: '/1/places/' + encodeURIComponent(objectID),
        hostType: 'read',
        callback: callback
      });
    };
    return index;
  };
}


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var debug = __webpack_require__(51)('algoliasearch:src/hostIndexState.js');
var localStorageNamespace = 'algoliasearch-client-js';

var store;
var moduleStore = {
  state: {},
  set: function(key, data) {
    this.state[key] = data;
    return this.state[key];
  },
  get: function(key) {
    return this.state[key] || null;
  }
};

var localStorageStore = {
  set: function(key, data) {
    moduleStore.set(key, data); // always replicate localStorageStore to moduleStore in case of failure

    try {
      var namespace = JSON.parse(global.localStorage[localStorageNamespace]);
      namespace[key] = data;
      global.localStorage[localStorageNamespace] = JSON.stringify(namespace);
      return namespace[key];
    } catch (e) {
      return localStorageFailure(key, e);
    }
  },
  get: function(key) {
    try {
      return JSON.parse(global.localStorage[localStorageNamespace])[key] || null;
    } catch (e) {
      return localStorageFailure(key, e);
    }
  }
};

function localStorageFailure(key, e) {
  debug('localStorage failed with', e);
  cleanup();
  store = moduleStore;
  return store.get(key);
}

store = supportsLocalStorage() ? localStorageStore : moduleStore;

module.exports = {
  get: getOrSet,
  set: getOrSet,
  supportsLocalStorage: supportsLocalStorage
};

function getOrSet(key, data) {
  if (arguments.length === 1) {
    return store.get(key);
  }

  return store.set(key, data);
}

function supportsLocalStorage() {
  try {
    if ('localStorage' in global &&
      global.localStorage !== null) {
      if (!global.localStorage[localStorageNamespace]) {
        // actual creation of the namespace
        global.localStorage.setItem(localStorageNamespace, JSON.stringify({}));
      }
      return true;
    }

    return false;
  } catch (_) {
    return false;
  }
}

// In case of any error on localStorage, we clean our own namespace, this should handle
// quota errors when a lot of keys + data are used
function cleanup() {
  try {
    global.localStorage.removeItem(localStorageNamespace);
  } catch (_) {
    // nothing to do
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52)))

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = '3.29.0';


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 2017 Julian Garnier
 Released under the MIT license
*/
var $jscomp={scope:{}};$jscomp.defineProperty="function"==typeof Object.defineProperties?Object.defineProperty:function(e,r,p){if(p.get||p.set)throw new TypeError("ES3 does not support getters and setters.");e!=Array.prototype&&e!=Object.prototype&&(e[r]=p.value)};$jscomp.getGlobal=function(e){return"undefined"!=typeof window&&window===e?e:"undefined"!=typeof global&&null!=global?global:e};$jscomp.global=$jscomp.getGlobal(this);$jscomp.SYMBOL_PREFIX="jscomp_symbol_";
$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol)};$jscomp.symbolCounter_=0;$jscomp.Symbol=function(e){return $jscomp.SYMBOL_PREFIX+(e||"")+$jscomp.symbolCounter_++};
$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var e=$jscomp.global.Symbol.iterator;e||(e=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));"function"!=typeof Array.prototype[e]&&$jscomp.defineProperty(Array.prototype,e,{configurable:!0,writable:!0,value:function(){return $jscomp.arrayIterator(this)}});$jscomp.initSymbolIterator=function(){}};$jscomp.arrayIterator=function(e){var r=0;return $jscomp.iteratorPrototype(function(){return r<e.length?{done:!1,value:e[r++]}:{done:!0}})};
$jscomp.iteratorPrototype=function(e){$jscomp.initSymbolIterator();e={next:e};e[$jscomp.global.Symbol.iterator]=function(){return this};return e};$jscomp.array=$jscomp.array||{};$jscomp.iteratorFromArray=function(e,r){$jscomp.initSymbolIterator();e instanceof String&&(e+="");var p=0,m={next:function(){if(p<e.length){var u=p++;return{value:r(u,e[u]),done:!1}}m.next=function(){return{done:!0,value:void 0}};return m.next()}};m[Symbol.iterator]=function(){return m};return m};
$jscomp.polyfill=function(e,r,p,m){if(r){p=$jscomp.global;e=e.split(".");for(m=0;m<e.length-1;m++){var u=e[m];u in p||(p[u]={});p=p[u]}e=e[e.length-1];m=p[e];r=r(m);r!=m&&null!=r&&$jscomp.defineProperty(p,e,{configurable:!0,writable:!0,value:r})}};$jscomp.polyfill("Array.prototype.keys",function(e){return e?e:function(){return $jscomp.iteratorFromArray(this,function(e){return e})}},"es6-impl","es3");var $jscomp$this=this;
(function(e,r){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (r),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"===typeof module&&module.exports?module.exports=r():e.anime=r()})(this,function(){function e(a){if(!h.col(a))try{return document.querySelectorAll(a)}catch(c){}}function r(a,c){for(var d=a.length,b=2<=arguments.length?arguments[1]:void 0,f=[],n=0;n<d;n++)if(n in a){var k=a[n];c.call(b,k,n,a)&&f.push(k)}return f}function p(a){return a.reduce(function(a,d){return a.concat(h.arr(d)?p(d):d)},[])}function m(a){if(h.arr(a))return a;
h.str(a)&&(a=e(a)||a);return a instanceof NodeList||a instanceof HTMLCollection?[].slice.call(a):[a]}function u(a,c){return a.some(function(a){return a===c})}function C(a){var c={},d;for(d in a)c[d]=a[d];return c}function D(a,c){var d=C(a),b;for(b in a)d[b]=c.hasOwnProperty(b)?c[b]:a[b];return d}function z(a,c){var d=C(a),b;for(b in c)d[b]=h.und(a[b])?c[b]:a[b];return d}function T(a){a=a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,function(a,c,d,k){return c+c+d+d+k+k});var c=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
a=parseInt(c[1],16);var d=parseInt(c[2],16),c=parseInt(c[3],16);return"rgba("+a+","+d+","+c+",1)"}function U(a){function c(a,c,b){0>b&&(b+=1);1<b&&--b;return b<1/6?a+6*(c-a)*b:.5>b?c:b<2/3?a+(c-a)*(2/3-b)*6:a}var d=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(a)||/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(a);a=parseInt(d[1])/360;var b=parseInt(d[2])/100,f=parseInt(d[3])/100,d=d[4]||1;if(0==b)f=b=a=f;else{var n=.5>f?f*(1+b):f+b-f*b,k=2*f-n,f=c(k,n,a+1/3),b=c(k,n,a);a=c(k,n,a-1/3)}return"rgba("+
255*f+","+255*b+","+255*a+","+d+")"}function y(a){if(a=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a))return a[2]}function V(a){if(-1<a.indexOf("translate")||"perspective"===a)return"px";if(-1<a.indexOf("rotate")||-1<a.indexOf("skew"))return"deg"}function I(a,c){return h.fnc(a)?a(c.target,c.id,c.total):a}function E(a,c){if(c in a.style)return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase())||"0"}function J(a,c){if(h.dom(a)&&
u(W,c))return"transform";if(h.dom(a)&&(a.getAttribute(c)||h.svg(a)&&a[c]))return"attribute";if(h.dom(a)&&"transform"!==c&&E(a,c))return"css";if(null!=a[c])return"object"}function X(a,c){var d=V(c),d=-1<c.indexOf("scale")?1:0+d;a=a.style.transform;if(!a)return d;for(var b=[],f=[],n=[],k=/(\w+)\((.+?)\)/g;b=k.exec(a);)f.push(b[1]),n.push(b[2]);a=r(n,function(a,b){return f[b]===c});return a.length?a[0]:d}function K(a,c){switch(J(a,c)){case "transform":return X(a,c);case "css":return E(a,c);case "attribute":return a.getAttribute(c)}return a[c]||
0}function L(a,c){var d=/^(\*=|\+=|-=)/.exec(a);if(!d)return a;var b=y(a)||0;c=parseFloat(c);a=parseFloat(a.replace(d[0],""));switch(d[0][0]){case "+":return c+a+b;case "-":return c-a+b;case "*":return c*a+b}}function F(a,c){return Math.sqrt(Math.pow(c.x-a.x,2)+Math.pow(c.y-a.y,2))}function M(a){a=a.points;for(var c=0,d,b=0;b<a.numberOfItems;b++){var f=a.getItem(b);0<b&&(c+=F(d,f));d=f}return c}function N(a){if(a.getTotalLength)return a.getTotalLength();switch(a.tagName.toLowerCase()){case "circle":return 2*
Math.PI*a.getAttribute("r");case "rect":return 2*a.getAttribute("width")+2*a.getAttribute("height");case "line":return F({x:a.getAttribute("x1"),y:a.getAttribute("y1")},{x:a.getAttribute("x2"),y:a.getAttribute("y2")});case "polyline":return M(a);case "polygon":var c=a.points;return M(a)+F(c.getItem(c.numberOfItems-1),c.getItem(0))}}function Y(a,c){function d(b){b=void 0===b?0:b;return a.el.getPointAtLength(1<=c+b?c+b:0)}var b=d(),f=d(-1),n=d(1);switch(a.property){case "x":return b.x;case "y":return b.y;
case "angle":return 180*Math.atan2(n.y-f.y,n.x-f.x)/Math.PI}}function O(a,c){var d=/-?\d*\.?\d+/g,b;b=h.pth(a)?a.totalLength:a;if(h.col(b))if(h.rgb(b)){var f=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(b);b=f?"rgba("+f[1]+",1)":b}else b=h.hex(b)?T(b):h.hsl(b)?U(b):void 0;else f=(f=y(b))?b.substr(0,b.length-f.length):b,b=c&&!/\s/g.test(b)?f+c:f;b+="";return{original:b,numbers:b.match(d)?b.match(d).map(Number):[0],strings:h.str(a)||c?b.split(d):[]}}function P(a){a=a?p(h.arr(a)?a.map(m):m(a)):[];return r(a,
function(a,d,b){return b.indexOf(a)===d})}function Z(a){var c=P(a);return c.map(function(a,b){return{target:a,id:b,total:c.length}})}function aa(a,c){var d=C(c);if(h.arr(a)){var b=a.length;2!==b||h.obj(a[0])?h.fnc(c.duration)||(d.duration=c.duration/b):a={value:a}}return m(a).map(function(a,b){b=b?0:c.delay;a=h.obj(a)&&!h.pth(a)?a:{value:a};h.und(a.delay)&&(a.delay=b);return a}).map(function(a){return z(a,d)})}function ba(a,c){var d={},b;for(b in a){var f=I(a[b],c);h.arr(f)&&(f=f.map(function(a){return I(a,
c)}),1===f.length&&(f=f[0]));d[b]=f}d.duration=parseFloat(d.duration);d.delay=parseFloat(d.delay);return d}function ca(a){return h.arr(a)?A.apply(this,a):Q[a]}function da(a,c){var d;return a.tweens.map(function(b){b=ba(b,c);var f=b.value,e=K(c.target,a.name),k=d?d.to.original:e,k=h.arr(f)?f[0]:k,w=L(h.arr(f)?f[1]:f,k),e=y(w)||y(k)||y(e);b.from=O(k,e);b.to=O(w,e);b.start=d?d.end:a.offset;b.end=b.start+b.delay+b.duration;b.easing=ca(b.easing);b.elasticity=(1E3-Math.min(Math.max(b.elasticity,1),999))/
1E3;b.isPath=h.pth(f);b.isColor=h.col(b.from.original);b.isColor&&(b.round=1);return d=b})}function ea(a,c){return r(p(a.map(function(a){return c.map(function(b){var c=J(a.target,b.name);if(c){var d=da(b,a);b={type:c,property:b.name,animatable:a,tweens:d,duration:d[d.length-1].end,delay:d[0].delay}}else b=void 0;return b})})),function(a){return!h.und(a)})}function R(a,c,d,b){var f="delay"===a;return c.length?(f?Math.min:Math.max).apply(Math,c.map(function(b){return b[a]})):f?b.delay:d.offset+b.delay+
b.duration}function fa(a){var c=D(ga,a),d=D(S,a),b=Z(a.targets),f=[],e=z(c,d),k;for(k in a)e.hasOwnProperty(k)||"targets"===k||f.push({name:k,offset:e.offset,tweens:aa(a[k],d)});a=ea(b,f);return z(c,{children:[],animatables:b,animations:a,duration:R("duration",a,c,d),delay:R("delay",a,c,d)})}function q(a){function c(){return window.Promise&&new Promise(function(a){return p=a})}function d(a){return g.reversed?g.duration-a:a}function b(a){for(var b=0,c={},d=g.animations,f=d.length;b<f;){var e=d[b],
k=e.animatable,h=e.tweens,n=h.length-1,l=h[n];n&&(l=r(h,function(b){return a<b.end})[0]||l);for(var h=Math.min(Math.max(a-l.start-l.delay,0),l.duration)/l.duration,w=isNaN(h)?1:l.easing(h,l.elasticity),h=l.to.strings,p=l.round,n=[],m=void 0,m=l.to.numbers.length,t=0;t<m;t++){var x=void 0,x=l.to.numbers[t],q=l.from.numbers[t],x=l.isPath?Y(l.value,w*x):q+w*(x-q);p&&(l.isColor&&2<t||(x=Math.round(x*p)/p));n.push(x)}if(l=h.length)for(m=h[0],w=0;w<l;w++)p=h[w+1],t=n[w],isNaN(t)||(m=p?m+(t+p):m+(t+" "));
else m=n[0];ha[e.type](k.target,e.property,m,c,k.id);e.currentValue=m;b++}if(b=Object.keys(c).length)for(d=0;d<b;d++)H||(H=E(document.body,"transform")?"transform":"-webkit-transform"),g.animatables[d].target.style[H]=c[d].join(" ");g.currentTime=a;g.progress=a/g.duration*100}function f(a){if(g[a])g[a](g)}function e(){g.remaining&&!0!==g.remaining&&g.remaining--}function k(a){var k=g.duration,n=g.offset,w=n+g.delay,r=g.currentTime,x=g.reversed,q=d(a);if(g.children.length){var u=g.children,v=u.length;
if(q>=g.currentTime)for(var G=0;G<v;G++)u[G].seek(q);else for(;v--;)u[v].seek(q)}if(q>=w||!k)g.began||(g.began=!0,f("begin")),f("run");if(q>n&&q<k)b(q);else if(q<=n&&0!==r&&(b(0),x&&e()),q>=k&&r!==k||!k)b(k),x||e();f("update");a>=k&&(g.remaining?(t=h,"alternate"===g.direction&&(g.reversed=!g.reversed)):(g.pause(),g.completed||(g.completed=!0,f("complete"),"Promise"in window&&(p(),m=c()))),l=0)}a=void 0===a?{}:a;var h,t,l=0,p=null,m=c(),g=fa(a);g.reset=function(){var a=g.direction,c=g.loop;g.currentTime=
0;g.progress=0;g.paused=!0;g.began=!1;g.completed=!1;g.reversed="reverse"===a;g.remaining="alternate"===a&&1===c?2:c;b(0);for(a=g.children.length;a--;)g.children[a].reset()};g.tick=function(a){h=a;t||(t=h);k((l+h-t)*q.speed)};g.seek=function(a){k(d(a))};g.pause=function(){var a=v.indexOf(g);-1<a&&v.splice(a,1);g.paused=!0};g.play=function(){g.paused&&(g.paused=!1,t=0,l=d(g.currentTime),v.push(g),B||ia())};g.reverse=function(){g.reversed=!g.reversed;t=0;l=d(g.currentTime)};g.restart=function(){g.pause();
g.reset();g.play()};g.finished=m;g.reset();g.autoplay&&g.play();return g}var ga={update:void 0,begin:void 0,run:void 0,complete:void 0,loop:1,direction:"normal",autoplay:!0,offset:0},S={duration:1E3,delay:0,easing:"easeOutElastic",elasticity:500,round:0},W="translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective".split(" "),H,h={arr:function(a){return Array.isArray(a)},obj:function(a){return-1<Object.prototype.toString.call(a).indexOf("Object")},
pth:function(a){return h.obj(a)&&a.hasOwnProperty("totalLength")},svg:function(a){return a instanceof SVGElement},dom:function(a){return a.nodeType||h.svg(a)},str:function(a){return"string"===typeof a},fnc:function(a){return"function"===typeof a},und:function(a){return"undefined"===typeof a},hex:function(a){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)},rgb:function(a){return/^rgb/.test(a)},hsl:function(a){return/^hsl/.test(a)},col:function(a){return h.hex(a)||h.rgb(a)||h.hsl(a)}},A=function(){function a(a,
d,b){return(((1-3*b+3*d)*a+(3*b-6*d))*a+3*d)*a}return function(c,d,b,f){if(0<=c&&1>=c&&0<=b&&1>=b){var e=new Float32Array(11);if(c!==d||b!==f)for(var k=0;11>k;++k)e[k]=a(.1*k,c,b);return function(k){if(c===d&&b===f)return k;if(0===k)return 0;if(1===k)return 1;for(var h=0,l=1;10!==l&&e[l]<=k;++l)h+=.1;--l;var l=h+(k-e[l])/(e[l+1]-e[l])*.1,n=3*(1-3*b+3*c)*l*l+2*(3*b-6*c)*l+3*c;if(.001<=n){for(h=0;4>h;++h){n=3*(1-3*b+3*c)*l*l+2*(3*b-6*c)*l+3*c;if(0===n)break;var m=a(l,c,b)-k,l=l-m/n}k=l}else if(0===
n)k=l;else{var l=h,h=h+.1,g=0;do m=l+(h-l)/2,n=a(m,c,b)-k,0<n?h=m:l=m;while(1e-7<Math.abs(n)&&10>++g);k=m}return a(k,d,f)}}}}(),Q=function(){function a(a,b){return 0===a||1===a?a:-Math.pow(2,10*(a-1))*Math.sin(2*(a-1-b/(2*Math.PI)*Math.asin(1))*Math.PI/b)}var c="Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(" "),d={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],a],Out:[[.25,
.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(b,c){return 1-a(1-b,c)}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(b,c){return.5>b?a(2*b,c)/2:1-a(-2*b+2,c)/2}]},b={linear:A(.25,.25,.75,.75)},f={},e;for(e in d)f.type=e,d[f.type].forEach(function(a){return function(d,f){b["ease"+a.type+c[f]]=h.fnc(d)?
d:A.apply($jscomp$this,d)}}(f)),f={type:f.type};return b}(),ha={css:function(a,c,d){return a.style[c]=d},attribute:function(a,c,d){return a.setAttribute(c,d)},object:function(a,c,d){return a[c]=d},transform:function(a,c,d,b,f){b[f]||(b[f]=[]);b[f].push(c+"("+d+")")}},v=[],B=0,ia=function(){function a(){B=requestAnimationFrame(c)}function c(c){var b=v.length;if(b){for(var d=0;d<b;)v[d]&&v[d].tick(c),d++;a()}else cancelAnimationFrame(B),B=0}return a}();q.version="2.2.0";q.speed=1;q.running=v;q.remove=
function(a){a=P(a);for(var c=v.length;c--;)for(var d=v[c],b=d.animations,f=b.length;f--;)u(a,b[f].animatable.target)&&(b.splice(f,1),b.length||d.pause())};q.getValue=K;q.path=function(a,c){var d=h.str(a)?e(a)[0]:a,b=c||100;return function(a){return{el:d,property:a,totalLength:N(d)*(b/100)}}};q.setDashoffset=function(a){var c=N(a);a.setAttribute("stroke-dasharray",c);return c};q.bezier=A;q.easings=Q;q.timeline=function(a){var c=q(a);c.pause();c.duration=0;c.add=function(d){c.children.forEach(function(a){a.began=
!0;a.completed=!0});m(d).forEach(function(b){var d=z(b,D(S,a||{}));d.targets=d.targets||a.targets;b=c.duration;var e=d.offset;d.autoplay=!1;d.direction=c.direction;d.offset=h.und(e)?b:L(e,b);c.began=!0;c.completed=!0;c.seek(d.offset);d=q(d);d.began=!0;d.completed=!0;d.duration>b&&(c.duration=d.duration);c.children.push(d)});c.seek(0);c.reset();c.autoplay&&c.restart();return c};return c};q.random=function(a,c){return Math.floor(Math.random()*(c-a+1))+a};return q});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52)))

/***/ }),
/* 172 */
/***/ (function(module, exports) {

/**
 * Active color.
 */
AFRAME.registerComponent('active-color', {
  dependencies: ['material'],

  schema: {
    active: { default: false },
    color: { default: '#ffffff' }
  },

  init: function () {
    this.defaultColor = this.el.getAttribute('material').color;
  },

  update: function () {
    var el = this.el;

    if (this.data.active) {
      el.setAttribute('material', { 'color': this.data.color, 'opacity': 1 });
    } else {
      el.setAttribute('material', 'color', this.defaultColor);
      if (el.components.animation__mouseleave) {
        setTimeout(() => {
          el.emit('mouseleave', null, false);
        });
      }
    }
  }
});

AFRAME.registerComponent('active-text-color', {
  dependencies: ['text'],

  schema: {
    active: { default: false },
    color: { default: '#333' }
  },

  init: function () {
    this.defaultColor = this.el.getAttribute('text').color;
  },

  update: function () {
    var el = this.el;
    if (this.data.active) {
      el.setAttribute('text', 'color', this.data.color);
    } else {
      el.setAttribute('text', 'color', this.defaultColor);
    }
  }
});

/***/ }),
/* 173 */
/***/ (function(module, exports) {

AFRAME.registerComponent('analyser', {
  dependencies: ['audioanalyser'],
  schema: {
    height: { default: 1.0 },
    thickness: { default: 0.1 },
    separation: { default: 0.3 },
    scale: { default: 4.0 },
    mirror: { default: 3 }
  },

  init: function () {
    this.analyser = this.el.components.audioanalyser;
    this.columns = null;
    var material = this.el.sceneEl.systems.materials.black;
    var geometry = new THREE.BoxBufferGeometry();
    for (var i = 0; i < this.analyser.data.fftSize; i++) {
      for (var side = 0; side < 2; side++) {
        var column = new THREE.Mesh(geometry, material);
        this.el.object3D.add(column);
      }
    }
    this.columns = this.el.object3D.children;
  },

  update: function () {
    var z = 0;
    for (var i = 0; i < this.columns.length; i++) {
      this.columns[i].position.x = (i % 2 * 2 - 1) * this.data.mirror;
      this.columns[i].position.z = z;
      this.columns[i].scale.set(this.data.thickness, this.data.height, this.data.thickness);
      z -= this.data.separation;
    }
  },

  tick: function () {
    var v;
    var height = this.data.height;
    var n = this.columns.length / 2;

    for (var i = 0; i < n; i++) {
      v = height + this.analyser.levels[i] / 256.0 * this.data.scale;
      this.columns[i * 2 + 0].scale.y = v;
      this.columns[i * 2 + 1].scale.y = v;
    }
  }
});

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var utils = __webpack_require__(55);

/**
 * Load beat data (all the beats and such).
 */
AFRAME.registerComponent('beat-loader', {
  schema: {
    challengeId: { type: 'string' },
    difficulty: { type: 'string' }
  },

  update: function () {
    if (!this.data.challengeId || !this.data.difficulty) {
      return;
    }
    this.loadBeats(this.data.challengeId, this.data.difficulty);
  },

  /**
   * XHR.
   */
  loadBeats: function (id, difficulty) {
    var el = this.el;
    var xhr;

    // Load beats.
    let url = utils.getS3FileUrl(this.data.challengeId, `${this.data.difficulty}.json`);
    xhr = new XMLHttpRequest();
    el.emit('beatloaderstart');
    console.log(`Fetching ${url}...`);
    xhr.open('GET', url);
    xhr.addEventListener('load', () => {
      this.handleBeats(JSON.parse(xhr.responseText));
    });
    xhr.send();
  },

  /**
   * TODO: Load the beat data into the game.
   */
  handleBeats: function (beatData) {
    this.el.sceneEl.emit('beatloaderfinish', beatData, false);
    console.log('Finished loading challenge data.');
  }
});

function updateQueryParam(uri, key, value) {
  var re = new RegExp('([?&])' + key + '=.*?(&|$)', 'i');
  var separator = uri.indexOf('?') !== -1 ? '&' : '?';
  if (uri.match(re)) {
    return uri.replace(re, '$1' + key + '=' + value + '$2');
  } else {
    return uri + separator + key + '=' + value;
  }
}

/***/ }),
/* 175 */
/***/ (function(module, exports) {

AFRAME.registerComponent('console-shortcuts', {
  play: function () {
    window.$ = val => document.querySelector(val);
    window.$$ = val => document.querySelectorAll(val);
    window.$$$ = val => document.querySelector(`[${val}]`).getAttribute(val);
    window.$$$$ = val => document.querySelector(`[${val}]`).components[val];
    window.scene = this.el;
    window.state = this.el.systems.state.state;
  }
});

/***/ }),
/* 176 */
/***/ (function(module, exports) {

/**
 * Cursor mesh to show at intersection point with respective hand.
 */
AFRAME.registerComponent('cursor-mesh', {
  schema: {
    cursorEl: { type: 'selector' }
  },

  init: function () {
    this.scenePivotEl = document.getElementById('scenePivot');
  },

  tick: function () {
    var cursor;
    var cursorEl = this.data.cursorEl;
    var el = this.el;
    var i;
    var intersection;
    var intersectedEl;
    var intersectionPoint;
    var object3D = this.el.object3D;
    var scenePivotEl = this.scenePivotEl;

    cursor = cursorEl.components.cursor;
    if (!cursor) {
      return;
    }

    // Look for valid intersection target.
    intersectedEl = cursorEl.components.cursor.intersectedEl;
    if (intersectedEl) {
      el.object3D.visible = true;
    } else {
      el.object3D.visible = false;
      return;
    }

    // Update cursor mesh.
    intersection = cursorEl.components.raycaster.getIntersection(intersectedEl);
    el.object3D.position.copy(intersection.point);

    if (scenePivotEl) {
      el.object3D.rotation.copy(scenePivotEl.object3D.rotation);
    }
  }
});

/***/ }),
/* 177 */
/***/ (function(module, exports) {

/**
 * Keyboard bindings to control controller.
 * Position controller in front of camera.
 */
AFRAME.registerComponent('debug-controller', {
  init: function () {
    var primaryHand;
    var secondaryHand;

    if (!AFRAME.utils.getUrlParameter('debug')) {
      return;
    }

    console.log('%c debug-controller enabled ', 'background: #111; color: red');

    this.isCloning = false;
    this.isDeleting = false;
    this.isTriggerDown = false;

    primaryHand = document.getElementById('rightHand');
    secondaryHand = document.getElementById('leftHand');

    if (AFRAME.utils.getUrlParameter('debug') === 'oculus') {
      primaryHand.emit('controllerconnected', { name: 'oculus-touch-controls' });
      secondaryHand.emit('controllerconnected', { name: 'oculus-touch-controls' });
      primaryHand.setAttribute('controller', 'controllerType', 'oculus-touch-controls');
      secondaryHand.setAttribute('controller', 'controllerType', 'oculus-touch-controls');
    } else {
      primaryHand.emit('controllerconnected', { name: 'vive-controls' });
      secondaryHand.emit('controllerconnected', { name: 'vive-controls' });
      primaryHand.setAttribute('controller', 'controllerType', 'vive-controls');
      secondaryHand.setAttribute('controller', 'controllerType', 'vive-controls');
    }

    // Enable raycaster.
    this.el.emit('enter-vr', null, false);

    document.addEventListener('keydown', evt => {
      var primaryPosition;
      var primaryRotation;
      var secondaryPosition;
      var secondaryRotation;

      if (!evt.shiftKey) {
        return;
      }

      // <space> for trigger.
      if (evt.keyCode === 32) {
        if (this.isTriggerDown) {
          primaryHand.emit('triggerup');
          this.isTriggerDown = false;
        } else {
          primaryHand.emit('triggerdown');
          this.isTriggerDown = true;
        }
        return;
      }

      // <q> for secondary trigger.
      if (evt.keyCode === 81) {
        if (this.isSecondaryTriggerDown) {
          secondaryHand.emit('triggerup');
          this.isSecondaryTriggerDown = false;
        } else {
          secondaryHand.emit('triggerdown');
          this.isSecondaryTriggerDown = true;
        }
        return;
      }

      // <n> secondary grip.
      if (evt.keyCode === 78) {
        if (this.secondaryGripDown) {
          secondaryHand.emit('gripup');
          this.secondaryGripDown = false;
        } else {
          secondaryHand.emit('gripdown');
          this.secondaryGripDown = true;
        }
      }

      // <m> primary grip.
      if (evt.keyCode === 77) {
        if (this.primaryGripDown) {
          primaryHand.emit('gripup');
          this.primaryGripDown = false;
        } else {
          primaryHand.emit('gripdown');
          this.primaryGripDown = true;
        }
      }

      // Menu button <1>.
      if (evt.keyCode === 49) {
        secondaryHand.emit('menudown');
      }

      // Position bindings.
      if (evt.ctrlKey) {
        secondaryPosition = secondaryHand.getAttribute('position');
        if (evt.keyCode === 72) {
          secondaryPosition.x -= 0.01;
        } // h.
        if (evt.keyCode === 74) {
          secondaryPosition.y -= 0.01;
        } // j.
        if (evt.keyCode === 75) {
          secondaryPosition.y += 0.01;
        } // k.
        if (evt.keyCode === 76) {
          secondaryPosition.x += 0.01;
        } // l.
        if (evt.keyCode === 59 || evt.keyCode === 186) {
          secondaryPosition.z -= 0.01;
        } // ;.
        if (evt.keyCode === 222) {
          secondaryPosition.z += 0.01;
        } // ;.
        secondaryHand.setAttribute('position', AFRAME.utils.clone(secondaryPosition));
      } else {
        primaryPosition = primaryHand.getAttribute('position');
        if (evt.keyCode === 72) {
          primaryPosition.x -= 0.01;
        } // h.
        if (evt.keyCode === 74) {
          primaryPosition.y -= 0.01;
        } // j.
        if (evt.keyCode === 75) {
          primaryPosition.y += 0.01;
        } // k.
        if (evt.keyCode === 76) {
          primaryPosition.x += 0.01;
        } // l.
        if (evt.keyCode === 59 || evt.keyCode === 186) {
          primaryPosition.z -= 0.01;
        } // ;.
        if (evt.keyCode === 222) {
          primaryPosition.z += 0.01;
        } // ;.
        primaryHand.setAttribute('position', AFRAME.utils.clone(primaryPosition));
      }

      // Rotation bindings.
      if (evt.ctrlKey) {
        secondaryRotation = secondaryHand.getAttribute('rotation');
        if (evt.keyCode === 89) {
          secondaryRotation.x -= 10;
        } // y.
        if (evt.keyCode === 79) {
          secondaryRotation.x += 10;
        } // o.
        if (evt.keyCode === 85) {
          secondaryRotation.y -= 10;
        } // u.
        if (evt.keyCode === 73) {
          secondaryRotation.y += 10;
        } // i.
        secondaryHand.setAttribute('rotation', AFRAME.utils.clone(secondaryRotation));
      } else {
        primaryRotation = primaryHand.getAttribute('rotation');
        if (evt.keyCode === 89) {
          primaryRotation.x -= 10;
        } // y.
        if (evt.keyCode === 79) {
          primaryRotation.x += 10;
        } // o.
        if (evt.keyCode === 85) {
          primaryRotation.y -= 10;
        } // u.
        if (evt.keyCode === 73) {
          primaryRotation.y += 10;
        } // i.
        primaryHand.setAttribute('rotation', AFRAME.utils.clone(primaryRotation));
      }
    });
  },

  play: function () {
    var primaryHand;
    var secondaryHand;

    if (!AFRAME.utils.getUrlParameter('debug')) {
      return;
    }

    primaryHand = document.getElementById('rightHand');
    secondaryHand = document.getElementById('leftHand');

    secondaryHand.object3D.position.set(-0.2, 1.5, -0.5);
    primaryHand.object3D.position.set(0.2, 1.5, -0.5);
    secondaryHand.setAttribute('rotation', { x: 35, y: 0, z: 0 });
    primaryHand.setAttribute('rotation', { x: 35, y: 0, z: 0 });
  }
});

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Log cursor events.
 */
AFRAME.registerComponent('debug-cursor', {
  init: function () {
    if (undefined === 'production') {
      return;
    }

    this.el.addEventListener('mouseenter', evt => {
      this.log('mouseenter', evt.detail.intersectedEl, 'green');
    });

    this.el.addEventListener('mouseleave', evt => {
      this.log('mouseleave', evt.detail.intersectedEl, 'red');
    });

    this.el.addEventListener('click', evt => {
      this.log('click', evt.detail.intersectedEl, 'blue');
    });
  },

  log: function (event, intersectedEl, color) {
    if (intersectedEl.id) {
      console.log(`%c[${event}] ${intersectedEl.id}`, `color: ${color}`);
    } else {
      console.log(`%c[${event}]`, `color: ${color}`);
      console.log(intersectedEl);
    }
  }
});

/***/ }),
/* 179 */
/***/ (function(module, exports) {

const events = ['triggerdown', 'gripdown', 'abuttondown', 'bbuttondown', 'xbuttondown', 'ybuttondown', 'trackpaddown'];

/**
 * Swap left or right-handed mode.
 */
AFRAME.registerComponent('hand-swapper', {
  schema: {
    enabled: { default: false }
  },

  init: function () {
    this.swapHand = this.swapHand.bind(this);
    events.forEach(event => {
      this.el.addEventListener(event, this.swapHand);
    });
  },

  swapHand: function () {
    if (!this.data.enabled) {
      return;
    }

    // Handled via state.
    this.el.sceneEl.emit('activehandswap', null, false);
  }
});

/***/ }),
/* 180 */
/***/ (function(module, exports) {

/**
 * Update window title and history.
 */
AFRAME.registerComponent('history', {
  schema: {
    challengeId: { type: 'string' },
    songName: { type: 'string' },
    songSubName: { type: 'string' }
  },

  update: function () {
    const data = this.data;
    history.pushState('', data.songName, updateQueryParam(window.location.href, 'challenge', data.challengeId));
    document.title = `Super Saber - ${data.songName}`;
  }
});

/***/ }),
/* 181 */
/***/ (function(module, exports) {

AFRAME.registerComponent('keyboard-raycastable', {
  dependencies: ['super-keyboard'],

  play: function () {
    // TODO: bind-toggle__raycastable for when search is activated.
    this.el.components['super-keyboard'].kbImg.setAttribute('bind-toggle__raycastable', 'menu.active');
  }
});

/***/ }),
/* 182 */
/***/ (function(module, exports) {

AFRAME.registerComponent('logoflicker', {
  dependencies: ['text'],

  schema: {
    delay: { default: 1000.0 }
  },

  init: function () {
    this.setOff = this.setOff.bind(this);
    this.setOn = this.setOn.bind(this);

    this.defaultColor = new THREE.Color().setStyle(this.el.components.text.data.color);
    this.color = new THREE.Color().setStyle('#0A0228');
    this.colorUniform = this.el.components.text.material.uniforms.color.value;

    this.sparks = document.getElementById('logosparks');
    this.sparkPositions = [{ position: new THREE.Vector3(0, 0.1, 0) }, { position: new THREE.Vector3(0.5, 1.2, 0) }, { position: new THREE.Vector3(0, 1.2, 0) }];

    this.setOn();
  },

  setOff: function () {
    this.colorUniform.x = this.color.r;
    this.colorUniform.y = this.color.g;
    this.colorUniform.z = this.color.b;
    this.colorUniform.needsUpdate = true;

    this.sparks.emit('logoflicker', this.sparkPositions[Math.floor(Math.random() * this.sparkPositions.length)], false);

    setTimeout(this.setOn, 50 + Math.floor(Math.random() * 100));
  },

  setOn: function () {
    this.colorUniform.x = this.defaultColor.r;
    this.colorUniform.y = this.defaultColor.g;
    this.colorUniform.z = this.defaultColor.b;
    this.colorUniform.needsUpdate = true;

    setTimeout(this.setOff, Math.floor(this.data.delay * 3 / 10 + Math.random() * this.data.delay));
  }
});

/***/ }),
/* 183 */
/***/ (function(module, exports) {

AFRAME.registerSystem('materials', {
  init: function () {
    this.black = new THREE.MeshLambertMaterial({ color: 0x000000, flatShading: true });
    this.default = new THREE.MeshLambertMaterial({ color: 0xff0000, flatShading: true });
    this.neon = new THREE.MeshBasicMaterial({ color: 0x9999ff, fog: false });
  }
});

AFRAME.registerComponent('materials', {
  schema: {
    default: 'black',
    oneOf: ['black', 'default', 'neon']
  },
  update: function () {
    this.el.object3D.traverse(o => o.material = this.system[this.data]);
  }
});

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var bindEvent = __webpack_require__(99).bindEvent;

/**
 * Select difficulty.
 */
AFRAME.registerComponent('menu-difficulty-select', {
  init: function () {
    this.el.sceneEl.addEventListener('menuchallengeselect', () => {
      setTimeout(() => {
        this.el.components.layout.update();
      });
    });
  },

  click: bindEvent(function (evt) {
    this.el.sceneEl.emit('menudifficultyselect', evt.target.closest('.difficultyOption').dataset.difficulty, false);
  })
});

/***/ }),
/* 185 */
/***/ (function(module, exports) {

/**
 * Reuse images from the search results to not create another texture.
 */
AFRAME.registerComponent('menu-selected-challenge-image', {
  schema: {
    selectedChallengeId: { type: 'string' }
  },

  init: function () {
    this.searchResultEls = document.getElementById('searchResultList');
  },

  update: function () {
    const data = this.data;
    const el = this.el;

    if (!data.selectedChallengeId) {
      return;
    }

    const imageEl = this.searchResultEls.querySelector(`[data-id="${data.selectedChallengeId}"] .searchResultImage`);
    el.getObject3D('mesh').material.map = imageEl.getObject3D('mesh').material.map;
    el.getObject3D('mesh').material.needsUpdate = true;
  }
});

/***/ }),
/* 186 */
/***/ (function(module, exports) {

const events = ['menudown', 'abuttondown', 'bbuttondown', 'xbuttondown', 'ybuttondown'];

/**
 * Tell app to pause game if playing.
 */
AFRAME.registerComponent('pauser', {
  schema: {
    enabled: { default: true }
  },

  init: function () {
    this.pauseGame = this.pauseGame.bind(this);

    events.forEach(event => {
      this.el.addEventListener(event, this.pauseGame);
    });
  },

  pauseGame: function () {
    if (!this.data.enabled) {
      return;
    }
    this.el.sceneEl.emit('pausegame', null, false);
  }
});

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var SoundPool = __webpack_require__(200);

AFRAME.registerSystem('play-sound', {
  init: function () {
    this.lastSoundPlayed = '';
    this.lastSoundPlayedTime = 0;
    this.pools = {};
  },

  createPool: function (sound, volume) {
    if (this.pools[sound]) {
      return;
    }
    this.pools[sound] = new SoundPool(sound, volume);
  },

  playSound: function (sound, volume) {
    if (!this.pools[sound]) {
      this.createPool(sound, volume);
    }
    this.pools[sound].play();

    this.lastSoundPlayed = sound;
    this.lastSoundTime = this.el.time;
  }
});

/**
 * Play sound on event.
 */
AFRAME.registerComponent('play-sound', {
  schema: {
    enabled: { default: true },
    event: { type: 'string' },
    sound: { type: 'string' },
    volume: { type: 'number', default: 1 }
  },

  multiple: true,

  init: function () {
    this.el.addEventListener(this.data.event, evt => {
      if (!this.data.enabled) {
        return;
      }
      this.system.playSound(this.src, this.data.volume);
    });
  },

  update: function () {
    this.src = this.data.sound;
    if (this.data.sound.startsWith('#')) {
      this.src = document.querySelector(this.data.sound).getAttribute('src');
    }
  }
});

/***/ }),
/* 188 */
/***/ (function(module, exports) {

AFRAME.registerComponent('gpu-preloader', {
  init: function () {
    setTimeout(() => {
      this.preloadFont();
      this.preloadKeyboard();
    }, 1000);

    setTimeout(() => {
      this.el.object3D.visible = false;
    }, 2000);
  },

  preloadFont: function () {
    var text;
    text = document.querySelector('[text]');
    if (text.components.text.texture) {
      this.preloadTexture(text.components.text.texture);
    } else {
      text.addEventListener('textfontset', () => {
        this.preloadTexture(text.components.text.texture);
      });
    }
  },

  preloadKeyboard: function () {
    var kbd;
    kbd = document.getElementById('kb');
    kbd.object3D.traverse(node => {
      if (node.material && node.material.map) {
        this.preloadTexture(node.material.map);
      }
    });
  },

  preloadTexture: function (texture) {
    this.el.sceneEl.renderer.setTexture2D(texture, 0);
  }
});

/***/ }),
/* 189 */
/***/ (function(module, exports) {

AFRAME.registerComponent('raycastable', {});

/***/ }),
/* 190 */
/***/ (function(module, exports) {

/**
 * Pivot the scene when user enters VR to face the links.
 */
AFRAME.registerComponent('recenter', {
  schema: {
    enabled: { default: true },
    target: { default: '' }
  },

  init: function () {
    var sceneEl = this.el.sceneEl;
    this.matrix = new THREE.Matrix4();
    this.frustum = new THREE.Frustum();
    this.rotationOffset = 0;
    this.euler = new THREE.Euler();
    this.euler.order = 'YXZ';
    this.menuPosition = new THREE.Vector3();
    this.recenter = this.recenter.bind(this);
    this.checkInViewAfterRecenter = this.checkInViewAfterRecenter.bind(this);
    this.target = document.querySelector(this.data.target);

    // Delay to make sure we have a valid pose.
    sceneEl.addEventListener('enter-vr', () => setTimeout(this.recenter, 100));
    // User can also recenter the menu manually.
    sceneEl.addEventListener('menudown', this.recenter);
    sceneEl.addEventListener('thumbstickdown', this.recenter);
    window.addEventListener('vrdisplaypresentchange', this.recenter);
  },

  recenter: function () {
    var euler = this.euler;
    if (!this.data.enabled) {
      return;
    }
    euler.setFromRotationMatrix(this.el.sceneEl.camera.el.object3D.matrixWorld, 'YXZ');
    this.el.object3D.rotation.y = euler.y + this.rotationOffset;
    // Check if the menu is in camera frustum in next tick after a frame has rendered.
    setTimeout(this.checkInViewAfterRecenter, 0);
  },

  /*
   * Sometimes the quaternion returns the yaw in the [-180, 180] range.
   * Check if the menu is in the camera frustum after recenter it to
   * decide if we apply an offset or not.
   */
  checkInViewAfterRecenter: function () {
    var bottomVec3 = new THREE.Vector3();
    var topVec3 = new THREE.Vector3();

    return function () {
      var camera = this.el.sceneEl.camera;
      var frustum = this.frustum;
      var menuPosition = this.menuPosition;

      camera.updateMatrix();
      camera.updateMatrixWorld();
      frustum.setFromMatrix(this.matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));

      // Check if menu position (and its bounds) are within the frustum.
      // Check bounds in case looking angled up or down, rather than menu central.
      menuPosition.setFromMatrixPosition(this.target.object3D.matrixWorld);
      bottomVec3.copy(menuPosition).y -= 3;
      topVec3.copy(menuPosition).y += 3;

      if (frustum.containsPoint(menuPosition) || frustum.containsPoint(bottomVec3) || frustum.containsPoint(topVec3)) {
        return;
      }

      this.rotationOffset = this.rotationOffset === 0 ? Math.PI : 0;
      // Recenter again with the new offset.
      this.recenter();
    };
  }(),

  remove: function () {
    this.el.sceneEl.removeEventListener('enter-vr', this.recenter);
  }
});

/***/ }),
/* 191 */
/***/ (function(module, exports) {

AFRAME.registerComponent('saber-controls', {
  schema: {
    hand: { default: 'right', oneOf: ['left', 'right'] },
    bladeEnabled: { default: true }
  },

  colors: {
    right: '#78aaff', // Blue
    left: '#ffa8a8' // Red
  },

  init: function () {
    var el = this.el;
    var data = this.data;
    el.addEventListener('controllerconnected', this.initSaber.bind(this));

    const hand = { hand: data.hand, model: false };
    el.setAttribute('oculus-touch-controls', hand);
    el.setAttribute('vive-controls', hand);
    el.setAttribute('windows-motion-controls', hand);
  },

  update: function () {
    if (!this.bladeEl) {
      return;
    }
    this.bladeEl.object3D.visible = this.data.bladeEnabled;
    if (this.data.bladeEnabled) {
      this.bladeElPivot.object3D.scale.set(0.0001, 0.001, 0.0001);
      this.bladeEl.emit('drawblade');
    }
  },

  tick: function () {
    if (!this.bladeEl || !this.bladeEl.getObject3D('mesh')) {
      return;
    }
    this.boundingBox.setFromObject(this.bladeEl.getObject3D('mesh'));
  },

  initSaber: function (evt) {
    var el = this.el;
    var saberHandleEl = document.createElement('a-entity');
    var bladeEl = this.bladeEl = document.createElement('a-entity');
    var bladeElPivot = this.bladeElPivot = document.createElement('a-entity');
    var saberPivotEl = document.createElement('a-entity');
    var highlightTop = document.createElement('a-entity');
    var highlightBottom = document.createElement('a-entity');
    var controllerConfig = this.config[evt.detail.name];

    this.boundingBox = new THREE.Box3();

    bladeEl.setAttribute('material', { shader: 'flat', color: this.colors[this.data.hand] });
    bladeEl.setAttribute('geometry', { primitive: 'box', height: 0.9, depth: 0.020, width: 0.020 });
    bladeEl.setAttribute('position', '0 -0.55 0');
    bladeEl.setAttribute('play-sound', { event: 'drawblade', sound: "#saberDraw" });
    bladeEl.object3D.visible = this.data.bladeEnabled;

    // For blade saber draw animation.
    bladeElPivot.appendChild(bladeEl);
    bladeElPivot.setAttribute('animation', 'property: scale; from: 0 0 0; to: 1.0 1.0 1.0; dur: 750; easing: linear; startEvents: drawblade');

    saberHandleEl.setAttribute('material', { shader: 'flat', color: '#151515' });
    saberHandleEl.setAttribute('geometry', { primitive: 'box', height: 0.2, depth: 0.025, width: 0.025 });
    saberHandleEl.setAttribute('position', '0 0 0');

    highlightTop.setAttribute('material', { shader: 'flat', color: this.colors[this.data.hand] });
    highlightTop.setAttribute('geometry', { primitive: 'box', height: 0.18, depth: 0.005, width: 0.005 });
    highlightTop.setAttribute('position', '0 0 0.0125');

    highlightBottom.setAttribute('material', { shader: 'flat', color: this.colors[this.data.hand] });
    highlightBottom.setAttribute('geometry', { primitive: 'box', height: 0.18, depth: 0.005, width: 0.005 });
    highlightBottom.setAttribute('position', '0 0 -0.0125');

    saberHandleEl.appendChild(highlightTop);
    saberHandleEl.appendChild(highlightBottom);

    saberPivotEl.setAttribute('rotation', '90 0 0');
    saberPivotEl.appendChild(saberHandleEl);
    saberPivotEl.appendChild(bladeElPivot);
    el.appendChild(saberPivotEl);

    this.controllerConnected = true;
    this.controllerType = evt.detail.name;

    el.setAttribute('cursor', controllerConfig.cursor || {});
  },

  config: {
    'oculus-touch-controls': {
      cursor: {
        downEvents: ['triggerdown', 'gripdown', 'abuttondown', 'bbuttondown', 'xbuttondown', 'ybuttondown'],
        upEvents: ['triggerup', 'gripup', 'abuttonup', 'bbuttonup', 'xbuttonup', 'ybuttonup']
      }
    },

    'vive-controls': {
      cursor: {
        downEvents: ['trackpaddown', 'triggerdown', 'gripdown'],
        upEvents: ['trackpadup', 'triggerup', 'gripup']
      }
    },

    'windows-motion-controls': {
      cursor: {
        downEvents: ['trackpaddown', 'triggerdown', 'gripdown'],
        upEvents: ['trackpadup', 'triggerup', 'gripup']
      }
    }
  }
});

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var algoliasearch = __webpack_require__(160);
var bindEvent = __webpack_require__(99).bindEvent;

var client = algoliasearch('QULTOY3ZWU', 'be07164192471df7e97e6fa70c1d041d');
var algolia = client.initIndex('supersaber');

/**
 * Search (including the initial list of popular searches).
 * Attached to super-keyboard.
 */
AFRAME.registerComponent('search', {
  init: function () {
    this.eventDetail = { results: [] };
    this.popularHits = null;
    this.queryObject = { hitsPerPage: 100, query: '' };

    // Populate popular.
    this.search('');

    // Less hits on normal searches.
    this.queryObject.hitsPerPage = 30;
  },

  superkeyboardchange: bindEvent(function (evt) {
    this.search(evt.detail.value);
  }),

  search: function (query) {
    // Use cached for popular hits.
    if (!query && this.popularHits) {
      this.eventDetail.results = popularHits;
      this.el.sceneEl.emit('searchresults', this.eventDetail);
      return;
    }

    this.queryObject.query = query;
    algolia.search(this.queryObject, (err, content) => {
      // Cache popular hits.
      if (!query) {
        this.popularHits = content.hits;
      }
      this.eventDetail.results = content.hits;
      this.el.sceneEl.emit('searchresults', this.eventDetail);
    });
  }
});

/**
 * Click listener for search result.
 */
AFRAME.registerComponent('search-result-list', {
  click: bindEvent(function (evt) {
    this.el.sceneEl.emit('menuchallengeselect', evt.target.closest('.searchResult').dataset.id, false);
  })
});

AFRAME.registerComponent('search-result-image', {
  dependencies: ['material'],

  schema: {
    id: { type: 'string' }
  },

  init: function () {
    this.materialUpdateObj = { color: '#223' };

    this.el.addEventListener('materialtextureloaded', () => {
      this.el.setAttribute('material', 'color', '#FFF');
    });
  },

  update: function () {
    this.el.components.material.material.map = null;
    this.el.components.material.material.needsUpdate = true;

    this.materialUpdateObj.src = `https://s3-us-west-2.amazonaws.com/supersaber/${this.data.id}-image.jpg`;
    this.el.setAttribute('material', this.materialUpdateObj);
  }
});

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var utils = __webpack_require__(55);

/**
 * Song preview when search result selected with smart logic for preloading.
 */
AFRAME.registerComponent('song-preview-system', {
  schema: {
    selectedChallengeId: { type: 'string' }
  },

  init: function () {
    this.audio = null;
    this.audioStore = {};
    this.preloadedAudioIds = [];
    this.preloadQueue = [];

    // anime.js animation to fade in volume.
    this.volumeTarget = { volume: 0 };
    this.animation = AFRAME.anime({
      targets: this.volumeTarget,
      delay: 250,
      duration: 1500,
      easing: 'easeInQuad',
      volume: 0.5,
      autoplay: false,
      loop: false,
      update: () => {
        this.audio.volume = this.volumeTarget.volume;
      }
    });
  },

  update: function (oldData) {
    const data = this.data;

    if (oldData.selectedChallengeId && oldData.selectedChallengeId !== data.selectedChallengeId) {
      this.stopSong();
    }

    // Selected challenge ID updated.
    if (data.selectedChallengeId && oldData.selectedChallengeId !== data.selectedChallengeId) {
      // If not yet preloaded, pause the preload queue until this song is loaded.
      if (!this.preloadedAudioIds.includes(data.selectedChallengeId) && data.selectedChallengeId !== this.currentLoadingId) {
        this.prioritizePreloadSong();
      }

      this.playSong(data.selectedChallengeId);
    }
  },

  /**
   * Song was selected so pause preload queue, prioritize its loading, and try to play ASAP.
   */
  prioritizePreloadSong: function () {
    const data = this.data;
    const preloadQueue = this.preloadQueue;

    console.log(`[song-preview] Prioritizing loading of ${data.selectedChallengeId}`);
    this.priorityLoadingChallengeId = data.selectedChallengeId;

    this.audioStore[data.selectedChallengeId].addEventListener('loadeddata', () => {
      console.log(`[song-preview] Finished load of priority ${data.selectedChallengeId}`);
      this.preloadedAudioIds.push(data.selectedChallengeId);
      this.priorityLoadingChallengeId = '';
      // Resume preloading queue.
      if (preloadQueue.length) {
        console.log(`[song-preview] Resuming queue with ${preloadQueue[0].challengeId}`);
        this.preloadMetadata(preloadQueue[0]);
      }
    });

    // Preload.
    this.audioStore[data.selectedChallengeId].src = utils.getS3FileUrl(data.selectedChallengeId, 'song.ogg');

    // Remove from preload queue.
    for (let i = 0; i < preloadQueue.length; i++) {
      if (preloadQueue[i].challengeId === data.selectedChallengeId) {
        preloadQueue.splice(i, 1);
        break;
      }
    }
  },

  /**
   * Create an audio element and queue to preload. If the queue is empty, preload it
   * immediately.
   */
  queuePreloadSong: function (challengeId, previewStartTime) {
    if (this.audioStore[challengeId]) {
      return;
    }

    const audio = document.createElement('audio');
    audio.crossOrigin = 'anonymous';
    // audio.currentTime = previewStartTime;
    audio.volume = 0;
    this.audioStore[challengeId] = audio;

    let src = utils.getS3FileUrl(challengeId, 'song.ogg');
    if (this.currentLoadingId) {
      // Audio currently loading, add to queue.
      this.preloadQueue.push({
        audio: audio,
        challengeId: challengeId,
        src: src
      });
    } else {
      // Empty queue, preload now.
      this.preloadMetadata({
        audio: audio,
        challengeId: challengeId,
        src: src
      });
    }
  },

  /**
   * Preload metadata of audio file for quick play.
   * Set `src` and `preload`.
   * A preload queue is set up so we only preload one at a time to not bog down
   * the network. If a song is selected to preview, we can bump it to the front of the
   * queue.
   */
  preloadMetadata: function (preloadItem) {
    const audio = preloadItem.audio;
    console.log(`[song-preview] Preloading song preview ${preloadItem.challengeId}`);

    audio.addEventListener('loadedmetadata', () => {
      // Song preloaded.
      console.log(`[song-preview] Finished preloading song preview ${preloadItem.challengeId}`);
      this.preloadedAudioIds.push(preloadItem.challengeId);
      this.currentLoadingId = '';

      // Move on to next song in queue if any.
      console.log(`[song-preview] ${this.preloadQueue.length} in queue`);
      if (this.preloadQueue.length && !this.priorityLoadingChallengeId) {
        this.preloadMetadata(this.preloadQueue.shift());
      }
    });

    audio.preload = 'metadata';
    audio.src = preloadItem.src;
    this.currentLoadingId = preloadItem.challengeId;
  },

  stopSong: function () {
    if (!this.audio) {
      return;
    }
    if (this.animation) {
      this.animation.pause();
    }
    if (!this.audio.paused) {
      this.audio.pause();
    }
  },

  playSong: function (challengeId) {
    if (!challengeId) {
      return;
    }
    this.audio = this.audioStore[challengeId];
    this.audio.volume = 0;
    this.volumeTarget.volume = 0;
    this.audio.play();
    this.animation.restart();
    this.updateAnalyser();
  },

  updateAnalyser: function () {
    document.getElementById('introSong').pause();
    document.getElementById('audioanalyser').setAttribute('audioanalyser', 'src', this.audio);
  },

  /**
   * Stop song from preloading.
   */
  clearSong: function (challengeId) {
    let audio = this.audioStore[challengeId];
    audio.preload = 'none';

    // Remove from queue if in there.
    let index;
    for (let i = 0; i < this.preloadQueue.length; i++) {
      if (this.preloadQueue[i].id === challengeId) {
        index = i;
        break;
      }
    }
    if (!index) {
      return;
    }
    this.preloadQueue.splice(i, 1);
  }
});

/**
 * Data component attached to search result for song preview system.
 */
AFRAME.registerComponent('song-preview', {
  schema: {
    challengeId: { type: 'string' },
    previewStartTime: { type: 'number' }
  },

  update: function (oldData) {
    if (oldData.challengeId && this.data.challengeId !== oldData.challengeId) {
      this.el.sceneEl.components['song-preview-system'].clearSong(oldData.challengeId);
    }

    this.el.sceneEl.components['song-preview-system'].queuePreloadSong(this.data.challengeId, this.data.previewStartTime);
  }
});

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

const utils = __webpack_require__(55);

/**
 * Active challenge song / audio.
 */
AFRAME.registerComponent('song', {
  schema: {
    challengeId: { default: '' },
    isPlaying: { default: false }
  },

  init: function () {
    // Use audio element for audioanalyser.
    this.audio = document.createElement('audio');
    this.audio.setAttribute('id', 'song');
    this.el.sceneEl.appendChild(this.audio);
  },

  update: function (oldData) {
    var el = this.el;
    var data = this.data;

    // Changed challenge.
    if (data.challengeId !== oldData.challengeId) {
      let songUrl = utils.getS3FileUrl(data.challengeId, 'song.ogg');
      this.audio.addEventListener('canplaythrough', () => {
        this.audio.currentTime = 0;
      }, false);
      this.audio.src = data.challengeId ? songUrl : '';
    }

    // Keep playback state up to date.
    if (data.isPlaying && data.challengeId && this.audio.paused) {
      console.log(`Playing ${this.audio.src}...`);
      this.audio.play();
      return;
    } else if ((!data.isPlaying || !data.challengeId) && !this.audio.paused) {
      this.audio.pause();
    }
  }
});

/***/ }),
/* 195 */
/***/ (function(module, exports) {

AFRAME.registerComponent('stage-colors', {
  schema: {
    default: 'red',
    oneOf: ['red', 'blue']
  },

  init: function () {
    this.neonRed = new THREE.Color(0xff9999);
    this.neonBlue = new THREE.Color(0x9999ff);
    this.defaultRed = new THREE.Color(0xff0000);
    this.defaultBlue = new THREE.Color(0x0000ff);
    this.mineEnvMap = {
      red: new THREE.TextureLoader().load('assets/img/mineenviro-red.jpg'),
      blue: new THREE.TextureLoader().load('assets/img/mineenviro-blue.jpg')
    };
    this.mineColor = { red: new THREE.Color(0x070304), blue: new THREE.Color(0x030407) };
    this.mineEmission = { red: new THREE.Color(0x090707), blue: new THREE.Color(0x070709) };
    this.mineMaterial = new THREE.MeshStandardMaterial({
      roughness: 0.38,
      metalness: 0.48,
      color: this.mineColor[this.data],
      emissive: this.mineEmission[this.data],
      envMap: this.mineEnvMap[this.data]
    });
  },

  update: function () {
    var red = this.data == 'red';
    document.getElementById('backglow').setAttribute('material', { color: red ? '#f10' : '#00acfc' });
    document.getElementById('sky').setAttribute('material', { color: red ? '#770100' : '#15252d' });
    this.el.sceneEl.setAttribute('fog', { color: red ? '#a00' : '#007cb9' });
    this.el.sceneEl.systems.materials.neon.color = red ? this.neonRed : this.neonBlue;
    this.el.sceneEl.systems.materials.default.color = red ? this.defaultRed : this.defaultBlue;
    this.mineMaterial.color = this.mineColor[this.data];
    this.mineMaterial.emissive = this.mineEmission[this.data];
    this.mineMaterial.envMap = this.mineEnvMap[this.data];
  }

});

/***/ }),
/* 196 */
/***/ (function(module, exports) {

AFRAME.registerComponent('text-uppercase', {
  schema: {
    value: { type: 'string' }
  },

  update: function () {
    this.el.setAttribute('text', 'value', this.data.value.toUpperCase());
  }
});

/***/ }),
/* 197 */
/***/ (function(module, exports) {

AFRAME.registerComponent('toggle-pause-play', {
  schema: {
    isPlaying: { default: false }
  },

  update: function () {
    const action = this.data.isPlaying ? 'pause' : 'play';
    parent.postMessage(JSON.stringify({ verify: 'game-action', action }), '*');
  }
});

/***/ }),
/* 198 */
/***/ (function(module, exports) {

AFRAME.registerComponent('twister', {
  schema: {
    twist: { default: 0 },
    vertices: { default: 4, type: 'int' },
    count: { default: 20, type: 'int' },
    positionIncrement: { default: 2 },
    radiusIncrement: { default: 0.5 },
    thickness: { default: 0.4 }
  },

  init: function () {
    this.currentTwist = 0;
    this.animate = false;
  },

  update: function (oldData) {
    var radius = 4;
    var segment;
    var lastSegment;

    if (Math.abs(this.data.twist - this.currentTwist) > 0.001) {
      this.animate = true;
    }

    this.clearSegments();
    lastSegment = this.el.object3D;

    for (var i = 0; i < this.data.count; i++) {
      segment = this.createSegment(radius);
      segment.position.y = this.data.positionIncrement;
      lastSegment.add(segment);
      lastSegment = segment;
      radius += this.data.radiusIncrement;
    }
  },

  createSegment: function (radius) {
    const R = this.data.thickness;
    var points = [new THREE.Vector2(radius - R, R), new THREE.Vector2(radius - R, -R), new THREE.Vector2(radius + R, -R), new THREE.Vector2(radius + R, R), new THREE.Vector2(radius - R, R)];
    var material = this.el.sceneEl.systems.materials.black;
    var geometry = new THREE.LatheBufferGeometry(points, this.data.vertices);
    var segment = new THREE.Mesh(geometry, material);
    return segment;
  },

  clearSegments: function () {
    this.el.object3D.remove(this.el.object3D.children[0]);
  },

  tick: function (time, delta) {
    if (!this.animate) {
      return;
    }
    if (Math.abs(this.data.twist - this.currentTwist) < 0.001) {
      this.animate = false;
    }

    this.currentTwist += (this.data.twist - this.currentTwist) * delta * 0.001;

    var child = this.el.object3D.children[0];
    while (child) {
      child.rotation.y = this.currentTwist;
      child = child.children[0];
    }
  }
});

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(151);

function requireAll(req) {
  req.keys().forEach(req);
}

__webpack_require__(138);
__webpack_require__(150);
__webpack_require__(139);
__webpack_require__(140);
__webpack_require__(141);
__webpack_require__(142);
__webpack_require__(143);
__webpack_require__(144);
__webpack_require__(146);
__webpack_require__(148);
__webpack_require__(147);
__webpack_require__(149);
__webpack_require__(145);

requireAll(__webpack_require__(152));
requireAll(__webpack_require__(153));

/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = function SoundPool(src, volume) {
  var currSound = 0;
  var i;
  var pool = [];
  var sound;

  sound = new Audio(src);
  sound.volume = volume;
  pool.push(sound);

  return {
    play: function () {
      // Dynamic size pool.
      if (pool[currSound].currentTime !== 0 || !pool[currSound].ended) {
        sound = new Audio(src);
        sound.volume = volume;
        pool.push(sound);
        currSound++;
      }

      if (pool[currSound].currentTime === 0 || pool[currSound].ended) {
        pool[currSound].play();
      }
      currSound = (currSound + 1) % pool.length;
    }
  };
};

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var utils = __webpack_require__(55);

const challengeDataStore = {};
const hasInitialChallenge = !!AFRAME.utils.getUrlParameter('challenge');
const SEARCH_PER_PAGE = 6;

/**
 * State handler.
 *
 * 1. `handlers` is an object of events that when emitted to the scene will run the handler.
 *
 * 2. The handler function modifies the state.
 *
 * 3. Entities and components that are `bind`ed automatically update:
 *    `bind__<componentName>="<propertyName>: some.item.in.state"`
 */
AFRAME.registerState({
  initialState: {
    activeHand: localStorage.getItem('hand') || 'right',
    challenge: {
      author: '',
      difficulty: '',
      id: AFRAME.utils.getUrlParameter('challenge'),
      image: '',
      isLoading: false,
      songName: '',
      songSubName: ''
    },
    inVR: false,
    menu: {
      active: true,
      playButtonText: 'Play'
    },
    menuDifficulties: [],
    menuSelectedChallenge: {
      author: '',
      difficulty: '',
      downloads: '',
      downloadsText: '',
      id: '',
      image: '',
      songName: '',
      songSubName: ''
    },
    score: {
      maxStreak: 0,
      score: 0,
      streak: 0
    },
    search: {
      active: true,
      page: 0,
      hasNext: false,
      hasPrev: false,
      results: []
    },
    searchResultsPage: []
  },

  handlers: {
    /**
     * Swap left-handed or right-handed mode.
     */
    activehandswap: state => {
      state.activeHand = state.activeHand === 'right' ? 'left' : 'right';
      localStorage.setItem('activeHand', state.activeHand);
    },

    beatloaderfinish: state => {
      state.challenge.isLoading = false;
    },

    beatloaderstart: state => {
      state.challenge.isLoading = true;
    },

    /**
     * Song clicked from menu.
     */
    menuchallengeselect: (state, id) => {
      // Copy from challenge store populated from search results.
      let challengeData = challengeDataStore[id];
      Object.assign(state.menuSelectedChallenge, challengeData);

      // Populate difficulty options.
      state.menuDifficulties.length = 0;
      for (let i = 0; i < challengeData.difficulties.length; i++) {
        state.menuDifficulties.unshift(challengeData.difficulties[i]);
      }
      state.menuDifficulties.sort(difficultyComparator);
      // Default to easiest difficulty.
      state.menuSelectedChallenge.difficulty = state.menuDifficulties[0];

      state.menuSelectedChallenge.image = utils.getS3FileUrl(id, 'image.jpg');
      state.menuSelectedChallenge.downloadsText = `${challengeData.downloads} Plays`;
    },

    menudifficultyselect: (state, difficulty) => {
      state.menuSelectedChallenge.difficulty = difficulty;
    },

    pausegame: state => {
      state.menu.active = true;
    },

    /**
     * Start challenge.
     * Transfer staged challenge to the active challenge.
     */
    playbuttonclick: state => {
      // Reset score.
      state.score.maxStreak = 0;
      state.score.score = 0;
      state.score.streak = 0;

      // Set challenge. `beat-loader` is listening.
      Object.assign(state.challenge, state.menuSelectedChallenge);

      // Reset menu.
      state.menu.active = false;
      state.menuSelectedChallenge.id = '';
    },

    searchprevpage: function (state) {
      if (state.search.page === 0) {
        return;
      }
      state.search.page--;
      computeSearchPagination(state);
    },

    searchnextpage: function (state) {
      if (state.search.page > Math.floor(state.search.results.length / SEARCH_PER_PAGE)) {
        return;
      }
      state.search.page++;
      computeSearchPagination(state);
    },

    /**
     * Update search results. Will automatically render using `bind-for` (menu.html).
     */
    searchresults: (state, payload) => {
      var i;
      state.search.page = 0;
      state.search.results = payload.results;
      for (i = 0; i < payload.results.length; i++) {
        let result = payload.results[i];
        result.songSubName = result.songSubName || 'Unknown Artist';
        result.shortSongName = truncate(result.songName, 24).toUpperCase();
        result.shortSongSubName = truncate(result.songSubName, 32);
        challengeDataStore[result.id] = result;
      }
      computeSearchPagination(state);
    },

    'enter-vr': state => {
      state.inVR = true;
    },

    'exit-vr': state => {
      state.inVR = false;
    }
  },

  /**
   * Post-process the state after each action.
   */
  computeState: state => {
    state.leftRaycasterActive = state.menu.active && state.activeHand === 'left' && state.inVR;
    state.rightRaycasterActive = state.menu.active && state.activeHand === 'right' && state.inVR;
  }
});

function computeSearchPagination(state) {
  let numPages = Math.ceil(state.search.results.length / SEARCH_PER_PAGE);
  state.search.hasPrev = state.search.page > 0;
  state.search.hasNext = state.search.page < numPages - 1;

  state.searchResultsPage.length = 0;
  for (i = state.search.page * SEARCH_PER_PAGE; i < state.search.page * SEARCH_PER_PAGE + SEARCH_PER_PAGE; i++) {
    if (!state.search.results[i]) {
      break;
    }
    state.searchResultsPage.push(state.search.results[i]);
  }
}

function truncate(str, length) {
  if (!str) {
    return '';
  }
  if (str.length >= length) {
    return str.substring(0, length - 3) + '...';
  }
  return str;
}

const DIFFICULTIES = ['Easy', 'Normal', 'Hard', 'Expert', 'ExpertPlus'];
function difficultyComparator(a, b) {
  const aIndex = DIFFICULTIES.indexOf(a);
  const bIndex = DIFFICULTIES.indexOf(b);
  if (aIndex < bIndex) {
    return -1;
  }
  if (aIndex > bIndex) {
    return 1;
  }
  return 0;
}

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(209);
module.exports = __webpack_require__(19).RegExp.escape;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var isArray = __webpack_require__(60);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(3);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(26);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(36);
var gOPS = __webpack_require__(64);
var pIE = __webpack_require__(50);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 207 */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};


/***/ }),
/* 208 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0);
var $re = __webpack_require__(207)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(103) });

__webpack_require__(29)('copyWithin');


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $every = __webpack_require__(22)(4);

$export($export.P + $export.F * !__webpack_require__(21)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(72) });

__webpack_require__(29)('fill');


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $filter = __webpack_require__(22)(2);

$export($export.P + $export.F * !__webpack_require__(21)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(22)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(29)(KEY);


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(22)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(29)(KEY);


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $forEach = __webpack_require__(22)(0);
var STRICT = __webpack_require__(21)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(20);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var call = __webpack_require__(114);
var isArrayIter = __webpack_require__(80);
var toLength = __webpack_require__(8);
var createProperty = __webpack_require__(74);
var getIterFn = __webpack_require__(96);

$export($export.S + $export.F * !__webpack_require__(62)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $indexOf = __webpack_require__(56)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(60) });


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(0);
var toIObject = __webpack_require__(17);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(49) != Object || !__webpack_require__(21)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(17);
var toInteger = __webpack_require__(25);
var toLength = __webpack_require__(8);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $map = __webpack_require__(22)(1);

$export($export.P + $export.F * !__webpack_require__(21)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var createProperty = __webpack_require__(74);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(105);

$export($export.P + $export.F * !__webpack_require__(21)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(105);

$export($export.P + $export.F * !__webpack_require__(21)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var html = __webpack_require__(78);
var cof = __webpack_require__(18);
var toAbsoluteIndex = __webpack_require__(40);
var toLength = __webpack_require__(8);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $some = __webpack_require__(22)(3);

$export($export.P + $export.F * !__webpack_require__(21)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var fails = __webpack_require__(3);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(21)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Array');


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(204);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(26);

$export($export.P + $export.F * __webpack_require__(3)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(5)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(205));


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(12)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', { bind: __webpack_require__(106) });


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(16);
var HAS_INSTANCE = __webpack_require__(5)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(7).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(7).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(117);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(84);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(83);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(116) });


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(117) });


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(84) });


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(83);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(83);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var has = __webpack_require__(14);
var cof = __webpack_require__(18);
var inheritIfRequired = __webpack_require__(79);
var toPrimitive = __webpack_require__(26);
var fails = __webpack_require__(3);
var gOPN = __webpack_require__(35).f;
var gOPD = __webpack_require__(15).f;
var dP = __webpack_require__(7).f;
var $trim = __webpack_require__(45).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(34)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(6) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(12)(global, NUMBER, $Number);
}


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(113) });


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(113);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(125);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(126);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toInteger = __webpack_require__(25);
var aNumberValue = __webpack_require__(102);
var repeat = __webpack_require__(91);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $fails = __webpack_require__(3);
var aNumberValue = __webpack_require__(102);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(119) });


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(34) });


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperties: __webpack_require__(120) });


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperty: __webpack_require__(7).f });


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(31).onFreeze;

__webpack_require__(24)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(17);
var $getOwnPropertyDescriptor = __webpack_require__(15).f;

__webpack_require__(24)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(24)('getOwnPropertyNames', function () {
  return __webpack_require__(121).f;
});


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(9);
var $getPrototypeOf = __webpack_require__(16);

__webpack_require__(24)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(4);

__webpack_require__(24)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(208) });


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(9);
var $keys = __webpack_require__(36);

__webpack_require__(24)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(31).onFreeze;

__webpack_require__(24)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(31).onFreeze;

__webpack_require__(24)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(87).set });


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(48);
var test = {};
test[__webpack_require__(5)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(12)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(125);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(126);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(30);
var global = __webpack_require__(2);
var ctx = __webpack_require__(20);
var classof = __webpack_require__(48);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var aFunction = __webpack_require__(10);
var anInstance = __webpack_require__(32);
var forOf = __webpack_require__(33);
var speciesConstructor = __webpack_require__(68);
var task = __webpack_require__(93).set;
var microtask = __webpack_require__(85)();
var newPromiseCapabilityModule = __webpack_require__(86);
var perform = __webpack_require__(127);
var userAgent = __webpack_require__(70);
var promiseResolve = __webpack_require__(128);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(5)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(38)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(44)($Promise, PROMISE);
__webpack_require__(39)(PROMISE);
Wrapper = __webpack_require__(19)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(62)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var rApply = (__webpack_require__(2).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(34);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var bind = __webpack_require__(106);
var rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(7);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(26);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(15).f;
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(81)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(15);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(16);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(15);
var getPrototypeOf = __webpack_require__(16);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(124) });


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(87);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(7);
var gOPD = __webpack_require__(15);
var getPrototypeOf = __webpack_require__(16);
var has = __webpack_require__(14);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(37);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var inheritIfRequired = __webpack_require__(79);
var dP = __webpack_require__(7).f;
var gOPN = __webpack_require__(35).f;
var isRegExp = __webpack_require__(61);
var $flags = __webpack_require__(59);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(3)(function () {
  re2[__webpack_require__(5)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(12)(global, 'RegExp', $RegExp);
}

__webpack_require__(39)('RegExp');


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(58)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(58)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(58)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(58)('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = __webpack_require__(61);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(133);
var anObject = __webpack_require__(1);
var $flags = __webpack_require__(59);
var DESCRIPTORS = __webpack_require__(6);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(12)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(3)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(13)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(13)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(13)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(13)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $at = __webpack_require__(89)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(8);
var context = __webpack_require__(90);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(77)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(13)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(13)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(13)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(40);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(90);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(77)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(13)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(89)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(82)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(13)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(17);
var toLength = __webpack_require__(8);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(91)
});


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(13)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(8);
var context = __webpack_require__(90);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(77)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(13)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(13)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(13)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(45)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(2);
var has = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(6);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(12);
var META = __webpack_require__(31).KEY;
var $fails = __webpack_require__(3);
var shared = __webpack_require__(67);
var setToStringTag = __webpack_require__(44);
var uid = __webpack_require__(41);
var wks = __webpack_require__(5);
var wksExt = __webpack_require__(131);
var wksDefine = __webpack_require__(95);
var enumKeys = __webpack_require__(206);
var isArray = __webpack_require__(60);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var toIObject = __webpack_require__(17);
var toPrimitive = __webpack_require__(26);
var createDesc = __webpack_require__(37);
var _create = __webpack_require__(34);
var gOPNExt = __webpack_require__(121);
var $GOPD = __webpack_require__(15);
var $DP = __webpack_require__(7);
var $keys = __webpack_require__(36);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(35).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(50).f = $propertyIsEnumerable;
  __webpack_require__(64).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(30)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $typed = __webpack_require__(69);
var buffer = __webpack_require__(94);
var anObject = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(40);
var toLength = __webpack_require__(8);
var isObject = __webpack_require__(4);
var ArrayBuffer = __webpack_require__(2).ArrayBuffer;
var speciesConstructor = __webpack_require__(68);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(39)(ARRAY_BUFFER);


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(69).ABV, {
  DataView: __webpack_require__(94).DataView
});


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(28)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(109);
var validate = __webpack_require__(46);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(57)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(110);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(8);
var aFunction = __webpack_require__(10);
var arraySpeciesCreate = __webpack_require__(73);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(29)('flatMap');


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(110);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(8);
var toInteger = __webpack_require__(25);
var arraySpeciesCreate = __webpack_require__(73);

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(29)('flatten');


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(0);
var $includes = __webpack_require__(56)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(29)('includes');


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(0);
var microtask = __webpack_require__(85)();
var process = __webpack_require__(2).process;
var isNode = __webpack_require__(18)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0);
var cof = __webpack_require__(18);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.G, { global: __webpack_require__(2) });


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(65)('Map');


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(66)('Map');


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(108)('Map') });


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var scale = __webpack_require__(118);
var fround = __webpack_require__(116);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { scale: __webpack_require__(118) });


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(0);

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(7);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(6) && $export($export.P + __webpack_require__(63), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(7);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(6) && $export($export.P + __webpack_require__(63), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(123)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(124);
var toIObject = __webpack_require__(17);
var gOPD = __webpack_require__(15);
var createProperty = __webpack_require__(74);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(26);
var getPrototypeOf = __webpack_require__(16);
var getOwnPropertyDescriptor = __webpack_require__(15).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(6) && $export($export.P + __webpack_require__(63), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(26);
var getPrototypeOf = __webpack_require__(16);
var getOwnPropertyDescriptor = __webpack_require__(15).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(6) && $export($export.P + __webpack_require__(63), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(123)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export = __webpack_require__(0);
var global = __webpack_require__(2);
var core = __webpack_require__(19);
var microtask = __webpack_require__(85)();
var OBSERVABLE = __webpack_require__(5)('observable');
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var anInstance = __webpack_require__(32);
var redefineAll = __webpack_require__(38);
var hide = __webpack_require__(11);
var forOf = __webpack_require__(33);
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

__webpack_require__(39)('Observable');


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(0);
var core = __webpack_require__(19);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(68);
var promiseResolve = __webpack_require__(128);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(0);
var newPromiseCapability = __webpack_require__(86);
var perform = __webpack_require__(127);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(134);
var from = __webpack_require__(104);
var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(16);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(16);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(16);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(27);
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(65)('Set');


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(66)('Set');


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(108)('Set') });


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0);
var $at = __webpack_require__(89)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export = __webpack_require__(0);
var defined = __webpack_require__(23);
var toLength = __webpack_require__(8);
var isRegExp = __webpack_require__(61);
var getFlags = __webpack_require__(59);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(81)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(129);
var userAgent = __webpack_require__(70);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(129);
var userAgent = __webpack_require__(70);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(45)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(45)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(95)('asyncIterator');


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(95)('observable');


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', { global: __webpack_require__(2) });


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(65)('WeakMap');


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(66)('WeakMap');


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(65)('WeakSet');


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(66)('WeakSet');


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(97);
var getKeys = __webpack_require__(36);
var redefine = __webpack_require__(12);
var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var Iterators = __webpack_require__(43);
var wks = __webpack_require__(5);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $task = __webpack_require__(93);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var userAgent = __webpack_require__(70);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(329);
__webpack_require__(268);
__webpack_require__(270);
__webpack_require__(269);
__webpack_require__(272);
__webpack_require__(274);
__webpack_require__(279);
__webpack_require__(273);
__webpack_require__(271);
__webpack_require__(281);
__webpack_require__(280);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(275);
__webpack_require__(267);
__webpack_require__(278);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(235);
__webpack_require__(237);
__webpack_require__(236);
__webpack_require__(285);
__webpack_require__(284);
__webpack_require__(255);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(316);
__webpack_require__(321);
__webpack_require__(328);
__webpack_require__(319);
__webpack_require__(311);
__webpack_require__(312);
__webpack_require__(317);
__webpack_require__(322);
__webpack_require__(324);
__webpack_require__(307);
__webpack_require__(308);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(315);
__webpack_require__(318);
__webpack_require__(320);
__webpack_require__(323);
__webpack_require__(325);
__webpack_require__(326);
__webpack_require__(327);
__webpack_require__(230);
__webpack_require__(232);
__webpack_require__(231);
__webpack_require__(234);
__webpack_require__(233);
__webpack_require__(219);
__webpack_require__(217);
__webpack_require__(223);
__webpack_require__(220);
__webpack_require__(226);
__webpack_require__(228);
__webpack_require__(216);
__webpack_require__(222);
__webpack_require__(213);
__webpack_require__(227);
__webpack_require__(211);
__webpack_require__(225);
__webpack_require__(224);
__webpack_require__(218);
__webpack_require__(221);
__webpack_require__(210);
__webpack_require__(212);
__webpack_require__(215);
__webpack_require__(214);
__webpack_require__(229);
__webpack_require__(97);
__webpack_require__(301);
__webpack_require__(306);
__webpack_require__(133);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(286);
__webpack_require__(132);
__webpack_require__(134);
__webpack_require__(135);
__webpack_require__(341);
__webpack_require__(330);
__webpack_require__(331);
__webpack_require__(336);
__webpack_require__(339);
__webpack_require__(340);
__webpack_require__(334);
__webpack_require__(337);
__webpack_require__(335);
__webpack_require__(338);
__webpack_require__(332);
__webpack_require__(333);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(294);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(299);
__webpack_require__(344);
__webpack_require__(342);
__webpack_require__(343);
__webpack_require__(385);
__webpack_require__(388);
__webpack_require__(387);
__webpack_require__(389);
__webpack_require__(390);
__webpack_require__(386);
__webpack_require__(391);
__webpack_require__(392);
__webpack_require__(366);
__webpack_require__(369);
__webpack_require__(365);
__webpack_require__(363);
__webpack_require__(364);
__webpack_require__(367);
__webpack_require__(368);
__webpack_require__(350);
__webpack_require__(384);
__webpack_require__(349);
__webpack_require__(383);
__webpack_require__(395);
__webpack_require__(397);
__webpack_require__(348);
__webpack_require__(382);
__webpack_require__(394);
__webpack_require__(396);
__webpack_require__(347);
__webpack_require__(393);
__webpack_require__(346);
__webpack_require__(351);
__webpack_require__(352);
__webpack_require__(353);
__webpack_require__(354);
__webpack_require__(355);
__webpack_require__(357);
__webpack_require__(356);
__webpack_require__(358);
__webpack_require__(359);
__webpack_require__(360);
__webpack_require__(362);
__webpack_require__(361);
__webpack_require__(371);
__webpack_require__(372);
__webpack_require__(373);
__webpack_require__(374);
__webpack_require__(376);
__webpack_require__(375);
__webpack_require__(378);
__webpack_require__(377);
__webpack_require__(379);
__webpack_require__(380);
__webpack_require__(381);
__webpack_require__(345);
__webpack_require__(370);
__webpack_require__(400);
__webpack_require__(399);
__webpack_require__(398);
module.exports = __webpack_require__(19);


/***/ }),
/* 402 */
/***/ (function(module, exports) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4+314e4831
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    return promise.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        throw reason;
      });
    });
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(137), __webpack_require__(52)))

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52)))

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = __webpack_require__(406);
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$applicationCache: true,
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 408 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2QxYTc0NzQzMTg0ODc5Y2Q5ODEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Nsb25lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZvcmVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWJ1Zy9icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191c2VyLWFnZW50LmpzIiwid2VicGFjazovLy8uL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUtZXZlbnQtZGVjb3JhdG9ycy9jb21wb25lbnQtZGVjb3JhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1ldmVudC1kZWNvcmF0b3JzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnVpbGRTZWFyY2hNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9vbWl0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mbGF0dGVuLWludG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUtYW5pbWF0aW9uLWNvbXBvbmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1jdWJlbWFwLWNvbXBvbmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1ldmVudC1zZXQtY29tcG9uZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWZyYW1lLWhhcHRpY3MtY29tcG9uZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWZyYW1lLWxheW91dC1jb21wb25lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUtb3JiaXQtY29udHJvbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUtcGFydGljbGUtc3lzdGVtLWNvbXBvbmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1wYXJ0aWNsZXBsYXllci1jb21wb25lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUtcHJveHktZXZlbnQtY29tcG9uZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWZyYW1lLXNsaWNlOS1jb21wb25lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUtc3RhdGUtY29tcG9uZW50L2Rpc3QvYWZyYW1lLXN0YXRlLWNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1zdXBlci1rZXlib2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4va2ZyYW1lL2NvbXBvbmVudHMvYXVkaW9hbmFseXNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cyBcXC5qcyQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXRlIFxcLmpzJCIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1ldmVudC1kZWNvcmF0b3JzL2V2ZW50LWJpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1vcmJpdC1jb250cm9scy9saWIvT3JiaXRDb250cm9scy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmcmFtZS1wYXJ0aWNsZS1zeXN0ZW0tY29tcG9uZW50L2xpYi9TUEUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUtc3VwZXIta2V5Ym9hcmQva2V5Ym9hcmRzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaENvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleENvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2J1aWxkcy9hbGdvbGlhc2VhcmNoTGl0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvY3JlYXRlQWxnb2xpYXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvaW5saW5lLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2pzb25wLXJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9kZXByZWNhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9kZXByZWNhdGVkTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2V4aXRQcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9wbGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmltZWpzL2FuaW1lLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9hY3RpdmUtY29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvYW5hbHl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvYmVhdC1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY29uc29sZS1zaG9ydGN1dHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY3Vyc29yLW1lc2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGVidWctY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kZWJ1Zy1jdXJzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvaGFuZC1zd2FwcGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMva2V5Ym9hcmQtcmF5Y2FzdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbG9nb2ZsaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWF0ZXJpYWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lbnUtZGlmZmljdWx0eS1zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVudS1zZWxlY3RlZC1jaGFsbGVuZ2UtaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvcGF1c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3BsYXktc291bmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvcHJlbG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3JheWNhc3RhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3JlY2VudGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3NhYmVyLWNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3NlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zb25nLXByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvc29uZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zdGFnZS1jb2xvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdGV4dC11cHBlcmNhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdG9nZ2xlLXBhdXNlLXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdHdpc3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9zb3VuZHBvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWdyZWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWRpYW5zLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQub2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAub2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vZ2xvYmFsL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9+L29iamVjdC1rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIl0sIm5hbWVzIjpbIkJBU0VfVVJMIiwiZ2V0UzNGaWxlVXJsIiwiaWQiLCJuYW1lIiwibW9kdWxlIiwiZXhwb3J0cyIsIkFGUkFNRSIsIkVycm9yIiwiY29udGV4dCIsInJlZ2lzdGVyU3lzdGVtIiwiaW5pdCIsImFuYWx5c2VycyIsImdldE9yQ3JlYXRlQW5hbHlzZXIiLCJkYXRhIiwiQXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJjcmVhdGVBbmFseXNlciIsImF1ZGlvRWwiLCJzcmMiLCJnZXRBdHRyaWJ1dGUiLCJzb3VyY2UiLCJjcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UiLCJjb25uZWN0IiwiZGVzdGluYXRpb24iLCJzbW9vdGhpbmdUaW1lQ29uc3RhbnQiLCJmZnRTaXplIiwicmVnaXN0ZXJDb21wb25lbnQiLCJzY2hlbWEiLCJlbmFibGVCZWF0RGV0ZWN0aW9uIiwiZGVmYXVsdCIsImVuYWJsZUxldmVscyIsImVuYWJsZVdhdmVmb3JtIiwiZW5hYmxlVm9sdW1lIiwidHlwZSIsInVuaXF1ZSIsImxldmVscyIsIndhdmVmb3JtIiwidm9sdW1lIiwidXBkYXRlIiwic2VsZiIsInN5c3RlbSIsIlVpbnQ4QXJyYXkiLCJmcmVxdWVuY3lCaW5Db3VudCIsImVsIiwiZW1pdCIsInRpY2siLCJnZXRCeXRlRnJlcXVlbmN5RGF0YSIsImdldEJ5dGVUaW1lRG9tYWluRGF0YSIsInN1bSIsImkiLCJsZW5ndGgiLCJCRUFUX0RFQ0FZX1JBVEUiLCJCRUFUX0hPTEQiLCJCRUFUX01JTiIsImJlYXRDdXRPZmYiLCJjb25zb2xlIiwibG9nIiwiYmVhdFRpbWUiLCJNYXRoIiwibWF4IiwiZGVwZW5kZW5jaWVzIiwiYWN0aXZlIiwiY29sb3IiLCJkZWZhdWx0Q29sb3IiLCJzZXRBdHRyaWJ1dGUiLCJjb21wb25lbnRzIiwiYW5pbWF0aW9uX19tb3VzZWxlYXZlIiwic2V0VGltZW91dCIsImhlaWdodCIsInRoaWNrbmVzcyIsInNlcGFyYXRpb24iLCJzY2FsZSIsIm1pcnJvciIsImF1ZGlvYW5hbHlzZXIiLCJjb2x1bW5zIiwibWF0ZXJpYWwiLCJzY2VuZUVsIiwic3lzdGVtcyIsIm1hdGVyaWFscyIsImJsYWNrIiwiZ2VvbWV0cnkiLCJUSFJFRSIsIkJveEJ1ZmZlckdlb21ldHJ5Iiwic2lkZSIsImNvbHVtbiIsIk1lc2giLCJvYmplY3QzRCIsImFkZCIsImNoaWxkcmVuIiwieiIsInBvc2l0aW9uIiwieCIsInNldCIsInYiLCJuIiwieSIsInV0aWxzIiwicmVxdWlyZSIsImNoYWxsZW5nZUlkIiwiZGlmZmljdWx0eSIsImxvYWRCZWF0cyIsInhociIsInVybCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVCZWF0cyIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJiZWF0RGF0YSIsInVwZGF0ZVF1ZXJ5UGFyYW0iLCJ1cmkiLCJrZXkiLCJ2YWx1ZSIsInJlIiwiUmVnRXhwIiwic2VwYXJhdG9yIiwiaW5kZXhPZiIsIm1hdGNoIiwicmVwbGFjZSIsInBsYXkiLCJ3aW5kb3ciLCIkIiwidmFsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiJCQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiJCQkIiwiJCQkJCIsInNjZW5lIiwic3RhdGUiLCJjdXJzb3JFbCIsInNjZW5lUGl2b3RFbCIsImdldEVsZW1lbnRCeUlkIiwiY3Vyc29yIiwiaW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0ZWRFbCIsImludGVyc2VjdGlvblBvaW50IiwidmlzaWJsZSIsInJheWNhc3RlciIsImdldEludGVyc2VjdGlvbiIsImNvcHkiLCJwb2ludCIsInJvdGF0aW9uIiwicHJpbWFyeUhhbmQiLCJzZWNvbmRhcnlIYW5kIiwiZ2V0VXJsUGFyYW1ldGVyIiwiaXNDbG9uaW5nIiwiaXNEZWxldGluZyIsImlzVHJpZ2dlckRvd24iLCJldnQiLCJwcmltYXJ5UG9zaXRpb24iLCJwcmltYXJ5Um90YXRpb24iLCJzZWNvbmRhcnlQb3NpdGlvbiIsInNlY29uZGFyeVJvdGF0aW9uIiwic2hpZnRLZXkiLCJrZXlDb2RlIiwiaXNTZWNvbmRhcnlUcmlnZ2VyRG93biIsInNlY29uZGFyeUdyaXBEb3duIiwicHJpbWFyeUdyaXBEb3duIiwiY3RybEtleSIsImNsb25lIiwiZGV0YWlsIiwiZXZlbnQiLCJldmVudHMiLCJlbmFibGVkIiwic3dhcEhhbmQiLCJiaW5kIiwiZm9yRWFjaCIsInNvbmdOYW1lIiwic29uZ1N1Yk5hbWUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwibG9jYXRpb24iLCJocmVmIiwidGl0bGUiLCJrYkltZyIsImRlbGF5Iiwic2V0T2ZmIiwic2V0T24iLCJDb2xvciIsInNldFN0eWxlIiwidGV4dCIsImNvbG9yVW5pZm9ybSIsInVuaWZvcm1zIiwic3BhcmtzIiwic3BhcmtQb3NpdGlvbnMiLCJWZWN0b3IzIiwiciIsImciLCJiIiwibmVlZHNVcGRhdGUiLCJmbG9vciIsInJhbmRvbSIsIk1lc2hMYW1iZXJ0TWF0ZXJpYWwiLCJmbGF0U2hhZGluZyIsIm5lb24iLCJNZXNoQmFzaWNNYXRlcmlhbCIsImZvZyIsIm9uZU9mIiwidHJhdmVyc2UiLCJvIiwiYmluZEV2ZW50IiwibGF5b3V0IiwiY2xpY2siLCJ0YXJnZXQiLCJjbG9zZXN0IiwiZGF0YXNldCIsInNlbGVjdGVkQ2hhbGxlbmdlSWQiLCJzZWFyY2hSZXN1bHRFbHMiLCJpbWFnZUVsIiwiZ2V0T2JqZWN0M0QiLCJtYXAiLCJwYXVzZUdhbWUiLCJTb3VuZFBvb2wiLCJsYXN0U291bmRQbGF5ZWQiLCJsYXN0U291bmRQbGF5ZWRUaW1lIiwicG9vbHMiLCJjcmVhdGVQb29sIiwic291bmQiLCJwbGF5U291bmQiLCJsYXN0U291bmRUaW1lIiwidGltZSIsIm11bHRpcGxlIiwic3RhcnRzV2l0aCIsInByZWxvYWRGb250IiwicHJlbG9hZEtleWJvYXJkIiwidGV4dHVyZSIsInByZWxvYWRUZXh0dXJlIiwia2JkIiwibm9kZSIsInJlbmRlcmVyIiwic2V0VGV4dHVyZTJEIiwibWF0cml4IiwiTWF0cml4NCIsImZydXN0dW0iLCJGcnVzdHVtIiwicm90YXRpb25PZmZzZXQiLCJldWxlciIsIkV1bGVyIiwib3JkZXIiLCJtZW51UG9zaXRpb24iLCJyZWNlbnRlciIsImNoZWNrSW5WaWV3QWZ0ZXJSZWNlbnRlciIsInNldEZyb21Sb3RhdGlvbk1hdHJpeCIsImNhbWVyYSIsIm1hdHJpeFdvcmxkIiwiYm90dG9tVmVjMyIsInRvcFZlYzMiLCJ1cGRhdGVNYXRyaXgiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsInNldEZyb21NYXRyaXgiLCJtdWx0aXBseU1hdHJpY2VzIiwicHJvamVjdGlvbk1hdHJpeCIsIm1hdHJpeFdvcmxkSW52ZXJzZSIsInNldEZyb21NYXRyaXhQb3NpdGlvbiIsImNvbnRhaW5zUG9pbnQiLCJQSSIsInJlbW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kIiwiYmxhZGVFbmFibGVkIiwiY29sb3JzIiwicmlnaHQiLCJsZWZ0IiwiaW5pdFNhYmVyIiwibW9kZWwiLCJibGFkZUVsIiwiYmxhZGVFbFBpdm90IiwiYm91bmRpbmdCb3giLCJzZXRGcm9tT2JqZWN0Iiwic2FiZXJIYW5kbGVFbCIsImNyZWF0ZUVsZW1lbnQiLCJzYWJlclBpdm90RWwiLCJoaWdobGlnaHRUb3AiLCJoaWdobGlnaHRCb3R0b20iLCJjb250cm9sbGVyQ29uZmlnIiwiY29uZmlnIiwiQm94MyIsInNoYWRlciIsInByaW1pdGl2ZSIsImRlcHRoIiwid2lkdGgiLCJhcHBlbmRDaGlsZCIsImNvbnRyb2xsZXJDb25uZWN0ZWQiLCJjb250cm9sbGVyVHlwZSIsImRvd25FdmVudHMiLCJ1cEV2ZW50cyIsImFsZ29saWFzZWFyY2giLCJjbGllbnQiLCJhbGdvbGlhIiwiaW5pdEluZGV4IiwiZXZlbnREZXRhaWwiLCJyZXN1bHRzIiwicG9wdWxhckhpdHMiLCJxdWVyeU9iamVjdCIsImhpdHNQZXJQYWdlIiwicXVlcnkiLCJzZWFyY2giLCJzdXBlcmtleWJvYXJkY2hhbmdlIiwiZXJyIiwiY29udGVudCIsImhpdHMiLCJtYXRlcmlhbFVwZGF0ZU9iaiIsImF1ZGlvIiwiYXVkaW9TdG9yZSIsInByZWxvYWRlZEF1ZGlvSWRzIiwicHJlbG9hZFF1ZXVlIiwidm9sdW1lVGFyZ2V0IiwiYW5pbWF0aW9uIiwiYW5pbWUiLCJ0YXJnZXRzIiwiZHVyYXRpb24iLCJlYXNpbmciLCJhdXRvcGxheSIsImxvb3AiLCJvbGREYXRhIiwic3RvcFNvbmciLCJpbmNsdWRlcyIsImN1cnJlbnRMb2FkaW5nSWQiLCJwcmlvcml0aXplUHJlbG9hZFNvbmciLCJwbGF5U29uZyIsInByaW9yaXR5TG9hZGluZ0NoYWxsZW5nZUlkIiwicHVzaCIsInByZWxvYWRNZXRhZGF0YSIsInNwbGljZSIsInF1ZXVlUHJlbG9hZFNvbmciLCJwcmV2aWV3U3RhcnRUaW1lIiwiY3Jvc3NPcmlnaW4iLCJwcmVsb2FkSXRlbSIsInNoaWZ0IiwicHJlbG9hZCIsInBhdXNlIiwicGF1c2VkIiwicmVzdGFydCIsInVwZGF0ZUFuYWx5c2VyIiwiY2xlYXJTb25nIiwiaW5kZXgiLCJpc1BsYXlpbmciLCJzb25nVXJsIiwiY3VycmVudFRpbWUiLCJuZW9uUmVkIiwibmVvbkJsdWUiLCJkZWZhdWx0UmVkIiwiZGVmYXVsdEJsdWUiLCJtaW5lRW52TWFwIiwicmVkIiwiVGV4dHVyZUxvYWRlciIsImxvYWQiLCJibHVlIiwibWluZUNvbG9yIiwibWluZUVtaXNzaW9uIiwibWluZU1hdGVyaWFsIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJyb3VnaG5lc3MiLCJtZXRhbG5lc3MiLCJlbWlzc2l2ZSIsImVudk1hcCIsInRvVXBwZXJDYXNlIiwiYWN0aW9uIiwicGFyZW50IiwicG9zdE1lc3NhZ2UiLCJzdHJpbmdpZnkiLCJ2ZXJpZnkiLCJ0d2lzdCIsInZlcnRpY2VzIiwiY291bnQiLCJwb3NpdGlvbkluY3JlbWVudCIsInJhZGl1c0luY3JlbWVudCIsImN1cnJlbnRUd2lzdCIsImFuaW1hdGUiLCJyYWRpdXMiLCJzZWdtZW50IiwibGFzdFNlZ21lbnQiLCJhYnMiLCJjbGVhclNlZ21lbnRzIiwiY3JlYXRlU2VnbWVudCIsIlIiLCJwb2ludHMiLCJWZWN0b3IyIiwiTGF0aGVCdWZmZXJHZW9tZXRyeSIsImRlbHRhIiwiY2hpbGQiLCJyZXF1aXJlQWxsIiwicmVxIiwia2V5cyIsImN1cnJTb3VuZCIsInBvb2wiLCJBdWRpbyIsImVuZGVkIiwiY2hhbGxlbmdlRGF0YVN0b3JlIiwiaGFzSW5pdGlhbENoYWxsZW5nZSIsIlNFQVJDSF9QRVJfUEFHRSIsInJlZ2lzdGVyU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJhY3RpdmVIYW5kIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNoYWxsZW5nZSIsImF1dGhvciIsImltYWdlIiwiaXNMb2FkaW5nIiwiaW5WUiIsIm1lbnUiLCJwbGF5QnV0dG9uVGV4dCIsIm1lbnVEaWZmaWN1bHRpZXMiLCJtZW51U2VsZWN0ZWRDaGFsbGVuZ2UiLCJkb3dubG9hZHMiLCJkb3dubG9hZHNUZXh0Iiwic2NvcmUiLCJtYXhTdHJlYWsiLCJzdHJlYWsiLCJwYWdlIiwiaGFzTmV4dCIsImhhc1ByZXYiLCJzZWFyY2hSZXN1bHRzUGFnZSIsImhhbmRsZXJzIiwiYWN0aXZlaGFuZHN3YXAiLCJzZXRJdGVtIiwiYmVhdGxvYWRlcmZpbmlzaCIsImJlYXRsb2FkZXJzdGFydCIsIm1lbnVjaGFsbGVuZ2VzZWxlY3QiLCJjaGFsbGVuZ2VEYXRhIiwiT2JqZWN0IiwiYXNzaWduIiwiZGlmZmljdWx0aWVzIiwidW5zaGlmdCIsInNvcnQiLCJkaWZmaWN1bHR5Q29tcGFyYXRvciIsIm1lbnVkaWZmaWN1bHR5c2VsZWN0IiwicGF1c2VnYW1lIiwicGxheWJ1dHRvbmNsaWNrIiwic2VhcmNocHJldnBhZ2UiLCJjb21wdXRlU2VhcmNoUGFnaW5hdGlvbiIsInNlYXJjaG5leHRwYWdlIiwic2VhcmNocmVzdWx0cyIsInBheWxvYWQiLCJyZXN1bHQiLCJzaG9ydFNvbmdOYW1lIiwidHJ1bmNhdGUiLCJzaG9ydFNvbmdTdWJOYW1lIiwiY29tcHV0ZVN0YXRlIiwibGVmdFJheWNhc3RlckFjdGl2ZSIsInJpZ2h0UmF5Y2FzdGVyQWN0aXZlIiwibnVtUGFnZXMiLCJjZWlsIiwic3RyIiwic3Vic3RyaW5nIiwiRElGRklDVUxUSUVTIiwiYSIsImFJbmRleCIsImJJbmRleCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIs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QUFLO0FBQ0wsd0VBQXdFO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx5QkFBeUIsc0JBQXNCLEVBQUUsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7QUN0S0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVB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Q0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLHFFQUFxRTtBQUNyRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ1hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQkE7QUFDQTs7QUFFQTs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNkQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakIsR0FBRztBQUNIOzs7Ozs7O0FDWEE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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R0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3RDQTtBQUNBLHFFQUFzRSxtQkFBbUIsVUFBVSxFQUFFLEVBQUU7QUFDdkcsQ0FBQzs7Ozs7OztBQ0ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0EsVUFBVTtBQUNWOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVLEVBQUU7QUFDaEQsbUJBQW1CLHNDQUFzQztBQUN6RCxDQUFDLHFDQUFxQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7OztBQ2pDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ1BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNSRDtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSCxZQUFZO0FBQ1o7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtRUFBbUU7QUFDNUYsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ2xCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDSkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtRUFBbUU7QUFDNUYsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw0RUFBNEUsRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOzs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qjs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qjs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RDs7Ozs7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RUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7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LGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGNBQWM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7OztBQUlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RCw2RUFBNkU7O0FBRTdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLFFBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxxQkFBcUI7QUFDaEMs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OztBQUUzRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxtQkFBbUI7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFlBQVk7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDeE9BOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDZEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0hBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7O0FDbEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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SC9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDWEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDckJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ2xCRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDVEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDM0JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUN0QkQ7Ozs7Ozs7QUNBQTtBQUNBOztBQUVBLDRCQUE0QixtQkFBbUIsNkJBQTZCLEVBQUUsRUFB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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7Ozs7Ozs7O0FDdEVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUFxQyx3QkFBd0IsMEJBQTBCLFlBQVksRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ1JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ25CRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN0QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ05EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixjQUFjO0FBQ2Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7Ozs7Ozs7QUNoQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ05EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7Ozs7OztBQ2pCRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ0xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNqQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQSxDQUFDLEVBQUU7Ozs7Ozs7QUNsQkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQSxDQUFDLEVBQUU7Ozs7Ozs7QUNoQkg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0EsQ0FBQyxFQUFFOzs7Ozs7O0FDUEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQSxDQUFDLEVBQUU7Ozs7Ozs7QUNSSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQSxDQUFDLEVBQUU7Ozs7Ozs7QUNmSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLENBQUMsRUFBRTs7Ozs7OztBQ1JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOzs7Ozs7O0FDZEg7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBOztBQUVBLHVDQUF1QywwQ0FBa0Q7Ozs7Ozs7O0FDSHpGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDN0JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDWEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNORDs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTs7QUFFQSw4QkFBOEIsaUNBQStCOzs7Ozs7O0FDSDdEO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELHdCQUF3QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNMRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDbkJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsT0FBTztBQUNqQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IiLCJmaWxlIjoiYnVpbGQvYnVpbGQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxOTkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDdkMWE3NDc0MzE4NDg3OWNkOTgxIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBxdW90ID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS43JyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWFwID0gcmVxdWlyZSgnLi9lczYubWFwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpO1xudmFyIHN0b3JlID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKCkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKSB7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZiAoIXRhcmdldE1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZiAoIWtleU1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgaWYgKG1ldGFkYXRhTWFwKSBtZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChfLCBrZXkpIHsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG52YXIgZXhwID0gZnVuY3Rpb24gKE8pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNwYWNlcyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xudmFyIHNwYWNlID0gJ1snICsgc3BhY2VzICsgJ10nO1xudmFyIG5vbiA9ICdcXHUyMDBiXFx1MDA4NSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBBTElBUykge1xuICB2YXIgZXhwID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYgKEFMSUFTKSBleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24gKHN0cmluZywgVFlQRSkge1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvcmVhY2gvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVidWcvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBob3N0cyBvdXIgZXJyb3IgZGVmaW5pdGlvbnNcbi8vIFdlIHVzZSBjdXN0b20gZXJyb3IgXCJ0eXBlc1wiIHNvIHRoYXQgd2UgY2FuIGFjdCBvbiB0aGVtIHdoZW4gd2UgbmVlZCBpdFxuLy8gZS5nLjogaWYgZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuVW5wYXJzYWJsZUpTT04gdGhlbi4uXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmZ1bmN0aW9uIEFsZ29saWFTZWFyY2hFcnJvcihtZXNzYWdlLCBleHRyYVByb3BlcnRpZXMpIHtcbiAgdmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbiAgdmFyIGVycm9yID0gdGhpcztcblxuICAvLyB0cnkgdG8gZ2V0IGEgc3RhY2t0cmFjZVxuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3Iuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICdDYW5ub3QgZ2V0IGEgc3RhY2t0cmFjZSwgYnJvd3NlciBpcyB0b28gb2xkJztcbiAgfVxuXG4gIHRoaXMubmFtZSA9ICdBbGdvbGlhU2VhcmNoRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJztcblxuICBpZiAoZXh0cmFQcm9wZXJ0aWVzKSB7XG4gICAgZm9yRWFjaChleHRyYVByb3BlcnRpZXMsIGZ1bmN0aW9uIGFkZFRvRXJyb3JPYmplY3QodmFsdWUsIGtleSkge1xuICAgICAgZXJyb3Jba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG59XG5cbmluaGVyaXRzKEFsZ29saWFTZWFyY2hFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXN0b21FcnJvcihuYW1lLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIEFsZ29saWFTZWFyY2hDdXN0b21FcnJvcigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAvLyBjdXN0b20gbWVzc2FnZSBub3Qgc2V0LCB1c2UgZGVmYXVsdFxuICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGFyZ3MudW5zaGlmdChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBBbGdvbGlhU2VhcmNoRXJyb3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdGhpcy5uYW1lID0gJ0FsZ29saWFTZWFyY2gnICsgbmFtZSArICdFcnJvcic7XG4gIH1cblxuICBpbmhlcml0cyhBbGdvbGlhU2VhcmNoQ3VzdG9tRXJyb3IsIEFsZ29saWFTZWFyY2hFcnJvcik7XG5cbiAgcmV0dXJuIEFsZ29saWFTZWFyY2hDdXN0b21FcnJvcjtcbn1cblxuLy8gbGF0ZSBleHBvcnRzIHRvIGxldCB2YXJpb3VzIGZuIGRlZnMgYW5kIGluaGVyaXRzIHRha2UgcGxhY2Vcbm1vZHVsZS5leHBvcnRzID0ge1xuICBBbGdvbGlhU2VhcmNoRXJyb3I6IEFsZ29saWFTZWFyY2hFcnJvcixcbiAgVW5wYXJzYWJsZUpTT046IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdVbnBhcnNhYmxlSlNPTicsXG4gICAgJ0NvdWxkIG5vdCBwYXJzZSB0aGUgaW5jb21pbmcgcmVzcG9uc2UgYXMgSlNPTiwgc2VlIGVyci5tb3JlIGZvciBkZXRhaWxzJ1xuICApLFxuICBSZXF1ZXN0VGltZW91dDogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ1JlcXVlc3RUaW1lb3V0JyxcbiAgICAnUmVxdWVzdCB0aW1lZG91dCBiZWZvcmUgZ2V0dGluZyBhIHJlc3BvbnNlJ1xuICApLFxuICBOZXR3b3JrOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnTmV0d29yaycsXG4gICAgJ05ldHdvcmsgaXNzdWUsIHNlZSBlcnIubW9yZSBmb3IgZGV0YWlscydcbiAgKSxcbiAgSlNPTlBTY3JpcHRGYWlsOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnSlNPTlBTY3JpcHRGYWlsJyxcbiAgICAnPHNjcmlwdD4gd2FzIGxvYWRlZCBidXQgZGlkIG5vdCBjYWxsIG91ciBwcm92aWRlZCBjYWxsYmFjaydcbiAgKSxcbiAgSlNPTlBTY3JpcHRFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ0pTT05QU2NyaXB0RXJyb3InLFxuICAgICc8c2NyaXB0PiB1bmFibGUgdG8gbG9hZCBkdWUgdG8gYW4gYGVycm9yYCBldmVudCBvbiBpdCdcbiAgKSxcbiAgVW5rbm93bjogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ1Vua25vd24nLFxuICAgICdVbmtub3duIGVycm9yIG9jY3VyZWQnXG4gIClcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvZXJyb3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICB2YXIgbmV3QXJyID0gW107XG4gIGZvcmVhY2goYXJyLCBmdW5jdGlvbihpdGVtLCBpdGVtSW5kZXgpIHtcbiAgICBuZXdBcnIucHVzaChmbihpdGVtLCBpdGVtSW5kZXgsIGFycikpO1xuICB9KTtcbiAgcmV0dXJuIG5ld0Fycjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQkFTRV9VUkwgPSAnaHR0cHM6Ly9zMy11cy13ZXN0LTIuYW1hem9uYXdzLmNvbS9zdXBlcnNhYmVyJztcblxuZnVuY3Rpb24gZ2V0UzNGaWxlVXJsIChpZCwgbmFtZSkge1xuICByZXR1cm4gYCR7QkFTRV9VUkx9LyR7aWR9LSR7bmFtZX1gO1xufVxubW9kdWxlLmV4cG9ydHMuZ2V0UzNGaWxlVXJsID0gZ2V0UzNGaWxlVXJsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzLmpzIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZiAodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7IG5ldyBDKGl0ZXIpOyB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UoKSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYgKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpIGRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcbiAgdmFyIGZucyA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKTtcbiAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICB2YXIgcnhmbiA9IGZuc1sxXTtcbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpIHtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmLCBuby11c2VsZXNzLWNhbGxcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTggRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdXNlci1hZ2VudC5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKTtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH0gfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFsIEFGUkFNRSAqL1xyXG5cclxuLypcclxuICogUHJvdmlkZXMgYSBzaW1wbGUgQVBJIGZvciBjcmVhdGluZyBkZWNvcmF0b3IgZnVuY3Rpb25zIHdoaWNoIHlvdSBjYW4gYXBwbHkgdG8geW91ciBDb21wb25lbnQgZGVmaW5pdGlvbnMuXHJcbiAqIFRoZXNlIGRlY29yYXRlZCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkIHdoZW4gdGhlaXIgQ29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgYW5kIGhhdmUgdGhlaXIgJ3RoaXMnIGF0dHJpYnV0ZSBzZXRcclxuICogdG8gdGhlIG5ldyBDb21wb25lbnQuXHJcbiAqXHJcbiAqIERlY29yYXRvcnMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiBmdW5jdGlvbnMgdGhhdCBhcmUgb3duZWQgYnkgQ29tcG9uZW50IGRlc2NyaXB0b3JzIHJlZ2lzdGVyZWQgd2l0aFxyXG4gKiBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQuIERlY29yYXRpbmcgYW55IG90aGVyIGZ1bmN0aW9uIHdpbGwgaGF2ZSBubyBlZmZlY3QsIGFzIHRoZSBkZWNvcmF0b3JcclxuICogZnVuY3RvciB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxyXG4gKi9cclxuXHJcbi8qXHJcbiAqIERlY29yYXRlcyBhIGZ1bmN0aW9uIHdpdGggYSBmdW5jdG9yIHRoYXQgaXMgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgZWFjaCBpbnN0YW50aWF0ZWQgQ29tcG9uZW50IHdoaWNoIG93bnMgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmdW5jIC0gRnVuY3Rpb24gdG8gZGVjb3JhdGUuXHJcbiAqIEBwYXJhbSBkZWNvcmF0b3JGdW5jIC0gRnVuY3RvciB3aGljaCBkZWNvcmF0ZXMgZnVuYy4gSXQncyBkZWZpbml0aW9uIHNob3VsZCBhcHBlYXIgbGlrZSB0aGlzOlxyXG4gKiAgICBmdW5jdGlvbiBkZWNvcmF0b3JGdW5jdG9yKGZ1bmNQcm9wZXJ0eU5hbWUpIHtcclxuICogICAgICBjb25zdCBmdW5jID0gdGhpc1tmdW5jUHJvcGVydHlOYW1lXTsgLy8gJ3RoaXMnIGlzIGFzc2lnbmVkIHRvIHRoZSBpbnN0YW50aWF0ZWQgQ29tcG9uZW50LlxyXG4gKiAgICAgIC8vIERlY29yYXRvciBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb25cclxuICogICAgICByZXR1cm4gKCkgPT4ge1xyXG4gKiAgICAgICAgY29uc29sZS5sb2codGhpcy5lbC5pZCArIFwiIGhhcyBhIGRlY29yYXRlZCBmdW5jdGlvbiFcIik7XHJcbiAqICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gKiAgICAgIH1cclxuICogICAgfVxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIHBlbmRpbmcgZGVjb3JhdGVkIGZ1bmN0b3Igd2hpY2ggd2lsbCBiZSBleGVjdXRlZCB3aGVuIGEgY29tcG9uZW50IHRoYXQgb3ducyBpdCBpcyBpbnN0YW50aWF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvcmF0ZShmdW5jLCBkZWNvcmF0b3JGdW5jKSB7XHJcbiAgcmV0dXJuIGRlY29yYXRpb25zLmFkZChmdW5jLCBkZWNvcmF0b3JGdW5jKTtcclxufVxyXG5cclxuLy8gSGVscGVyIGZvciBzdG9yaW5nIGFuZCByZXRyaWV2aW5nIGRlY29yYXRvciBmdW5jdG9ycyBmb3IgYSBnaXZlbiBmdW5jdGlvbi5cclxuY29uc3QgZGVjb3JhdGlvbnMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgY29uc3QgZnVuY01hcCA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGFkZChmdW5jLCBkZWNvcmF0b3IpIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IGZ1bmNNYXAuaGFzKGZ1bmMpID8gZnVuYyA6IHVuZGVmaW5lZDsgLy8gSW4gY2FzZSBkZWNvcmF0b3JzIGFyZSBuZXN0ZWQuXHJcbiAgICBjb25zdCBkZWNvcmF0ZWRGdW5jID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIGZ1bmNNYXAuc2V0KGRlY29yYXRlZEZ1bmMsIHtwYXJlbnQ6IHBhcmVudCwgZGVjb3JhdG9yOiBkZWNvcmF0b3J9KTtcclxuICAgIHJldHVybiBkZWNvcmF0ZWRGdW5jO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QWxsKGZ1bmMpIHtcclxuICAgIHZhciBpdGVyID0gZnVuY01hcC5nZXQoZnVuYyk7XHJcbiAgICB2YXIgZGVjb3JhdG9ycyA9IFtdO1xyXG4gICAgd2hpbGUgKGl0ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBkZWNvcmF0b3JzLnB1c2goaXRlci5kZWNvcmF0b3IpO1xyXG4gICAgICBpdGVyID0gaXRlci5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVjb3JhdG9ycztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb25EZWNvcmF0ZWQoZnVuYykge1xyXG4gICAgcmV0dXJuIGZ1bmNNYXAuaGFzKGZ1bmMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGFkZDogYWRkLFxyXG4gICAgZ2V0QWxsOiBnZXRBbGwsXHJcbiAgICBpc0Z1bmN0aW9uRGVjb3JhdGVkOiBpc0Z1bmN0aW9uRGVjb3JhdGVkXHJcbiAgfVxyXG59KSgpO1xyXG5cclxuLy8gSGVyZSBJJ20gd3JhcHBpbmcgdGhlIEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCBmdW5jdGlvbiBhbmQgYWxzbyBlYWNoIENvbXBvbmVudCBjb25zdHJ1Y3Rvci4gV2hlbmV2ZXIgYSBuZXcgY29tcG9uZW50XHJcbi8vIGlzIGluc3RhbnRpYXRlZCBJJ20gc2Nhbm5pbmcgaXRzIGxpc3Qgb2YgcHJvcGVydGllcyBmb3IgYW55IGZ1bmN0aW9ucyB3aGljaCBoYXZlIGJlZW4gZGVjb3JhdGVkLiBFYWNoIGRlY29yYXRpb25cclxuLy8gZnVuY3RvciB3aWxsIHRoZW4gYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGNvbXBvbmVudCB3aGljaCBvd25zIHRoZSBmdW5jdGlvbi5cclxuKGZ1bmN0aW9uKCkge1xyXG4gIE9iamVjdC5rZXlzKEFGUkFNRS5jb21wb25lbnRzKS5mb3JFYWNoKCBmdW5jdGlvbihjKSB7XHJcbiAgICB3cmFwQ29tcG9uZW50KGMpXHJcbiAgfSk7XHJcbiAgd3JhcFJlZ2lzdGVyKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGV4ZWN1dGVEZWNvcmF0b3JzT25OZXdDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICBjb25zdCBwcm90ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbXBvbmVudCk7XHJcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90KS5mb3JFYWNoKCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIGNvbnN0IHByb3AgPSBwcm90W25hbWVdO1xyXG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWNvcmF0aW9ucy5pc0Z1bmN0aW9uRGVjb3JhdGVkKHByb3ApKSB7XHJcbiAgICAgICAgZGVjb3JhdGlvbnMuZ2V0QWxsKHByb3ApLmZvckVhY2goZnVuY3Rpb24oZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgICBjb21wb25lbnRbbmFtZV0gPSBkZWNvcmF0b3IuY2FsbChjb21wb25lbnQsIG5hbWUsIHByb3ApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBDb21wb25lbnQobmFtZSkge1xyXG4gICAgY29uc3Qgb3JpZyA9IEFGUkFNRS5jb21wb25lbnRzW25hbWVdLkNvbXBvbmVudDtcclxuXHJcbiAgICBBRlJBTUUuY29tcG9uZW50c1tuYW1lXS5Db21wb25lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gT3ZlcnJpZGUgaW5pdCBvbiB0aGUgaW5zdGFuY2UgdG8gZXhlY3V0ZSB0aGUgZGVjb3JhdG9yIGZ1bmN0b3JzIGJlZm9yZSBpbml0aWFsaXppbmcuXHJcbiAgICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmluaXQ7XHJcbiAgICAgICAgZXhlY3V0ZURlY29yYXRvcnNPbk5ld0NvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgICBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBBRlJBTUUuY29tcG9uZW50c1tuYW1lXS5Db21wb25lbnQucHJvdG90eXBlID0gb3JpZy5wcm90b3R5cGU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3cmFwUmVnaXN0ZXIoKSB7XHJcbiAgICBjb25zdCBvcmlnUmVnaXN0ZXIgPSBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQ7XHJcbiAgICBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIG9yaWdSZWdpc3Rlci5hcHBseShBRlJBTUUsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHJldHVybiB3cmFwQ29tcG9uZW50KG5hbWUpO1xyXG4gICAgfVxyXG4gIH1cclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLmRlY29yYXRlID0gZGVjb3JhdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FmcmFtZS1ldmVudC1kZWNvcmF0b3JzL2NvbXBvbmVudC1kZWNvcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWwgQUZSQU1FICovXG5cbmlmICh0eXBlb2YgQUZSQU1FID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2FmcmFtZS1ldmVudC1kZWNvcmF0b3JzIHdhcyBsb2FkZWQgYmVmb3JlIEFGUkFNRSB3YXMgYXZhaWxhYmxlJyk7XG59XG5cbmNvbnN0IGV2ZW50QmluZGVyID0gcmVxdWlyZShcIi4vZXZlbnQtYmluZGVyXCIpO1xuY29uc3QgZGVjb3JhdGUgPSByZXF1aXJlKFwiLi9jb21wb25lbnQtZGVjb3JhdG9yc1wiKS5kZWNvcmF0ZTtcblxubW9kdWxlLmV4cG9ydHMuYmluZEV2ZW50ID0gZXZlbnRCaW5kZXIuYmluZEV2ZW50O1xubW9kdWxlLmV4cG9ydHMuYmluZEV2ZW50UGxheVBhdXNlID0gZXZlbnRCaW5kZXIuYmluZEV2ZW50UGxheVBhdXNlO1xubW9kdWxlLmV4cG9ydHMuZGVjb3JhdGUgPSBkZWNvcmF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWZyYW1lLWV2ZW50LWRlY29yYXRvcnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gYnVpbGRTZWFyY2hNZXRob2Q7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycy5qcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZWFyY2ggbWV0aG9kIHRvIGJlIHVzZWQgaW4gY2xpZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5UGFyYW0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciB0aGUgcXVlcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdGhlIHVybFxuICogQHJldHVybiB7ZnVuY3Rpb259IHRoZSBzZWFyY2ggbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU2VhcmNoTWV0aG9kKHF1ZXJ5UGFyYW0sIHVybCkge1xuICAvKipcbiAgICogVGhlIHNlYXJjaCBtZXRob2QuIFByZXBhcmVzIHRoZSBkYXRhIGFuZCBzZW5kIHRoZSBxdWVyeSB0byBBbGdvbGlhLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIHN0cmluZyB1c2VkIGZvciBxdWVyeSBzZWFyY2hcbiAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHNlbmQgd2l0aCB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjbGllbnQgZ2V0cyB0aGUgYW5zd2VyXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZHxQcm9taXNlfSBJZiB0aGUgY2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkIHRoZW4gdGhpcyBtZXRob2RzIHJldHVybnMgYSBQcm9taXNlXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoKHF1ZXJ5LCBhcmdzLCBjYWxsYmFjaykge1xuICAgIC8vIHdhcm4gVjIgdXNlcnMgb24gaG93IHRvIHNlYXJjaFxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnIHx8XG4gICAgICB0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyAuc2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIGNiKVxuICAgICAgLy8gLnNlYXJjaChjYiwgcGFyYW1zKVxuICAgICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ2luZGV4LnNlYXJjaCB1c2FnZSBpcyBpbmRleC5zZWFyY2gocXVlcnksIHBhcmFtcywgY2IpJyk7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXppbmcgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBxdWVyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVXNhZ2UgOiAuc2VhcmNoKCksIC5zZWFyY2goY2IpXG4gICAgICBjYWxsYmFjayA9IHF1ZXJ5O1xuICAgICAgcXVlcnkgPSAnJztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGFyZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFVzYWdlIDogLnNlYXJjaChxdWVyeS9hcmdzKSwgLnNlYXJjaChxdWVyeSwgY2IpXG4gICAgICBjYWxsYmFjayA9IGFyZ3M7XG4gICAgICBhcmdzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgMyBhcmd1bWVudHMgd2l0aCB2YWx1ZXNcblxuICAgIC8vIFVzYWdlIDogLnNlYXJjaChhcmdzKSAvLyBjYXJlZnVsOiB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAhPT0gbnVsbCkge1xuICAgICAgYXJncyA9IHF1ZXJ5O1xuICAgICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkIHx8IHF1ZXJ5ID09PSBudWxsKSB7IC8vIC5zZWFyY2godW5kZWZpbmVkL251bGwpXG4gICAgICBxdWVyeSA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSAnJztcblxuICAgIGlmIChxdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbXMgKz0gcXVlcnlQYXJhbSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSk7XG4gICAgfVxuXG4gICAgdmFyIGFkZGl0aW9uYWxVQTtcbiAgICBpZiAoYXJncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYXJncy5hZGRpdGlvbmFsVUEpIHtcbiAgICAgICAgYWRkaXRpb25hbFVBID0gYXJncy5hZGRpdGlvbmFsVUE7XG4gICAgICAgIGRlbGV0ZSBhcmdzLmFkZGl0aW9uYWxVQTtcbiAgICAgIH1cbiAgICAgIC8vIGBfZ2V0U2VhcmNoUGFyYW1zYCB3aWxsIGF1Z21lbnQgcGFyYW1zLCBkbyBub3QgYmUgZm9vbGVkIGJ5IHRoZSA9IHZlcnN1cyArPSBmcm9tIHByZXZpb3VzIGlmXG4gICAgICBwYXJhbXMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMoYXJncywgcGFyYW1zKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB0aGlzLl9zZWFyY2gocGFyYW1zLCB1cmwsIGNhbGxiYWNrLCBhZGRpdGlvbmFsVUEpO1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2J1aWxkU2VhcmNoTWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvbWl0KG9iaiwgdGVzdCkge1xuICB2YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG4gIHZhciBmb3JlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG4gIHZhciBmaWx0ZXJlZCA9IHt9O1xuXG4gIGZvcmVhY2goa2V5cyhvYmopLCBmdW5jdGlvbiBkb0ZpbHRlcihrZXlOYW1lKSB7XG4gICAgaWYgKHRlc3Qoa2V5TmFtZSkgIT09IHRydWUpIHtcbiAgICAgIGZpbHRlcmVkW2tleU5hbWVdID0gb2JqW2tleU5hbWVdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9vbWl0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCAvKiA9IDAgKi8sIHN0YXJ0IC8qID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgdG8gPSB0b0Fic29sdXRlSW5kZXgodGFyZ2V0LCBsZW4pO1xuICB2YXIgZnJvbSA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgdmFyIGluYyA9IDE7XG4gIGlmIChmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpIHtcbiAgICBpbmMgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG5mdW5jdGlvbiBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICB2YXIgdGFyZ2V0SW5kZXggPSBzdGFydDtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgdmFyIG1hcEZuID0gbWFwcGVyID8gY3R4KG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIHNwcmVhZGFibGU7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICAgIHNwcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmIChpc09iamVjdChlbGVtZW50KSkge1xuICAgICAgICBzcHJlYWRhYmxlID0gZWxlbWVudFtJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gICAgICAgIHNwcmVhZGFibGUgPSBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ByZWFkYWJsZSAmJiBkZXB0aCA+IDApIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MWZmZmZmZmZmZmZmZmYpIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkludG9BcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZsYXR0ZW4taW50by1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpIHtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xudmFyIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpO1xudmFyIE1BWDMyID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMik7XG52YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZnJvdW5kIHx8IGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gIHZhciAkYWJzID0gTWF0aC5hYnMoeCk7XG4gIHZhciAkc2lnbiA9IHNpZ24oeCk7XG4gIHZhciBhLCByZXN1bHQ7XG4gIGlmICgkYWJzIDwgTUlOMzIpIHJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpIHJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2NhbGUgfHwgZnVuY3Rpb24gc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gIGlmIChcbiAgICBhcmd1bWVudHMubGVuZ3RoID09PSAwXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCB4ICE9IHhcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IGluTG93ICE9IGluTG93XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBpbkhpZ2ggIT0gaW5IaWdoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBvdXRMb3cgIT0gb3V0TG93XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBvdXRIaWdoICE9IG91dEhpZ2hcbiAgKSByZXR1cm4gTmFOO1xuICBpZiAoeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5KSByZXR1cm4geDtcbiAgcmV0dXJuICh4IC0gaW5Mb3cpICogKG91dEhpZ2ggLSBvdXRMb3cpIC8gKGluSGlnaCAtIGluTG93KSArIG91dExvdztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdDtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgdmFyIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgaGV4ID0gL15bLStdPzBbeFhdLztcblxubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHZhciBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIHRtcCA9IHt9O1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNzsgfSkpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWwgQUZSQU1FLCBUSFJFRSAqL1xuXG52YXIgYW5pbWUgPSByZXF1aXJlKCdhbmltZWpzJyk7XG5cbkFGUkFNRS5hbmltZSA9IGFuaW1lO1xuXG5pZiAodHlwZW9mIEFGUkFNRSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgYXR0ZW1wdGVkIHRvIHJlZ2lzdGVyIGJlZm9yZSBBRlJBTUUgd2FzIGF2YWlsYWJsZS4nKTtcbn1cblxudmFyIGNvbG9ySGVscGVyRnJvbSA9IG5ldyBUSFJFRS5Db2xvcigpO1xudmFyIGNvbG9ySGVscGVyVG8gPSBuZXcgVEhSRUUuQ29sb3IoKTtcblxudmFyIHV0aWxzID0gQUZSQU1FLnV0aWxzO1xudmFyIGdldENvbXBvbmVudFByb3BlcnR5ID0gdXRpbHMuZW50aXR5LmdldENvbXBvbmVudFByb3BlcnR5O1xudmFyIHNldENvbXBvbmVudFByb3BlcnR5ID0gdXRpbHMuZW50aXR5LnNldENvbXBvbmVudFByb3BlcnR5O1xudmFyIHNwbGl0Q2FjaGUgPSB7fTtcblxudmFyIFRZUEVfQ09MT1IgPSAnY29sb3InO1xudmFyIFBST1BfUE9TSVRJT04gPSAncG9zaXRpb24nO1xudmFyIFBST1BfUk9UQVRJT04gPSAncm90YXRpb24nO1xudmFyIFBST1BfU0NBTEUgPSAnc2NhbGUnO1xudmFyIFNUUklOR19DT01QT05FTlRTID0gJ2NvbXBvbmVudHMnO1xudmFyIFNUUklOR19PQkpFQ1QzRCA9ICdvYmplY3QzRCc7XG5cbi8qKlxuICogQW5pbWF0aW9uIGNvbXBvbmVudCBmb3IgQS1GcmFtZSB1c2luZyBhbmltZS5qcy5cbiAqXG4gKiBUaGUgY29tcG9uZW50IG1hbnVhbGx5IGNvbnRyb2xzIHRoZSB0aWNrIGJ5IHNldHRpbmcgYGF1dG9wbGF5OiBmYWxzZWAgb24gYW5pbWUuanMgYW5kXG4gKiBtYW51YWxseSAqIGNhbGxpbmcgYGFuaW1hdGlvbi50aWNrKClgIGluIHRoZSB0aWNrIGhhbmRsZXIuIFRvIHBhdXNlIG9yIHJlc3VtZSwgd2UgdG9nZ2xlIGFcbiAqIGJvb2xlYW4gKiBmbGFnICogYGlzQW5pbWF0aW9uUGxheWluZ2AuXG4gKlxuICogYW5pbWUuanMgYW5pbWF0aW9uIGNvbmZpZyBmb3IgdHdlZW5pbmluZyBKYXZhc2NyaXB0IG9iamVjdHMgYW5kIHZhbHVlcyB3b3JrcyBhczpcbiAqXG4gKiAgY29uZmlnID0ge1xuICogICAgdGFyZ2V0czoge2ZvbzogMC4wLCBiYXI6ICcjMDAwJ30sXG4gKiAgICBmb286IDEuMCxcbiAqICAgIGJhcjogJyNGRkYnXG4gKiAgfVxuICpcbiAqIFRoZSBhYm92ZSB3aWxsIHR3ZWVuIGVhY2ggcHJvcGVydHkgaW4gYHRhcmdldHNgLiBUaGUgYHRvYCB2YWx1ZXMgYXJlIHNldCBpbiB0aGUgcm9vdCBvZlxuICogdGhlIGNvbmZpZy5cbiAqXG4gKiBAbWVtYmVyIHtvYmplY3R9IGFuaW1hdGlvbiAtIGFuaW1lLmpzIGluc3RhbmNlLlxuICogQG1lbWJlciB7Ym9vbGVhbn0gYW5pbWF0aW9uSXNQbGF5aW5nIC0gQ29udHJvbCBpZiBhbmltYXRpb24gaXMgcGxheWluZy5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdhbmltYXRpb24nLCB7XG4gIHNjaGVtYToge1xuICAgIGF1dG9wbGF5OiB7ZGVmYXVsdDogdHJ1ZX0sXG4gICAgZGVsYXk6IHtkZWZhdWx0OiAwfSxcbiAgICBkaXI6IHtkZWZhdWx0OiAnJ30sXG4gICAgZHVyOiB7ZGVmYXVsdDogMTAwMH0sXG4gICAgZWFzaW5nOiB7ZGVmYXVsdDogJ2Vhc2VJblF1YWQnfSxcbiAgICBlbGFzdGljaXR5OiB7ZGVmYXVsdDogNDAwfSxcbiAgICBlbmFibGVkOiB7ZGVmYXVsdDogdHJ1ZX0sXG4gICAgZnJvbToge2RlZmF1bHQ6ICcnfSxcbiAgICBsb29wOiB7XG4gICAgICBkZWZhdWx0OiAwLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBCb29sZWFuIG9yIGludGVnZXIuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gJ3RydWUnKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09ICdmYWxzZScpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcGVydHk6IHtkZWZhdWx0OiAnJ30sXG4gICAgc3RhcnRFdmVudHM6IHt0eXBlOiAnYXJyYXknfSxcbiAgICBwYXVzZUV2ZW50czoge3R5cGU6ICdhcnJheSd9LFxuICAgIHJlc3VtZUV2ZW50czoge3R5cGU6ICdhcnJheSd9LFxuICAgIHRvOiB7ZGVmYXVsdDogJyd9LFxuICAgIHR5cGU6IHtkZWZhdWx0OiAnJ30sXG4gICAgaXNSYXdQcm9wZXJ0eToge2RlZmF1bHQ6IGZhbHNlfVxuICB9LFxuXG4gIG11bHRpcGxlOiB0cnVlLFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmV2ZW50RGV0YWlsID0ge25hbWU6IHRoaXMuYXR0ck5hbWV9O1xuICAgIHRoaXMudGltZSA9IDA7XG5cbiAgICB0aGlzLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmltYXRpb25Jc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm9uU3RhcnRFdmVudCA9IHRoaXMub25TdGFydEV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5iZWdpbkFuaW1hdGlvbiA9IHRoaXMuYmVnaW5BbmltYXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnBhdXNlQW5pbWF0aW9uID0gdGhpcy5wYXVzZUFuaW1hdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzdW1lQW5pbWF0aW9uID0gdGhpcy5yZXN1bWVBbmltYXRpb24uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZnJvbUNvbG9yID0ge307XG4gICAgdGhpcy50b0NvbG9yID0ge307XG4gICAgdGhpcy50YXJnZXRzID0ge307XG4gICAgdGhpcy50YXJnZXRzQXJyYXkgPSBbXTtcblxuICAgIHRoaXMudXBkYXRlQ29uZmlnRm9yRGVmYXVsdCA9IHRoaXMudXBkYXRlQ29uZmlnRm9yRGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudXBkYXRlQ29uZmlnRm9yUmF3Q29sb3IgPSB0aGlzLnVwZGF0ZUNvbmZpZ0ZvclJhd0NvbG9yLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuYW5pbWF0aW9uSXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZWwuZW1pdCgnYW5pbWF0aW9uY29tcGxldGUnLCBzZWxmLmV2ZW50RGV0YWlsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICB0aGlzLmFuaW1hdGlvbklzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgaWYgKG9sZERhdGEuZW5hYmxlZCAmJiAhdGhpcy5kYXRhLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhLnByb3BlcnR5KSB7IHJldHVybjsgfVxuXG4gICAgLy8gQmFzZSBjb25maWcuXG4gICAgY29uZmlnLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgY29uZmlnLmRpcmVjdGlvbiA9IGRhdGEuZGlyO1xuICAgIGNvbmZpZy5kdXJhdGlvbiA9IGRhdGEuZHVyO1xuICAgIGNvbmZpZy5lYXNpbmcgPSBkYXRhLmVhc2luZztcbiAgICBjb25maWcuZWxhc3RpY2l0eSA9IGRhdGEuZWxhc3RpY2l0eTtcbiAgICBjb25maWcubG9vcCA9IGRhdGEubG9vcDtcblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb24uXG4gICAgdGhpcy5jcmVhdGVBbmRTdGFydEFuaW1hdGlvbigpO1xuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICh0LCBkdCkge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25Jc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy50aW1lICs9IGR0O1xuICAgIHRoaXMuYW5pbWF0aW9uLnRpY2sodGhpcy50aW1lKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhdXNlQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMucGF1c2VkV2FzUGxheWluZyA9IHRoaXMuYW5pbWF0aW9uSXNQbGF5aW5nO1xuICAgIHRoaXMucGF1c2VBbmltYXRpb24oKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBwbGF5YCBoYW5kbGVyIG9ubHkgZm9yIHJlc3VtaW5nIHNjZW5lLlxuICAgKi9cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgaWYgKHRoaXMucGF1c2VkV2FzUGxheWluZykge1xuICAgICAgdGhpcy5yZXN1bWVBbmltYXRpb24oKTtcbiAgICAgIHRoaXMucGF1c2VkV2FzUGxheWluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIGZyb20gc2NyYXRjaC5cbiAgICovXG4gIGNyZWF0ZUFuZFN0YXJ0QW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbmZpZygpO1xuICAgIHRoaXMuYW5pbWF0aW9uSXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltZSh0aGlzLmNvbmZpZyk7XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuXG4gICAgLy8gV2FpdCBmb3Igc3RhcnQgZXZlbnRzIGZvciBhbmltYXRpb24uXG4gICAgaWYgKCFkYXRhLmF1dG9wbGF5IHx8IGRhdGEuc3RhcnRFdmVudHMgJiYgZGF0YS5zdGFydEV2ZW50cy5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBEZWxheSBhbmltYXRpb24uXG4gICAgaWYgKGRhdGEuZGVsYXkpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5iZWdpbkFuaW1hdGlvbiwgZGF0YS5kZWxheSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUGxheSBhbmltYXRpb24uXG4gICAgdGhpcy5iZWdpbkFuaW1hdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGJlZm9yZSBhbmltYXRpb24gc3RhcnQgKGluY2x1ZGluZyBmcm9tIHN0YXJ0RXZlbnRzKS5cbiAgICogU2V0IHRvIGluaXRpYWwgc3RhdGUgKGNvbmZpZy5mcm9tLCB0aW1lID0gMCwgc2Vla1RpbWUgPSAwKS5cbiAgICovXG4gIGJlZ2luQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVDb25maWcoKTtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuYW5pbWF0aW9uSXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN0b3BSZWxhdGVkQW5pbWF0aW9ucygpO1xuICAgIHRoaXMuZWwuZW1pdCgnYW5pbWF0aW9uYmVnaW4nLCB0aGlzLmV2ZW50RGV0YWlsKTtcbiAgfSxcblxuICBwYXVzZUFuaW1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uSXNQbGF5aW5nID0gZmFsc2U7XG4gIH0sXG5cbiAgcmVzdW1lQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb25Jc1BsYXlpbmcgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzdGFydEV2ZW50cyBjYWxsYmFjay5cbiAgICovXG4gIG9uU3RhcnRFdmVudDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kYXRhLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLnVwZGF0ZUNvbmZpZygpO1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgdGhpcy5hbmltYXRpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltZSh0aGlzLmNvbmZpZyk7XG5cbiAgICAvLyBJbmNsdWRlIHRoZSBkZWxheSBiZWZvcmUgZWFjaCBzdGFydCBldmVudC5cbiAgICBpZiAodGhpcy5kYXRhLmRlbGF5KSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMuYmVnaW5BbmltYXRpb24sIHRoaXMuZGF0YS5kZWxheSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5BbmltYXRpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogcmF3UHJvcGVydHk6IHRydWUgYW5kIHR5cGU6IGNvbG9yO1xuICAgKi9cbiAgdXBkYXRlQ29uZmlnRm9yUmF3Q29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgZnJvbTtcbiAgICB2YXIga2V5O1xuICAgIHZhciB0bztcblxuICAgIGlmICh0aGlzLndhaXRDb21wb25lbnRJbml0UmF3UHJvcGVydHkodGhpcy51cGRhdGVDb25maWdGb3JSYXdDb2xvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcm9tID0gZGF0YS5mcm9tIHx8IGdldFJhd1Byb3BlcnR5KGVsLCBkYXRhLnByb3BlcnR5KTtcbiAgICB0byA9IGRhdGEudG87XG5cbiAgICAvLyBVc2Ugci9nL2IgdmVjdG9yIGZvciBjb2xvciB0eXBlLlxuICAgIHRoaXMuc2V0Q29sb3JDb25maWcoZnJvbSwgdG8pO1xuICAgIGZyb20gPSB0aGlzLmZyb21Db2xvcjtcbiAgICB0byA9IHRoaXMudG9Db2xvcjtcblxuICAgIHRoaXMudGFyZ2V0c0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy50YXJnZXRzQXJyYXkucHVzaChmcm9tKTtcbiAgICBjb25maWcudGFyZ2V0cyA9IHRoaXMudGFyZ2V0c0FycmF5O1xuICAgIGZvciAoa2V5IGluIHRvKSB7IGNvbmZpZ1trZXldID0gdG9ba2V5XTsgfVxuXG4gICAgY29uZmlnLnVwZGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdFZhbHVlID0ge307XG4gICAgICBsYXN0VmFsdWUuciA9IGZyb20ucjtcbiAgICAgIGxhc3RWYWx1ZS5nID0gZnJvbS5nO1xuICAgICAgbGFzdFZhbHVlLmIgPSBmcm9tLmI7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbSkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gYW5pbS5hbmltYXRhYmxlc1swXS50YXJnZXQ7XG4gICAgICAgIC8vIEZvciBhbmltYXRpb24gdGltZWxpbmUuXG4gICAgICAgICAgaWYgKHZhbHVlLnIgPT09IGxhc3RWYWx1ZS5yICYmXG4gICAgICAgICAgICAgIHZhbHVlLmcgPT09IGxhc3RWYWx1ZS5nICYmXG4gICAgICAgICAgICAgIHZhbHVlLmIgPT09IGxhc3RWYWx1ZS5iKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHNldFJhd1Byb3BlcnR5KGVsLCBkYXRhLnByb3BlcnR5LCB2YWx1ZSwgZGF0YS50eXBlKTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3R1ZmYgcHJvcGVydHkgaW50byBnZW5lcmljIGBwcm9wZXJ0eWAga2V5LlxuICAgKi9cbiAgdXBkYXRlQ29uZmlnRm9yRGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBmcm9tO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGlzQm9vbGVhbjtcbiAgICB2YXIgaXNOdW1iZXI7XG4gICAgdmFyIHRvO1xuXG4gICAgaWYgKHRoaXMud2FpdENvbXBvbmVudEluaXRSYXdQcm9wZXJ0eSh0aGlzLnVwZGF0ZUNvbmZpZ0ZvckRlZmF1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnJvbSA9IGRhdGEuZnJvbSB8fCAoXG4gICAgICBpc1Jhd1Byb3BlcnR5KGRhdGEpXG4gICAgICAgID8gZ2V0UmF3UHJvcGVydHkoZWwsIGRhdGEucHJvcGVydHkpXG4gICAgICAgIDogZ2V0Q29tcG9uZW50UHJvcGVydHkoZWwsIGRhdGEucHJvcGVydHkpXG4gICAgKTtcbiAgICB0byA9IGRhdGEudG87XG5cbiAgICBpc051bWJlciA9ICFpc05hTihmcm9tIHx8IHRvKTtcbiAgICBpZiAoaXNOdW1iZXIpIHtcbiAgICAgIGZyb20gPSBwYXJzZUZsb2F0KGZyb20pO1xuICAgICAgdG8gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbSA9IGZyb20gPyBmcm9tLnRvU3RyaW5nKCkgOiBmcm9tO1xuICAgICAgdG8gPSB0byA/IHRvLnRvU3RyaW5nKCkgOiB0bztcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGJvb2xlYW5zIHRvIGludGVnZXIgdG8gYWxsb3cgYm9vbGVhbiBmbGlwcGluZy5cbiAgICBpc0Jvb2xlYW4gPSB0byA9PT0gJ3RydWUnIHx8IHRvID09PSAnZmFsc2UnO1xuICAgIGlmIChpc0Jvb2xlYW4pIHtcbiAgICAgIGZyb20gPSBkYXRhLmZyb20gPT09ICd0cnVlJyA/IDEgOiAwO1xuICAgICAgdG8gPSBkYXRhLnRvID09PSAndHJ1ZScgPyAxIDogMDtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldHMuYWZyYW1lUHJvcGVydHkgPSBmcm9tO1xuICAgIGNvbmZpZy50YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuICAgIGNvbmZpZy5hZnJhbWVQcm9wZXJ0eSA9IHRvO1xuICAgIGNvbmZpZy51cGRhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhc3RWYWx1ZSA9IGZyb207XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW0pIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGFuaW0uYW5pbWF0YWJsZXNbMF0udGFyZ2V0LmFmcmFtZVByb3BlcnR5O1xuXG4gICAgICAgIC8vIE5lZWQgdG8gZG8gYSBsYXN0IHZhbHVlIGNoZWNrIGZvciBhbmltYXRpb24gdGltZWxpbmUgc2luY2UgYWxsIHRoZSB0d2VlbmluZ1xuICAgICAgICAvLyBiZWdpbnMgc2ltdWx0YWVub3VzbHkgZXZlbiBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLiBBbHNvIGJldHRlciBmb3IgcGVyZlxuICAgICAgICAvLyBhbnl3YXlzLlxuICAgICAgICBpZiAodmFsdWUgPT09IGxhc3RWYWx1ZSkgeyByZXR1cm47IH1cbiAgICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzQm9vbGVhbikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj0gMSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1Jhd1Byb3BlcnR5KGRhdGEpKSB7XG4gICAgICAgICAgc2V0UmF3UHJvcGVydHkoZWwsIGRhdGEucHJvcGVydHksIHZhbHVlLCBkYXRhLnR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldENvbXBvbmVudFByb3BlcnR5KGVsLCBkYXRhLnByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgfSxcblxuICAvKipcbiAgICogRXh0ZW5kIHgveS96L3cgb250byB0aGUgY29uZmlnLlxuICAgKiBVcGRhdGUgdmVjdG9yIGJ5IG1vZGlmeWluZyBvYmplY3QzRC5cbiAgICovXG4gIHVwZGF0ZUNvbmZpZ0ZvclZlY3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuXG4gICAgLy8gUGFyc2UgY29vcmRpbmF0ZXMuXG4gICAgZnJvbSA9IGRhdGEuZnJvbVxuICAgICAgPyBBRlJBTUUudXRpbHMuY29vcmRpbmF0ZXMucGFyc2UoZGF0YS5mcm9tKSAgLy8gSWYgZGF0YS5mcm9tIGRlZmluZWQsIHVzZSB0aGF0LlxuICAgICAgOiBnZXRDb21wb25lbnRQcm9wZXJ0eShlbCwgZGF0YS5wcm9wZXJ0eSk7ICAvLyBJZiBkYXRhLmZyb20gbm90IGRlZmluZWQsIGdldCBvbiB0aGUgZmx5LlxuICAgIHRvID0gQUZSQU1FLnV0aWxzLmNvb3JkaW5hdGVzLnBhcnNlKGRhdGEudG8pO1xuXG4gICAgLy8gQW5pbWF0ZSByb3RhdGlvbiB0aHJvdWdoIHJhZGlhbnMuXG4gICAgaWYgKGRhdGEucHJvcGVydHkgPT09IFBST1BfUk9UQVRJT04pIHtcbiAgICAgIHRvUmFkaWFucyhmcm9tKTtcbiAgICAgIHRvUmFkaWFucyh0byk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRvIGFuZCBmcm9tLlxuICAgIHRoaXMudGFyZ2V0c0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy50YXJnZXRzQXJyYXkucHVzaChmcm9tKTtcbiAgICBjb25maWcudGFyZ2V0cyA9IHRoaXMudGFyZ2V0c0FycmF5O1xuICAgIGZvciAoa2V5IGluIHRvKSB7IGNvbmZpZ1trZXldID0gdG9ba2V5XTsgfVxuXG4gICAgLy8gSWYgYW5pbWF0aW5nIG9iamVjdDNEIHRyYW5zZm9ybWF0aW9uLCBydW4gbW9yZSBvcHRpbWl6ZWQgdXBkYXRlci5cbiAgICBpZiAoZGF0YS5wcm9wZXJ0eSA9PT0gUFJPUF9QT1NJVElPTiB8fCBkYXRhLnByb3BlcnR5ID09PSBQUk9QX1JPVEFUSU9OIHx8XG4gICAgICAgIGRhdGEucHJvcGVydHkgPT09IFBST1BfU0NBTEUpIHtcbiAgICAgIGNvbmZpZy51cGRhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdFZhbHVlID0ge307XG4gICAgICAgIGxhc3RWYWx1ZS54ID0gZnJvbS54O1xuICAgICAgICBsYXN0VmFsdWUueSA9IGZyb20ueTtcbiAgICAgICAgbGFzdFZhbHVlLnogPSBmcm9tLno7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYW5pbS5hbmltYXRhYmxlc1swXS50YXJnZXQ7XG4gICAgICAgICAgLy8gRm9yIGFuaW1hdGlvbiB0aW1lbGluZS5cbiAgICAgICAgICBpZiAodmFsdWUueCA9PT0gbGFzdFZhbHVlLnggJiZcbiAgICAgICAgICAgICAgdmFsdWUueSA9PT0gbGFzdFZhbHVlLnkgJiZcbiAgICAgICAgICAgICAgdmFsdWUueiA9PT0gbGFzdFZhbHVlLnopIHsgcmV0dXJuOyB9XG4gICAgICAgICAgbGFzdFZhbHVlLnggPSB2YWx1ZS54O1xuICAgICAgICAgIGxhc3RWYWx1ZS55ID0gdmFsdWUueTtcbiAgICAgICAgICBsYXN0VmFsdWUueiA9IHZhbHVlLno7XG4gICAgICAgICAgZWwub2JqZWN0M0RbZGF0YS5wcm9wZXJ0eV0uc2V0KHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnopO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbmltYXRpbmcgc29tZSB2ZWN0b3IuXG4gICAgY29uZmlnLnVwZGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdFZhbHVlID0ge307XG4gICAgICBsYXN0VmFsdWUueCA9IGZyb20ueDtcbiAgICAgIGxhc3RWYWx1ZS55ID0gZnJvbS55O1xuICAgICAgbGFzdFZhbHVlLnogPSBmcm9tLno7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhbmltLmFuaW1hdGlvbnNbMF0udGFyZ2V0O1xuICAgICAgICAvLyBGb3IgYW5pbWF0aW9uIHRpbWVsaW5lLlxuICAgICAgICBpZiAodmFsdWUueCA9PT0gbGFzdFZhbHVlLnggJiZcbiAgICAgICAgICAgIHZhbHVlLnkgPT09IGxhc3RWYWx1ZS55ICYmXG4gICAgICAgICAgICB2YWx1ZS56ID09PSBsYXN0VmFsdWUueikgeyByZXR1cm47IH1cbiAgICAgICAgbGFzdFZhbHVlLnggPSB2YWx1ZS54O1xuICAgICAgICBsYXN0VmFsdWUueSA9IHZhbHVlLnk7XG4gICAgICAgIGxhc3RWYWx1ZS56ID0gdmFsdWUuejtcbiAgICAgICAgc2V0Q29tcG9uZW50UHJvcGVydHkoZWwsIGRhdGEucHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbmZpZyBiZWZvcmUgZWFjaCBydW4uXG4gICAqL1xuICB1cGRhdGVDb25maWc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcFR5cGU7XG5cbiAgICAvLyBSb3V0ZSBjb25maWcgdHlwZS5cbiAgICBwcm9wVHlwZSA9IGdldFByb3BlcnR5VHlwZSh0aGlzLmVsLCB0aGlzLmRhdGEucHJvcGVydHkpO1xuICAgIGlmIChpc1Jhd1Byb3BlcnR5KHRoaXMuZGF0YSkgJiYgdGhpcy5kYXRhLnR5cGUgPT09IFRZUEVfQ09MT1IpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29uZmlnRm9yUmF3Q29sb3IoKTtcbiAgICB9IGVsc2UgaWYgKHByb3BUeXBlID09PSAndmVjMicgfHwgcHJvcFR5cGUgPT09ICd2ZWMzJyB8fCBwcm9wVHlwZSA9PT0gJ3ZlYzQnKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbmZpZ0ZvclZlY3RvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbmZpZ0ZvckRlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdhaXQgZm9yIGNvbXBvbmVudCB0byBpbml0aWFsaXplLlxuICAgKi9cbiAgd2FpdENvbXBvbmVudEluaXRSYXdQcm9wZXJ0eTogZnVuY3Rpb24gKGNiKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWU7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZGF0YS5mcm9tKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCFkYXRhLnByb3BlcnR5LnN0YXJ0c1dpdGgoU1RSSU5HX0NPTVBPTkVOVFMpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgY29tcG9uZW50TmFtZSA9IHNwbGl0RG90KGRhdGEucHJvcGVydHkpWzFdO1xuICAgIGlmIChlbC5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9uZW50aW5pdGlhbGl6ZWQnLCBmdW5jdGlvbiB3YWl0IChldnQpIHtcbiAgICAgIGlmIChldnQuZGV0YWlsLm5hbWUgIT09IGNvbXBvbmVudE5hbWUpIHsgcmV0dXJuOyB9XG4gICAgICBjYigpO1xuICAgICAgLy8gU2luY2UgdGhlIGNvbmZpZyB3YXMgY3JlYXRlZCBhc3luYywgY3JlYXRlIHRoZSBhbmltYXRpb24gbm93IHNpbmNlIHdlIG1pc3NlZCBpdFxuICAgICAgLy8gZWFybGllci5cbiAgICAgIHNlbGYuYW5pbWF0aW9uID0gYW5pbWUoc2VsZi5jb25maWcpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcG9uZW50aW5pdGlhbGl6ZWQnLCB3YWl0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogTWFrZSBzdXJlIHR3byBhbmltYXRpb25zIG9uIHRoZSBzYW1lIHByb3BlcnR5IGRvbid0IGZpZ2h0IGVhY2ggb3RoZXIuXG4gICAqIGUuZy4sIGFuaW1hdGlvbl9fbW91c2VlbnRlcj1cInByb3BlcnR5OiBtYXRlcmlhbC5vcGFjaXR5XCJcbiAgICogICAgICAgYW5pbWF0aW9uX19tb3VzZWxlYXZlPVwicHJvcGVydHk6IG1hdGVyaWFsLm9wYWNpdHlcIlxuICAgKi9cbiAgc3RvcFJlbGF0ZWRBbmltYXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBvbmVudDtcbiAgICB2YXIgY29tcG9uZW50TmFtZTtcbiAgICBmb3IgKGNvbXBvbmVudE5hbWUgaW4gdGhpcy5lbC5jb21wb25lbnRzKSB7XG4gICAgICBjb21wb25lbnQgPSB0aGlzLmVsLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV07XG4gICAgICBpZiAoY29tcG9uZW50TmFtZSA9PT0gdGhpcy5hdHRyTmFtZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKGNvbXBvbmVudC5uYW1lICE9PSAnYW5pbWF0aW9uJykgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKCFjb21wb25lbnQuYW5pbWF0aW9uSXNQbGF5aW5nKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoY29tcG9uZW50LmRhdGEucHJvcGVydHkgIT09IHRoaXMuZGF0YS5wcm9wZXJ0eSkgeyBjb250aW51ZTsgfVxuICAgICAgY29tcG9uZW50LmFuaW1hdGlvbklzUGxheWluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBhZGRFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoZWwsIGRhdGEuc3RhcnRFdmVudHMsIHRoaXMub25TdGFydEV2ZW50KTtcbiAgICBhZGRFdmVudExpc3RlbmVycyhlbCwgZGF0YS5wYXVzZUV2ZW50cywgdGhpcy5wYXVzZUFuaW1hdGlvbik7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoZWwsIGRhdGEucmVzdW1lRXZlbnRzLCB0aGlzLnJlc3VtZUFuaW1hdGlvbik7XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGVsLCBkYXRhLnN0YXJ0RXZlbnRzLCB0aGlzLm9uU3RhcnRFdmVudCk7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZWwsIGRhdGEucGF1c2VFdmVudHMsIHRoaXMucGF1c2VBbmltYXRpb24pO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGVsLCBkYXRhLnJlc3VtZUV2ZW50cywgdGhpcy5yZXN1bWVBbmltYXRpb24pO1xuICB9LFxuXG4gIHNldENvbG9yQ29uZmlnOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICBjb2xvckhlbHBlckZyb20uc2V0KGZyb20pO1xuICAgIGNvbG9ySGVscGVyVG8uc2V0KHRvKTtcbiAgICBmcm9tID0gdGhpcy5mcm9tQ29sb3I7XG4gICAgdG8gPSB0aGlzLnRvQ29sb3I7XG4gICAgZnJvbS5yID0gY29sb3JIZWxwZXJGcm9tLnI7XG4gICAgZnJvbS5nID0gY29sb3JIZWxwZXJGcm9tLmc7XG4gICAgZnJvbS5iID0gY29sb3JIZWxwZXJGcm9tLmI7XG4gICAgdG8uciA9IGNvbG9ySGVscGVyVG8ucjtcbiAgICB0by5nID0gY29sb3JIZWxwZXJUby5nO1xuICAgIHRvLmIgPSBjb2xvckhlbHBlclRvLmI7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdpdmVuIHByb3BlcnR5IG5hbWUsIGNoZWNrIHNjaGVtYSB0byBzZWUgd2hhdCB0eXBlIHdlIGFyZSBhbmltYXRpbmcuXG4gKiBXZSBqdXN0IGNhcmUgd2hldGhlciB0aGUgcHJvcGVydHkgaXMgYSB2ZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BlcnR5VHlwZSAoZWwsIHByb3BlcnR5KSB7XG4gIHZhciBjb21wb25lbnQ7XG4gIHZhciBjb21wb25lbnROYW1lO1xuICB2YXIgc3BsaXQ7XG4gIHZhciBwcm9wZXJ0eU5hbWU7XG5cbiAgc3BsaXQgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICBjb21wb25lbnROYW1lID0gc3BsaXRbMF07XG4gIHByb3BlcnR5TmFtZSA9IHNwbGl0WzFdO1xuICBjb21wb25lbnQgPSBlbC5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdIHx8IEFGUkFNRS5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdO1xuXG4gIC8vIFByaW1pdGl2ZXMuXG4gIGlmICghY29tcG9uZW50KSB7IHJldHVybiBudWxsOyB9XG5cbiAgLy8gRHluYW1pYyBzY2hlbWEuIFdlIG9ubHkgY2FyZSBhYm91dCB2ZWN0b3JzIGFueXdheXMuXG4gIGlmIChwcm9wZXJ0eU5hbWUgJiYgIWNvbXBvbmVudC5zY2hlbWFbcHJvcGVydHlOYW1lXSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIC8vIE11bHRpLXByb3AuXG4gIGlmIChwcm9wZXJ0eU5hbWUpIHsgcmV0dXJuIGNvbXBvbmVudC5zY2hlbWFbcHJvcGVydHlOYW1lXS50eXBlOyB9XG5cbiAgLy8gU2luZ2xlLXByb3AuXG4gIHJldHVybiBjb21wb25lbnQuc2NoZW1hLnR5cGU7XG59XG5cbi8qKlxuICogQ29udmVydCBvYmplY3QgdG8gcmFkaWFucy5cbiAqL1xuZnVuY3Rpb24gdG9SYWRpYW5zIChvYmopIHtcbiAgb2JqLnggPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKG9iai54KTtcbiAgb2JqLnkgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKG9iai55KTtcbiAgb2JqLnogPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKG9iai56KTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMgKGVsLCBldmVudE5hbWVzLCBoYW5kbGVyKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lc1tpXSwgaGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgKGVsLCBldmVudE5hbWVzLCBoYW5kbGVyKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lc1tpXSwgaGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmF3UHJvcGVydHkgKGVsLCBwYXRoKSB7XG4gIHZhciBpO1xuICB2YXIgc3BsaXQ7XG4gIHZhciB2YWx1ZTtcbiAgc3BsaXQgPSBzcGxpdERvdChwYXRoKTtcbiAgdmFsdWUgPSBlbDtcbiAgZm9yIChpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVtzcGxpdFtpXV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBzZXRSYXdQcm9wZXJ0eSAoZWwsIHBhdGgsIHZhbHVlLCB0eXBlKSB7XG4gIHZhciBpO1xuICB2YXIgc3BsaXQ7XG4gIHZhciBwcm9wZXJ0eU5hbWU7XG4gIHZhciB0YXJnZXRWYWx1ZTtcblxuICAvLyBXYWxrLlxuICBzcGxpdCA9IHNwbGl0RG90KHBhdGgpO1xuICB0YXJnZXRWYWx1ZSA9IGVsO1xuICBmb3IgKGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoIC0gMTsgaSsrKSB7IHRhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWVbc3BsaXRbaV1dOyB9XG4gIHByb3BlcnR5TmFtZSA9IHNwbGl0W3NwbGl0Lmxlbmd0aCAtIDFdO1xuXG4gIC8vIFJhdyBjb2xvci5cbiAgaWYgKHR5cGUgPT09IFRZUEVfQ09MT1IpIHtcbiAgICBpZiAoJ3InIGluIHRhcmdldFZhbHVlW3Byb3BlcnR5TmFtZV0pIHtcbiAgICAgIHRhcmdldFZhbHVlW3Byb3BlcnR5TmFtZV0uciA9IHZhbHVlLnI7XG4gICAgICB0YXJnZXRWYWx1ZVtwcm9wZXJ0eU5hbWVdLmcgPSB2YWx1ZS5nO1xuICAgICAgdGFyZ2V0VmFsdWVbcHJvcGVydHlOYW1lXS5iID0gdmFsdWUuYjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0VmFsdWVbcHJvcGVydHlOYW1lXS54ID0gdmFsdWUucjtcbiAgICAgIHRhcmdldFZhbHVlW3Byb3BlcnR5TmFtZV0ueSA9IHZhbHVlLmc7XG4gICAgICB0YXJnZXRWYWx1ZVtwcm9wZXJ0eU5hbWVdLnogPSB2YWx1ZS5iO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB0YXJnZXRWYWx1ZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNwbGl0RG90IChwYXRoKSB7XG4gIGlmIChwYXRoIGluIHNwbGl0Q2FjaGUpIHsgcmV0dXJuIHNwbGl0Q2FjaGVbcGF0aF07IH1cbiAgc3BsaXRDYWNoZVtwYXRoXSA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIHNwbGl0Q2FjaGVbcGF0aF07XG59XG5cbmZ1bmN0aW9uIGlzUmF3UHJvcGVydHkgKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuaXNSYXdQcm9wZXJ0eSB8fCBkYXRhLnByb3BlcnR5LnN0YXJ0c1dpdGgoU1RSSU5HX0NPTVBPTkVOVFMpIHx8XG4gICAgICAgICBkYXRhLnByb3BlcnR5LnN0YXJ0c1dpdGgoU1RSSU5HX09CSkVDVDNEKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtYW5pbWF0aW9uLWNvbXBvbmVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBBRlJBTUUsIFRIUkVFICovXHJcbmlmICh0eXBlb2YgQUZSQU1FID09PSAndW5kZWZpbmVkJykge1xyXG4gIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGF0dGVtcHRlZCB0byByZWdpc3RlciBiZWZvcmUgQUZSQU1FIHdhcyBhdmFpbGFibGUuJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDdWJlbWFwIGNvbXBvbmVudCBmb3IgQS1GcmFtZS5cclxuICovXHJcbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnY3ViZW1hcCcsIHtcclxuICBzY2hlbWE6IHtcclxuICAgIGZvbGRlcjoge1xyXG4gICAgICB0eXBlOiAnc3RyaW5nJ1xyXG4gICAgfSxcclxuICAgIGVkZ2VMZW5ndGg6IHtcclxuICAgICAgdHlwZTogJ2ludCcsXHJcbiAgICAgIGRlZmF1bHQ6IDUwMDBcclxuICAgIH0sXHJcbiAgICBleHQ6IHtcclxuICAgICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICAgIGRlZmF1bHQ6ICdqcGcnXHJcbiAgICB9LFxyXG4gICAgdHJhbnNwYXJlbnQ6IHtcclxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxyXG4gICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIGNvbXBvbmVudCBpcyBhdHRhY2hlZCBhbmQgd2hlbiBjb21wb25lbnQgZGF0YSBjaGFuZ2VzLlxyXG4gICAqIEdlbmVyYWxseSBtb2RpZmllcyB0aGUgZW50aXR5IGJhc2VkIG9uIHRoZSBkYXRhLlxyXG4gICAqL1xyXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcclxuICAgIC8vIGVudGl0eSBkYXRhXHJcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgLy8gUGF0aCB0byB0aGUgZm9sZGVyIGNvbnRhaW5pbmcgdGhlIDYgY3ViZW1hcCBpbWFnZXNcclxuICAgIHZhciBzcmNQYXRoID0gZGF0YS5mb2xkZXI7XHJcblxyXG4gICAgLy8gQ3ViZW1hcCBpbWFnZSBmaWxlcyBtdXN0IGZvbGxvdyB0aGlzIG5hbWluZyBzY2hlbWVcclxuICAgIC8vIGZyb206IGh0dHA6Ly90aHJlZWpzLm9yZy9kb2NzL2luZGV4Lmh0bWwjUmVmZXJlbmNlL1RleHR1cmVzL0N1YmVUZXh0dXJlXHJcbiAgICB2YXIgdXJscyA9IFtcclxuICAgICAgJ3Bvc3gnLCAnbmVneCcsXHJcbiAgICAgICdwb3N5JywgJ25lZ3knLFxyXG4gICAgICAncG9zeicsICduZWd6J1xyXG4gICAgXTtcclxuICAgIC8vIEFwcGx5IGV4dGVuc2lvblxyXG4gICAgdXJscyA9IHVybHMubWFwKGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICByZXR1cm4gdmFsICsgXCIuXCIgKyBkYXRhLmV4dDtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENvZGUgdGhhdCBmb2xsb3dzIGlzIGFkYXB0ZWQgZnJvbSBcIlNreWJveCBhbmQgZW52aXJvbm1lbnQgbWFwIGluIFRocmVlLmpzXCIgYnkgUm9tYW4gTGl1dGlrb3ZcclxuICAgIC8vIGh0dHA6Ly9ibG9nLnJvbWFubGl1dGlrb3YuY29tL3Bvc3QvNTg3MDU4NDA2OTgvc2t5Ym94LWFuZC1lbnZpcm9ubWVudC1tYXAtaW4tdGhyZWVqc1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbJ2N1YmUnXTsgLy8gaW5pdCBjdWJlIHNoYWRlciBmcm9tIGJ1aWx0LWluIGxpYlxyXG5cclxuICAgIC8vIENyZWF0ZSBzaGFkZXIgbWF0ZXJpYWxcclxuICAgIHZhciBza3lCb3hTaGFkZXIgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xyXG4gICAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLFxyXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgIHVuaWZvcm1zOiBzaGFkZXIudW5pZm9ybXMsXHJcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxyXG4gICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZSxcclxuICAgICAgdHJhbnNwYXJlbnQ6IGRhdGEudHJhbnNwYXJlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNldCBza3lib3ggZGltZW5zaW9uc1xyXG4gICAgdmFyIGVkZ2VMZW5ndGggPSBkYXRhLmVkZ2VMZW5ndGg7XHJcbiAgICB2YXIgc2t5Qm94R2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KGVkZ2VMZW5ndGgsIGVkZ2VMZW5ndGgsIGVkZ2VMZW5ndGgpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBsb2FkZXIsIHNldCBmb2xkZXIgcGF0aCwgYW5kIGxvYWQgY3ViZW1hcCB0ZXh0dXJlc1xyXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xyXG4gICAgbG9hZGVyLnNldFBhdGgoc3JjUGF0aCk7XHJcbiAgICBsb2FkZXIubG9hZCh1cmxzLCBmdW5jdGlvbih0ZXh0dXJlKSB7XHJcbiAgICAgIC8vIENsb25lIFNoYWRlck1hdGVyaWFsIChuZWNlc3NhcnkgZm9yIG11bHRpcGxlIGN1YmVtYXBzKVxyXG4gICAgICB2YXIgc2t5Qm94TWF0ZXJpYWwgPSBza3lCb3hTaGFkZXIuY2xvbmUoKTtcclxuICAgICAgc2t5Qm94TWF0ZXJpYWwudW5pZm9ybXNbJ3RDdWJlJ10udmFsdWUgPSB0ZXh0dXJlOyAvLyBBcHBseSBjdWJlbWFwIHRleHR1cmVzIHRvIHNoYWRlciB1bmlmb3Jtc1xyXG5cclxuICAgICAgLy8gU2V0IGVudGl0eSdzIG9iamVjdDNEXHJcbiAgICAgIGVsLnNldE9iamVjdDNEKCdjdWJlbWFwJywgbmV3IFRIUkVFLk1lc2goc2t5Qm94R2VvbWV0cnksIHNreUJveE1hdGVyaWFsKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVtb3ZlZCAoZS5nLiwgdmlhIHJlbW92ZUF0dHJpYnV0ZSkuXHJcbiAgICogR2VuZXJhbGx5IHVuZG9lcyBhbGwgbW9kaWZpY2F0aW9ucyB0byB0aGUgZW50aXR5LlxyXG4gICAqL1xyXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5lbC5yZW1vdmVPYmplY3QzRCgnY3ViZW1hcCcpO1xyXG4gIH1cclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtY3ViZW1hcC1jb21wb25lbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWwgQUZSQU1FICovXG52YXIgc3R5bGVQYXJzZXIgPSBBRlJBTUUudXRpbHMuc3R5bGVQYXJzZXI7XG5cbmlmICh0eXBlb2YgQUZSQU1FID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBhdHRlbXB0ZWQgdG8gcmVnaXN0ZXIgYmVmb3JlIEFGUkFNRSB3YXMgYXZhaWxhYmxlLicpO1xufVxuXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2V2ZW50LXNldCcsIHtcbiAgc2NoZW1hOiB7XG4gICAgZGVmYXVsdDogJycsXG4gICAgcGFyc2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHN0eWxlUGFyc2VyLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgbXVsdGlwbGU6IHRydWUsXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50TmFtZSA9IG51bGw7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgIHRoaXMudXBkYXRlRXZlbnRMaXN0ZW5lcigpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc291cmNlLW9mLXRydXRoIGV2ZW50IGxpc3RlbmVyIHJlZ2lzdHJ5LlxuICAgKiBEb2VzIG5vdCBhY3R1YWxseSBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHlldC5cbiAgICovXG4gIHVwZGF0ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBldmVudDtcbiAgICB2YXIgdGFyZ2V0O1xuICAgIHZhciB0YXJnZXRFbDtcblxuICAgIC8vIFNldCBldmVudCBsaXN0ZW5lciB1c2luZyBgX2V2ZW50YC5cbiAgICBldmVudCA9IGRhdGEuX2V2ZW50IHx8IHRoaXMuaWQ7XG4gICAgdGFyZ2V0ID0gZGF0YS5fdGFyZ2V0O1xuXG4gICAgLy8gRGVjaWRlIHRoZSB0YXJnZXQgdG8gYHNldEF0dHJpYnV0ZWAgb24uXG4gICAgdGFyZ2V0RWwgPSB0YXJnZXQgPyBlbC5zY2VuZUVsLnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KSA6IGVsO1xuXG4gICAgdGhpcy5ldmVudE5hbWUgPSBldmVudDtcbiAgICB0aGlzLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIgKCkge1xuICAgICAgdmFyIHByb3BOYW1lO1xuICAgICAgLy8gU2V0IGF0dHJpYnV0ZXMuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lID09PSAnX2V2ZW50JyB8fCBwcm9wTmFtZSA9PT0gJ190YXJnZXQnKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIEFGUkFNRS51dGlscy5lbnRpdHkuc2V0Q29tcG9uZW50UHJvcGVydHkuY2FsbCh0aGlzLCB0YXJnZXRFbCwgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtZXZlbnQtc2V0LWNvbXBvbmVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBBRlJBTUUgKi9cblxuaWYgKHR5cGVvZiBBRlJBTUUgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGF0dGVtcHRlZCB0byByZWdpc3RlciBiZWZvcmUgQUZSQU1FIHdhcyBhdmFpbGFibGUuJyk7XG59XG5cbi8qKlxuICogSGFwdGljcyBjb21wb25lbnQgZm9yIEEtRnJhbWUuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnaGFwdGljcycsIHtcbiAgZGVwZW5kZW5jaWVzOiBbJ3RyYWNrZWQtY29udHJvbHMnXSxcblxuICBzY2hlbWE6IHtcbiAgICBhY3R1YXRvckluZGV4OiB7ZGVmYXVsdDogMH0sXG4gICAgZHVyOiB7ZGVmYXVsdDogMTAwfSxcbiAgICBlbmFibGVkOiB7ZGVmYXVsdDogdHJ1ZX0sXG4gICAgZXZlbnRzOiB7dHlwZTogJ2FycmF5J30sXG4gICAgZXZlbnRzRnJvbToge3R5cGU6ICdzdHJpbmcnfSxcbiAgICBmb3JjZToge2RlZmF1bHQ6IDF9XG4gIH0sXG5cbiAgbXVsdGlwbGU6IHRydWUsXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuY2FsbFB1bHNlID0gZnVuY3Rpb24gKCkgeyBzZWxmLnB1bHNlKCk7IH07XG5cbiAgICBpZiAodGhpcy5lbC5jb21wb25lbnRzWyd0cmFja2VkLWNvbnRyb2xzJ10uY29udHJvbGxlcikge1xuICAgICAgdGhpcy5nYW1lcGFkID0gdGhpcy5lbC5jb21wb25lbnRzWyd0cmFja2VkLWNvbnRyb2xzJ10uY29udHJvbGxlcjtcbiAgICAgIGlmICghdGhpcy5nYW1lcGFkIHx8ICF0aGlzLmdhbWVwYWQuaGFwdGljQWN0dWF0b3JzLmxlbmd0aCkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjb250cm9sbGVyY29ubmVjdGVkJywgZnVuY3Rpb24gaW5pdCAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuZ2FtZXBhZCA9IHNlbGYuZWwuY29tcG9uZW50c1sndHJhY2tlZC1jb250cm9scyddLmNvbnRyb2xsZXI7XG4gICAgICAgICAgaWYgKCFzZWxmLmdhbWVwYWQgfHwgIXNlbGYuZ2FtZXBhZC5oYXB0aWNBY3R1YXRvcnMubGVuZ3RoKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSwgMTUwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgcHVsc2U6IGZ1bmN0aW9uIChmb3JjZSwgZHVyKSB7XG4gICAgdmFyIGFjdHVhdG9yO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGlmICghZGF0YS5lbmFibGVkIHx8ICF0aGlzLmdhbWVwYWQgfHwgIXRoaXMuZ2FtZXBhZC5oYXB0aWNBY3R1YXRvcnMpIHsgcmV0dXJuOyB9XG4gICAgYWN0dWF0b3IgPSB0aGlzLmdhbWVwYWQuaGFwdGljQWN0dWF0b3JzW2RhdGEuYWN0dWF0b3JJbmRleF07XG4gICAgYWN0dWF0b3IucHVsc2UoZm9yY2UgfHwgZGF0YS5mb3JjZSwgZHVyIHx8IGRhdGEuZHVyKTtcbiAgfSxcblxuICBhZGRFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBpO1xuICAgIHZhciBsaXN0ZW5UYXJnZXQ7XG5cbiAgICBsaXN0ZW5UYXJnZXQgPSBkYXRhLmV2ZW50c0Zyb20gPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRhdGEuZXZlbnRzRnJvbSkgOiB0aGlzLmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZGF0YS5ldmVudHNbaV0sIHRoaXMuY2FsbFB1bHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGlzdGVuVGFyZ2V0O1xuXG4gICAgbGlzdGVuVGFyZ2V0ID0gZGF0YS5ldmVudHNGcm9tID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihkYXRhLmV2ZW50c0Zyb20pIDogdGhpcy5lbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlblRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGRhdGEuZXZlbnRzW2ldLCB0aGlzLmNhbGxQdWxzZSk7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtaGFwdGljcy1jb21wb25lbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcG9zaXRpb25zID0gW107XG52YXIgcG9zaXRpb25IZWxwZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4vKipcbiAqIExheW91dCBjb21wb25lbnQgZm9yIEEtRnJhbWUuXG4gKiBTb21lIGxheW91dHMgYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cudmItaGVscGVyLmNvbS90dXRvcmlhbF9wbGF0b25pY19zb2xpZHMuaHRtbFxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2xheW91dCcsIHtcbiAgc2NoZW1hOiB7XG4gICAgYW5nbGU6IHt0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogZmFsc2UsIG1pbjogMCwgbWF4OiAzNjAsIGlmOiB7dHlwZTogWydjaXJjbGUnXX19LFxuICAgIGNvbHVtbnM6IHtkZWZhdWx0OiAxLCBtaW46IDAsIGlmOiB7dHlwZTogWydib3gnXX19LFxuICAgIG1hcmdpbjoge2RlZmF1bHQ6IDEsIG1pbjogMCwgaWY6IHt0eXBlOiBbJ2JveCcsICdsaW5lJ119fSxcbiAgICBtYXJnaW5Db2x1bW46IHtkZWZhdWx0OiAxLCBtaW46IDAsIGlmOiB7dHlwZTogWydib3gnXX19LFxuICAgIG1hcmdpblJvdzoge2RlZmF1bHQ6IDEsIG1pbjogMCwgaWY6IHt0eXBlOiBbJ2JveCddfX0sXG4gICAgb3JkZXJBdHRyaWJ1dGU6IHtkZWZhdWx0OiAnJ30sXG4gICAgcGxhbmU6IHtkZWZhdWx0OiAneHknfSxcbiAgICByYWRpdXM6IHtkZWZhdWx0OiAxLCBtaW46IDAsIGlmOiB7dHlwZTogWydjaXJjbGUnLCAnY3ViZScsICdkb2RlY2FoZWRyb24nLCAncHlyYW1pZCddfX0sXG4gICAgcmV2ZXJzZToge2RlZmF1bHQ6IGZhbHNlfSxcbiAgICB0eXBlOiB7ZGVmYXVsdDogJ2xpbmUnLCBvbmVPZjogWydib3gnLCAnY2lyY2xlJywgJ2N1YmUnLCAnZG9kZWNhaGVkcm9uJywgJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3B5cmFtaWQnXX0sXG4gICAgZmlsbDoge2RlZmF1bHQ6IHRydWUsIGlmOiB7dHlwZTogWydjaXJjbGUnXX19LFxuICAgIGFsaWduOiB7ZGVmYXVsdDogJ2VuZCcsIG9uZU9mOiBbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnXX1cbiAgfSxcblxuICAvKipcbiAgICogU3RvcmUgaW5pdGlhbCBwb3NpdGlvbnMgaW4gY2FzZSBuZWVkIHRvIHJlc2V0IG9uIGNvbXBvbmVudCByZW1vdmFsLlxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgdGhpcy5jaGlsZHJlbiA9IGVsLmdldENoaWxkRW50aXRpZXMoKTtcbiAgICB0aGlzLmluaXRpYWxQb3NpdGlvbnMgPSBbXTtcblxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiBnZXRJbml0aWFsUG9zaXRpb25zIChjaGlsZEVsKSB7XG4gICAgICBpZiAoY2hpbGRFbC5oYXNMb2FkZWQpIHsgcmV0dXJuIF9nZXRQb3NpdGlvbnMoKTsgfVxuICAgICAgY2hpbGRFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBfZ2V0UG9zaXRpb25zKTtcbiAgICAgIGZ1bmN0aW9uIF9nZXRQb3NpdGlvbnMgKCkge1xuICAgICAgICBzZWxmLmluaXRpYWxQb3NpdGlvbnMucHVzaChjaGlsZEVsLm9iamVjdDNELnBvc2l0aW9uLngpO1xuICAgICAgICBzZWxmLmluaXRpYWxQb3NpdGlvbnMucHVzaChjaGlsZEVsLm9iamVjdDNELnBvc2l0aW9uLnkpO1xuICAgICAgICBzZWxmLmluaXRpYWxQb3NpdGlvbnMucHVzaChjaGlsZEVsLm9iamVjdDNELnBvc2l0aW9uLnopO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5oYW5kbGVDaGlsZEF0dGFjaGVkID0gdGhpcy5oYW5kbGVDaGlsZEF0dGFjaGVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDaGlsZERldGFjaGVkID0gdGhpcy5oYW5kbGVDaGlsZERldGFjaGVkLmJpbmQodGhpcyk7XG5cbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGlsZC1hdHRhY2hlZCcsIHRoaXMuaGFuZGxlQ2hpbGRBdHRhY2hlZCk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hpbGQtZGV0YWNoZWQnLCB0aGlzLmhhbmRsZUNoaWxkRGV0YWNoZWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY2hpbGQgZW50aXR5IHBvc2l0aW9ucy5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBkZWZpbmVkRGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBudW1DaGlsZHJlbjtcbiAgICB2YXIgcG9zaXRpb25GbjtcblxuICAgIG51bUNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpZmZlcmVudCBwb3NpdGlvbnMgYmFzZWQgb24gbGF5b3V0IHNoYXBlLlxuICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICBjYXNlICdib3gnOiB7XG4gICAgICAgIHBvc2l0aW9uRm4gPSBnZXRCb3hQb3NpdGlvbnM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY2lyY2xlJzoge1xuICAgICAgICBwb3NpdGlvbkZuID0gZ2V0Q2lyY2xlUG9zaXRpb25zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2N1YmUnOiB7XG4gICAgICAgIHBvc2l0aW9uRm4gPSBnZXRDdWJlUG9zaXRpb25zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2RvZGVjYWhlZHJvbic6IHtcbiAgICAgICAgcG9zaXRpb25GbiA9IGdldERvZGVjYWhlZHJvblBvc2l0aW9ucztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdweXJhbWlkJzoge1xuICAgICAgICBwb3NpdGlvbkZuID0gZ2V0UHlyYW1pZFBvc2l0aW9ucztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIExpbmUuXG4gICAgICAgIHBvc2l0aW9uRm4gPSBnZXRMaW5lUG9zaXRpb25zO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmluZWREYXRhID0gZWwuZ2V0RE9NQXR0cmlidXRlKCdsYXlvdXQnKTtcbiAgICBwb3NpdGlvbnMubGVuZ3RoID0gMDtcbiAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbkZuKFxuICAgICAgZGF0YSwgbnVtQ2hpbGRyZW4sXG4gICAgICB0eXBlb2YgZGVmaW5lZERhdGEgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZGVmaW5lZERhdGEuaW5kZXhPZignbWFyZ2luJykgIT09IC0xXG4gICAgICAgIDogJ21hcmdpbicgaW4gZGVmaW5lZERhdGFcbiAgICApO1xuICAgIGlmIChkYXRhLnJldmVyc2UpIHsgcG9zaXRpb25zLnJldmVyc2UoKTsgfVxuICAgIHNldFBvc2l0aW9ucyhjaGlsZHJlbiwgcG9zaXRpb25zLCBkYXRhLm9yZGVyQXR0cmlidXRlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXQgcG9zaXRpb25zLlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGlsZC1hdHRhY2hlZCcsIHRoaXMuaGFuZGxlQ2hpbGRBdHRhY2hlZCk7XG4gICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGlsZC1kZXRhY2hlZCcsIHRoaXMuaGFuZGxlQ2hpbGREZXRhY2hlZCk7XG4gICAgc2V0UG9zaXRpb25zKHRoaXMuY2hpbGRyZW4sIHRoaXMuaW5pdGlhbFBvc2l0aW9ucyk7XG4gIH0sXG5cbiAgaGFuZGxlQ2hpbGRBdHRhY2hlZDogZnVuY3Rpb24gKGV2dCkge1xuICAgIC8vIE9ubHkgdXBkYXRlIGlmIGRpcmVjdCBjaGlsZCBhdHRhY2hlZC5cbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmIChldnQuZGV0YWlsLmVsLnBhcmVudE5vZGUgIT09IGVsKSB7IHJldHVybjsgfVxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChldnQuZGV0YWlsLmVsKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9LFxuXG4gIGhhbmRsZUNoaWxkRGV0YWNoZWQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAvLyBPbmx5IHVwZGF0ZSBpZiBkaXJlY3QgY2hpbGQgZGV0YWNoZWQuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4uaW5kZXhPZihldnQuZGV0YWlsLmVsKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UodGhpcy5jaGlsZHJlbi5pbmRleE9mKGV2dC5kZXRhaWwuZWwpLCAxKTtcbiAgICB0aGlzLmluaXRpYWxQb3NpdGlvbnMuc3BsaWNlKHRoaXMuY2hpbGRyZW4uaW5kZXhPZihldnQuZGV0YWlsLmVsKSwgMSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHBvc2l0aW9ucyBmb3IgYGJveGAgbGF5b3V0LlxuICovXG5mdW5jdGlvbiBnZXRCb3hQb3NpdGlvbnMgKGRhdGEsIG51bUNoaWxkcmVuLCBtYXJnaW5EZWZpbmVkKSB7XG4gIHZhciBjb2x1bW47XG4gIHZhciBtYXJnaW5Db2x1bW47XG4gIHZhciBtYXJnaW5Sb3c7XG4gIHZhciBvZmZzZXRDb2x1bW47XG4gIHZhciBvZmZzZXRSb3c7XG4gIHZhciByb3c7XG4gIHZhciByb3dzID0gTWF0aC5jZWlsKG51bUNoaWxkcmVuIC8gZGF0YS5jb2x1bW5zKTtcblxuICBtYXJnaW5Db2x1bW4gPSBkYXRhLm1hcmdpbkNvbHVtbjtcbiAgbWFyZ2luUm93ID0gZGF0YS5tYXJnaW5Sb3c7XG4gIGlmIChtYXJnaW5EZWZpbmVkKSB7XG4gICAgbWFyZ2luQ29sdW1uID0gZGF0YS5tYXJnaW47XG4gICAgbWFyZ2luUm93ID0gZGF0YS5tYXJnaW47XG4gIH1cblxuICBvZmZzZXRSb3cgPSBnZXRPZmZzZXRJdGVtSW5kZXgoZGF0YS5hbGlnbiwgcm93cyk7XG4gIG9mZnNldENvbHVtbiA9IGdldE9mZnNldEl0ZW1JbmRleChkYXRhLmFsaWduLCBkYXRhLmNvbHVtbnMpO1xuXG4gIGZvciAocm93ID0gMDsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICBmb3IgKGNvbHVtbiA9IDA7IGNvbHVtbiA8IGRhdGEuY29sdW1uczsgY29sdW1uKyspIHtcbiAgICAgIHBvc2l0aW9uSGVscGVyLnNldCgwLCAwLCAwKTtcbiAgICAgIGlmIChkYXRhLnBsYW5lLmluZGV4T2YoJ3gnKSA9PT0gMCkge1xuICAgICAgICBwb3NpdGlvbkhlbHBlci54ID0gKGNvbHVtbiAtIG9mZnNldENvbHVtbikgKiBtYXJnaW5Db2x1bW47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5wbGFuZS5pbmRleE9mKCd5JykgPT09IDApIHtcbiAgICAgICAgcG9zaXRpb25IZWxwZXIueSA9IChjb2x1bW4gLSBvZmZzZXRDb2x1bW4pICogbWFyZ2luQ29sdW1uO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucGxhbmUuaW5kZXhPZigneScpID09PSAxKSB7XG4gICAgICAgIHBvc2l0aW9uSGVscGVyLnkgPSAocm93IC0gb2Zmc2V0Um93KSAqIG1hcmdpblJvdztcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnBsYW5lLmluZGV4T2YoJ3onKSA9PT0gMSkge1xuICAgICAgICBwb3NpdGlvbkhlbHBlci56ID0gKHJvdyAtIG9mZnNldFJvdykgKiBtYXJnaW5Sb3c7XG4gICAgICB9XG4gICAgICBwdXNoUG9zaXRpb25WZWMzKHBvc2l0aW9uSGVscGVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb25zO1xufVxubW9kdWxlLmV4cG9ydHMuZ2V0Qm94UG9zaXRpb25zID0gZ2V0Qm94UG9zaXRpb25zO1xuXG4vKipcbiAqIEdldCBwb3NpdGlvbnMgZm9yIGBjaXJjbGVgIGxheW91dC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2lyY2xlUG9zaXRpb25zIChkYXRhLCBudW1DaGlsZHJlbikge1xuICB2YXIgaTtcbiAgdmFyIHJhZDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbnVtQ2hpbGRyZW47IGkrKykge1xuICAgIHJhZDtcblxuICAgIGlmIChpc05hTihkYXRhLmFuZ2xlKSkge1xuICAgICAgcmFkID0gaSAqICgyICogTWF0aC5QSSkgLyBudW1DaGlsZHJlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFkID0gaSAqIGRhdGEuYW5nbGUgKiAwLjAxNzQ1MzI5MjUyOyAgLy8gQW5nbGUgdG8gcmFkaWFuLlxuICAgIH1cblxuICAgIHBvc2l0aW9uSGVscGVyLnNldCgwLCAwLCAwKTtcbiAgICBpZiAoZGF0YS5wbGFuZS5pbmRleE9mKCd4JykgPT09IDApIHtcbiAgICAgIHBvc2l0aW9uSGVscGVyLnggPSBkYXRhLnJhZGl1cyAqIE1hdGguY29zKHJhZCk7XG4gICAgfVxuICAgIGlmIChkYXRhLnBsYW5lLmluZGV4T2YoJ3knKSA9PT0gMCkge1xuICAgICAgcG9zaXRpb25IZWxwZXIueSA9IGRhdGEucmFkaXVzICogTWF0aC5jb3MocmFkKTtcbiAgICB9XG4gICAgaWYgKGRhdGEucGxhbmUuaW5kZXhPZigneScpID09PSAxKSB7XG4gICAgICBwb3NpdGlvbkhlbHBlci55ID0gZGF0YS5yYWRpdXMgKiBNYXRoLnNpbihyYWQpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5wbGFuZS5pbmRleE9mKCd6JykgPT09IDEpIHtcbiAgICAgIHBvc2l0aW9uSGVscGVyLnogPSBkYXRhLnJhZGl1cyAqIE1hdGguc2luKHJhZCk7XG4gICAgfVxuICAgIHB1c2hQb3NpdGlvblZlYzMocG9zaXRpb25IZWxwZXIpO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbnM7XG59XG5tb2R1bGUuZXhwb3J0cy5nZXRDaXJjbGVQb3NpdGlvbnMgPSBnZXRDaXJjbGVQb3NpdGlvbnM7XG5cbi8qKlxuICogR2V0IHBvc2l0aW9ucyBmb3IgYGxpbmVgIGxheW91dC5cbiAqIFRPRE86IDNEIG1hcmdpbnMuXG4gKi9cbmZ1bmN0aW9uIGdldExpbmVQb3NpdGlvbnMgKGRhdGEsIG51bUNoaWxkcmVuKSB7XG4gIGRhdGEuY29sdW1ucyA9IG51bUNoaWxkcmVuO1xuICByZXR1cm4gZ2V0Qm94UG9zaXRpb25zKGRhdGEsIG51bUNoaWxkcmVuLCB0cnVlKTtcbn1cbm1vZHVsZS5leHBvcnRzLmdldExpbmVQb3NpdGlvbnMgPSBnZXRMaW5lUG9zaXRpb25zO1xuXG4vKipcbiAqIEdldCBwb3NpdGlvbnMgZm9yIGBjdWJlYCBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGdldEN1YmVQb3NpdGlvbnMgKGRhdGEsIG51bUNoaWxkcmVuKSB7XG4gIHB1c2hQb3NpdGlvbnMoXG4gICAgMSwgMCwgMCxcbiAgICAwLCAxLCAwLFxuICAgIDAsIDAsIDEsXG4gICAgLTEsIDAsIDAsXG4gICAgMCwgLTEsIDAsXG4gICAgMCwgMCwgLTFcbiAgKTtcbiAgc2NhbGVQb3NpdGlvbnMoZGF0YS5yYWRpdXMgLyAyKTtcbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cbm1vZHVsZS5leHBvcnRzLmdldEN1YmVQb3NpdGlvbnMgPSBnZXRDdWJlUG9zaXRpb25zO1xuXG4vKipcbiAqIEdldCBwb3NpdGlvbnMgZm9yIGBkb2RlY2FoZWRyb25gIGxheW91dC5cbiAqL1xuZnVuY3Rpb24gZ2V0RG9kZWNhaGVkcm9uUG9zaXRpb25zIChkYXRhLCBudW1DaGlsZHJlbikge1xuICB2YXIgUEhJID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcbiAgdmFyIEIgPSAxIC8gUEhJO1xuICB2YXIgQyA9IDIgLSBQSEk7XG4gIHZhciBOQiA9IC0xICogQjtcbiAgdmFyIE5DID0gLTEgKiBDO1xuICBwdXNoUG9zaXRpb25zKFxuICAgIC0xLCBDLCAwLFxuICAgIC0xLCBOQywgMCxcbiAgICAwLCAtMSwgQyxcbiAgICAwLCAtMSwgTkMsXG4gICAgMCwgMSwgQyxcbiAgICAwLCAxLCBOQyxcbiAgICAxLCBDLCAwLFxuICAgIDEsIE5DLCAwLFxuICAgIEIsIEIsIEIsXG4gICAgQiwgQiwgTkIsXG4gICAgQiwgTkIsIEIsXG4gICAgQiwgTkIsIE5CLFxuICAgIEMsIDAsIDEsXG4gICAgQywgMCwgLTEsXG4gICAgTkIsIEIsIEIsXG4gICAgTkIsIEIsIE5CLFxuICAgIE5CLCBOQiwgQixcbiAgICBOQiwgTkIsIE5CLFxuICAgIE5DLCAwLCAxLFxuICAgIE5DLCAwLCAtMVxuICApO1xuICBzY2FsZVBvc2l0aW9ucyhkYXRhLnJhZGl1cyAvIDIpO1xuICByZXR1cm4gcG9zaXRpb25zO1xufVxubW9kdWxlLmV4cG9ydHMuZ2V0RG9kZWNhaGVkcm9uUG9zaXRpb25zID0gZ2V0RG9kZWNhaGVkcm9uUG9zaXRpb25zO1xuXG4vKipcbiAqIEdldCBwb3NpdGlvbnMgZm9yIGBweXJhbWlkYCBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGdldFB5cmFtaWRQb3NpdGlvbnMgKGRhdGEsIG51bUNoaWxkcmVuKSB7XG4gIHZhciBTUVJUXzMgPSBNYXRoLnNxcnQoMyk7XG4gIHZhciBORUdfU1FSVF8xXzMgPSAtMSAvIE1hdGguc3FydCgzKTtcbiAgdmFyIERCTF9TUVJUXzJfMyA9IDIgKiBNYXRoLnNxcnQoMiAvIDMpO1xuICBwdXNoUG9zaXRpb25zKFxuICAgIDAsIDAsIFNRUlRfMyArIE5FR19TUVJUXzFfMyxcbiAgICAtMSwgMCwgTkVHX1NRUlRfMV8zLFxuICAgIDEsIDAsIE5FR19TUVJUXzFfMyxcbiAgICAwLCBEQkxfU1FSVF8yXzMsIDBcbiAgKTtcbiAgc2NhbGVQb3NpdGlvbnMoZGF0YS5yYWRpdXMgLyAyKTtcbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cbm1vZHVsZS5leHBvcnRzLmdldFB5cmFtaWRQb3NpdGlvbnMgPSBnZXRQeXJhbWlkUG9zaXRpb25zO1xuXG4vKipcbiAqIFJldHVybiB0aGUgaXRlbSBpbmRleCBpbiBhIGdpdmVuIGxpc3QgdG8gY2FsY3VsYXRlIG9mZnNldHMgZnJvbVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiAtIE9uZSBvZiBgJ3N0YXJ0J2AsIGAnY2VudGVyJ2AsIGAnZW5kJ2BcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbnVtSXRlbXMgLSBUb3RhbCBudW1iZXIgb2YgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0SXRlbUluZGV4IChhbGlnbiwgbnVtSXRlbXMpIHtcbiAgc3dpdGNoIChhbGlnbikge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiBudW1JdGVtcyAtIDE7XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHJldHVybiAobnVtSXRlbXMgLSAxKSAvIDI7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8qKlxuICogTXVsdGlwbHkgYWxsIGNvb3JkaW5hdGVzIGJ5IGEgc2NhbGUgZmFjdG9yIGFuZCBhZGQgdHJhbnNsYXRlLlxuICpcbiAqIEBwYXJhbXMge2FycmF5fSBwb3NpdGlvbnMgLSBBcnJheSBvZiBjb29yZGluYXRlcyBpbiBhcnJheSBmb3JtLlxuICogQHJldHVybnMge2FycmF5fSBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gc2NhbGVQb3NpdGlvbnMgKHNjYWxlKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2ldID0gcG9zaXRpb25zW2ldICogc2NhbGU7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHBvc2l0aW9uIG9uIGNoaWxkIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGVscyAtIENoaWxkIGVudGl0aWVzIHRvIHNldC5cbiAqIEBwYXJhbSB7YXJyYXl9IHBvc2l0aW9ucyAtIEFycmF5IG9mIGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiBzZXRQb3NpdGlvbnMgKGVscywgcG9zaXRpb25zLCBvcmRlckF0dHJpYnV0ZSkge1xuICB2YXIgaTtcbiAgdmFyIG9yZGVySW5kZXg7XG5cbiAgLy8gQWxsb3cgZm9yIGNvbnRyb2xsaW5nIG9yZGVyIGV4cGxpY2l0bHkgc2luY2UgRE9NIG9yZGVyIGRvZXMgbm90IGhhdmUgYXMgbXVjaFxuICAvLyBtZWFuaW5nIGluIEEtRnJhbWUuXG4gIGlmIChvcmRlckF0dHJpYnV0ZSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9yZGVySW5kZXggPSBwYXJzZUludChlbHNbaV0uZ2V0QXR0cmlidXRlKG9yZGVyQXR0cmlidXRlKSwgMTApICogMztcbiAgICAgIGVsc1tpXS5vYmplY3QzRC5wb3NpdGlvbi5zZXQocG9zaXRpb25zW29yZGVySW5kZXhdLCBwb3NpdGlvbnNbb3JkZXJJbmRleCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbb3JkZXJJbmRleCArIDJdKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGlmICghZWxzW2kgLyAzXSkgeyByZXR1cm47IH1cbiAgICBlbHNbaSAvIDNdLm9iamVjdDNELnBvc2l0aW9uLnNldChwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV0sIHBvc2l0aW9uc1tpICsgMl0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hQb3NpdGlvbnMgKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHBvc2l0aW9ucy5wdXNoKGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hQb3NpdGlvblZlYzMgKHZlYzMpIHtcbiAgcG9zaXRpb25zLnB1c2godmVjMy54KTtcbiAgcG9zaXRpb25zLnB1c2godmVjMy55KTtcbiAgcG9zaXRpb25zLnB1c2godmVjMy56KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtbGF5b3V0LWNvbXBvbmVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vbGliL09yYml0Q29udHJvbHMnKTtcblxuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdvcmJpdC1jb250cm9scycsIHtcbiAgZGVwZW5kZW5jaWVzOiBbJ2NhbWVyYSddLFxuXG4gIHNjaGVtYToge1xuICAgIGF1dG9Sb3RhdGU6IHt0eXBlOiAnYm9vbGVhbid9LFxuICAgIGF1dG9Sb3RhdGVTcGVlZDoge2RlZmF1bHQ6IDJ9LFxuICAgIGRhbXBpbmdGYWN0b3I6IHtkZWZhdWx0OiAwLjF9LFxuICAgIGVuYWJsZWQ6IHtkZWZhdWx0OiB0cnVlfSxcbiAgICBlbmFibGVEYW1waW5nOiB7ZGVmYXVsdDogdHJ1ZX0sXG4gICAgZW5hYmxlS2V5czoge2RlZmF1bHQ6IHRydWV9LFxuICAgIGVuYWJsZVBhbjoge2RlZmF1bHQ6IHRydWV9LFxuICAgIGVuYWJsZVJvdGF0ZToge2RlZmF1bHQ6IHRydWV9LFxuICAgIGVuYWJsZVpvb206IHtkZWZhdWx0OiB0cnVlfSxcbiAgICBpbml0aWFsUG9zaXRpb246IHt0eXBlOiAndmVjMyd9LFxuICAgIGtleVBhblNwZWVkOiB7ZGVmYXVsdDogN30sXG4gICAgbWluQXppbXV0aEFuZ2xlOiB7dHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IEluZmluaXR5fSxcbiAgICBtYXhBemltdXRoQW5nbGU6IHt0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogSW5maW5pdHl9LFxuICAgIG1heERpc3RhbmNlOiB7ZGVmYXVsdDogMTAwMH0sXG4gICAgbWF4UG9sYXJBbmdsZToge2RlZmF1bHQ6IEFGUkFNRS51dGlscy5kZXZpY2UuaXNNb2JpbGUoKSA/IDkwIDogMTIwfSxcbiAgICBtaW5EaXN0YW5jZToge2RlZmF1bHQ6IDF9LFxuICAgIG1pblBvbGFyQW5nbGU6IHtkZWZhdWx0OiAwfSxcbiAgICBtaW5ab29tOiB7ZGVmYXVsdDogMH0sXG4gICAgcGFuU3BlZWQ6IHtkZWZhdWx0OiAxfSxcbiAgICByb3RhdGVTcGVlZDoge2RlZmF1bHQ6IDAuMDV9LFxuICAgIHNjcmVlblNwYWNlUGFubmluZzoge2RlZmF1bHQ6IGZhbHNlfSxcbiAgICB0YXJnZXQ6IHt0eXBlOiAndmVjMyd9LFxuICAgIHpvb21TcGVlZDoge2RlZmF1bHQ6IDAuNX1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgb2xkUG9zaXRpb247XG5cbiAgICB0aGlzLmNvbnRyb2xzID0gbmV3IFRIUkVFLk9yYml0Q29udHJvbHMoZWwuZ2V0T2JqZWN0M0QoJ2NhbWVyYScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zY2VuZUVsLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gICAgb2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZWwuc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCdlbnRlci12cicsICgpID0+IHtcbiAgICAgIGlmICghQUZSQU1FLnV0aWxzLmRldmljZS5jaGVja0hlYWRzZXRDb25uZWN0ZWQoKSAmJlxuICAgICAgICAgICFBRlJBTUUudXRpbHMuZGV2aWNlLmlzTW9iaWxlKCkpIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLmNvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2xvb2stY29udHJvbHMnKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2xvb2stY29udHJvbHMnLCAnZW5hYmxlZCcsIHRydWUpO1xuICAgICAgICBvbGRQb3NpdGlvbi5jb3B5KGVsLmdldE9iamVjdDNEKCdjYW1lcmEnKS5wb3NpdGlvbik7XG4gICAgICAgIGVsLmdldE9iamVjdDNEKCdjYW1lcmEnKS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlbC5zY2VuZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2V4aXQtdnInLCAoKSA9PiB7XG4gICAgICBpZiAoIUFGUkFNRS51dGlscy5kZXZpY2UuY2hlY2tIZWFkc2V0Q29ubmVjdGVkKCkgJiZcbiAgICAgICAgICAhQUZSQU1FLnV0aWxzLmRldmljZS5pc01vYmlsZSgpKSB7IHJldHVybjsgfVxuICAgICAgdGhpcy5jb250cm9scy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIGVsLmdldE9iamVjdDNEKCdjYW1lcmEnKS5wb3NpdGlvbi5jb3B5KG9sZFBvc2l0aW9uKTtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2xvb2stY29udHJvbHMnKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2xvb2stY29udHJvbHMnLCAnZW5hYmxlZCcsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2dyYWInO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2dyYWJiaW5nJztcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZ3JhYic7XG4gICAgfSk7XG5cbiAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZWwuZ2V0T2JqZWN0M0QoJ2NhbWVyYScpLnBvc2l0aW9uLmNvcHkodGhpcy5kYXRhLmluaXRpYWxQb3NpdGlvbik7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgIHZhciBjb250cm9scyA9IHRoaXMuY29udHJvbHM7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBjb250cm9scy50YXJnZXQgPSB0aGlzLnRhcmdldC5jb3B5KGRhdGEudGFyZ2V0KTtcbiAgICBjb250cm9scy5hdXRvUm90YXRlID0gZGF0YS5hdXRvUm90YXRlO1xuICAgIGNvbnRyb2xzLmF1dG9Sb3RhdGVTcGVlZCA9IGRhdGEuYXV0b1JvdGF0ZVNwZWVkO1xuICAgIGNvbnRyb2xzLmRhbXBpbmdGYWN0b3IgPSBkYXRhLmRhbXBpbmdGYWN0b3I7XG4gICAgY29udHJvbHMuZW5hYmxlZCA9IGRhdGEuZW5hYmxlZDtcbiAgICBjb250cm9scy5lbmFibGVEYW1waW5nID0gZGF0YS5lbmFibGVEYW1waW5nO1xuICAgIGNvbnRyb2xzLmVuYWJsZUtleXMgPSBkYXRhLmVuYWJsZUtleXM7XG4gICAgY29udHJvbHMuZW5hYmxlUGFuID0gZGF0YS5lbmFibGVQYW47XG4gICAgY29udHJvbHMuZW5hYmxlUm90YXRlID0gZGF0YS5lbmFibGVSb3RhdGU7XG4gICAgY29udHJvbHMuZW5hYmxlWm9vbSA9IGRhdGEuZW5hYmxlWm9vbTtcbiAgICBjb250cm9scy5rZXlQYW5TcGVlZCA9IGRhdGEua2V5UGFuU3BlZWQ7XG4gICAgY29udHJvbHMubWF4UG9sYXJBbmdsZSA9IFRIUkVFLk1hdGguZGVnVG9SYWQoZGF0YS5tYXhQb2xhckFuZ2xlKTtcbiAgICBjb250cm9scy5tYXhEaXN0YW5jZSA9IGRhdGEubWF4RGlzdGFuY2U7XG4gICAgY29udHJvbHMubWluRGlzdGFuY2UgPSBkYXRhLm1pbkRpc3RhbmNlO1xuICAgIGNvbnRyb2xzLm1pblBvbGFyQW5nbGUgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKGRhdGEubWluUG9sYXJBbmdsZSk7XG4gICAgY29udHJvbHMubWluWm9vbSA9IGRhdGEubWluWm9vbTtcbiAgICBjb250cm9scy5wYW5TcGVlZCA9IGRhdGEucGFuU3BlZWQ7XG4gICAgY29udHJvbHMucm90YXRlU3BlZWQgPSBkYXRhLnJvdGF0ZVNwZWVkO1xuICAgIGNvbnRyb2xzLnNjcmVlblNwYWNlUGFubmluZyA9IGRhdGEuc2NyZWVuU3BhY2VQYW5uaW5nO1xuICAgIGNvbnRyb2xzLnpvb21TcGVlZCA9IGRhdGEuem9vbVNwZWVkO1xuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGlmICghZGF0YS5lbmFibGVkKSB7IHJldHVybjsgfVxuICAgIGlmIChjb250cm9scy5lbmFibGVkICYmIChjb250cm9scy5lbmFibGVEYW1waW5nIHx8IGNvbnRyb2xzLmF1dG9Sb3RhdGUpKSB7XG4gICAgICB0aGlzLmNvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWZyYW1lLW9yYml0LWNvbnRyb2xzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBQYXJ0aWNsZXMgY29tcG9uZW50IGZvciBBLUZyYW1lLlxuICpcbiAqIFNoYWRlclBhcnRpY2xlRW5naW5lIGJ5IFNxdWFyZWZlZXQgKGh0dHBzOi8vZ2l0aHViLmNvbS9zcXVhcmVmZWV0KS5cbiAqL1xuXG52YXIgU1BFID0gcmVxdWlyZSgnLi9saWIvU1BFLmpzJyk7XG5cbmlmICh0eXBlb2YgQUZSQU1FID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBhdHRlbXB0ZWQgdG8gcmVnaXN0ZXIgYmVmb3JlIEFGUkFNRSB3YXMgYXZhaWxhYmxlLicpO1xufVxuXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3BhcnRpY2xlLXN5c3RlbScsIHtcblxuICAgIHNjaGVtYToge1xuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdDogJycsXG4gICAgICAgICAgICBvbmVPZjogWydkZWZhdWx0JywgJ2R1c3QnLCAnc25vdycsICdyYWluJ11cbiAgICAgICAgfSxcbiAgICAgICAgbWF4QWdlOiB7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvblNwcmVhZDoge1xuICAgICAgICAgICAgdHlwZTogJ3ZlYzMnXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uQXhpczoge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb25BbmdsZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcidcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZWxlcmF0aW9uVmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICd2ZWMzJ1xuICAgICAgICB9LFxuICAgICAgICBhY2NlbGVyYXRpb25TcHJlYWQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICd2ZWMzJ1xuICAgICAgICB9LFxuICAgICAgICB2ZWxvY2l0eVZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiAndmVjMydcbiAgICAgICAgfSxcbiAgICAgICAgdmVsb2NpdHlTcHJlYWQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICd2ZWMzJ1xuICAgICAgICB9LFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5J1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgICB9LFxuICAgICAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgICB9LFxuICAgICAgICBwYXJ0aWNsZUNvdW50OiB7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0dXJlOiB7XG4gICAgICAgICAgICB0eXBlOiAnYXNzZXQnXG4gICAgICAgIH0sXG4gICAgICAgIHJhbmRvbWl6ZToge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nXG4gICAgICAgIH0sXG4gICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWF4UGFydGljbGVDb3VudDoge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBkZWZhdWx0OiAyNTAwMDBcbiAgICAgICAgfSxcbiAgICAgICAgYmxlbmRpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgZGVmYXVsdDogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgICAgICAgIG9uZU9mOiBbVEhSRUUuTm9CbGVuZGluZyxUSFJFRS5Ob3JtYWxCbGVuZGluZyxUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcsVEhSRUUuTXVsdGlwbHlCbGVuZGluZ11cbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgICAgdHlwZTonYm9vbGVhbicsXG4gICAgICAgICAgICBkZWZhdWx0OnRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMucHJlc2V0cyA9IFtdO1xuXG4gICAgICAgIC8qIHByZXNldCBzZXR0aW5ncyBjYW4gYmUgb3ZlcndyaXR0ZW4gKi9cblxuICAgICAgICB0aGlzLnByZXNldHNbJ2RlZmF1bHQnXSA9IHtcbiAgICAgICAgICAgIG1heEFnZTogKHRoaXMuZGF0YS5tYXhBZ2UhPT0wP3RoaXMuZGF0YS5tYXhBZ2U6NiksXG4gICAgICAgICAgICBwb3NpdGlvblNwcmVhZDogKHRoaXMuZGF0YS5wb3NpdGlvblNwcmVhZC54IT09MHx8dGhpcy5kYXRhLnBvc2l0aW9uU3ByZWFkLnkhPT0wfHx0aGlzLmRhdGEucG9zaXRpb25TcHJlYWQueiE9PTA/dGhpcy5kYXRhLnBvc2l0aW9uU3ByZWFkOnt4OjAseTowLHo6MH0pLFxuICAgICAgICAgICAgdHlwZTogKHRoaXMuZGF0YS50eXBlIT09MD90aGlzLmRhdGEudHlwZTpTUEUuZGlzdHJpYnV0aW9ucy5CT1gpLCAvKiBTUEUuZGlzdHJpYnV0aW9ucy5TUEhFUkUsIFNQRS5kaXN0cmlidXRpb25zLkRJU0MgKi9cbiAgICAgICAgICAgIHJvdGF0aW9uQXhpczogKHRoaXMuZGF0YS5yb3RhdGlvbkF4aXMhPT0nJz90aGlzLmRhdGEucm90YXRpb25BeGlzOid4JyksXG4gICAgICAgICAgICByb3RhdGlvbkFuZ2xlOiAodGhpcy5kYXRhLnJvdGF0aW9uQW5nbGUhPT0wP3RoaXMuZGF0YS5yb3RhdGlvbkFuZ2xlOjApLFxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uVmFsdWU6ICh0aGlzLmRhdGEuYWNjZWxlcmF0aW9uVmFsdWUueCE9PTB8fHRoaXMuZGF0YS5hY2NlbGVyYXRpb25WYWx1ZS55IT09MHx8dGhpcy5kYXRhLmFjY2VsZXJhdGlvblZhbHVlLnohPT0wP3RoaXMuZGF0YS5hY2NlbGVyYXRpb25WYWx1ZTp7eDogMCwgeTogLTEwLCB6OiAwfSksXG4gICAgICAgICAgICBhY2NlbGVyYXRpb25TcHJlYWQ6ICh0aGlzLmRhdGEuYWNjZWxlcmF0aW9uU3ByZWFkLnghPT0wfHx0aGlzLmRhdGEuYWNjZWxlcmF0aW9uU3ByZWFkLnkhPT0wfHx0aGlzLmRhdGEuYWNjZWxlcmF0aW9uU3ByZWFkLnohPT0wP3RoaXMuZGF0YS5hY2NlbGVyYXRpb25TcHJlYWQ6e3g6IDEwLCB5OiAwLCB6OiAxMH0pLFxuICAgICAgICAgICAgdmVsb2NpdHlWYWx1ZTogKHRoaXMuZGF0YS52ZWxvY2l0eVZhbHVlLnghPT0wfHx0aGlzLmRhdGEudmVsb2NpdHlWYWx1ZS55IT09MHx8dGhpcy5kYXRhLnZlbG9jaXR5VmFsdWUueiE9PTA/dGhpcy5kYXRhLnZlbG9jaXR5VmFsdWU6e3g6IDAsIHk6IDI1LCB6OiAwfSksXG4gICAgICAgICAgICB2ZWxvY2l0eVNwcmVhZDogKHRoaXMuZGF0YS52ZWxvY2l0eVNwcmVhZC54IT09MHx8dGhpcy5kYXRhLnZlbG9jaXR5U3ByZWFkLnkhPT0wfHx0aGlzLmRhdGEudmVsb2NpdHlTcHJlYWQueiE9PTA/dGhpcy5kYXRhLnZlbG9jaXR5U3ByZWFkOnt4OiAxMCwgeTogNy41LCB6OiAxMH0pLFxuICAgICAgICAgICAgY29sb3I6ICh0aGlzLmRhdGEuY29sb3IubGVuZ3RoP3RoaXMuZGF0YS5jb2xvcjpbJyMwMDAwRkYnLCcjRkYwMDAwJ10pLFxuICAgICAgICAgICAgc2l6ZTogKHRoaXMuZGF0YS5zaXplIT09MD90aGlzLmRhdGEuc2l6ZToxKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdmFsdWU6ICh0aGlzLmRhdGEub3BhY2l0eSE9MD90aGlzLmRhdGEub3BhY2l0eToxKSB9LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAodGhpcy5kYXRhLmRpcmVjdGlvbiE9PTA/dGhpcy5kYXRhLmRpcmVjdGlvbjoxKSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAodGhpcy5kYXRhLmR1cmF0aW9uIT0wP3RoaXMuZGF0YS5kdXJhdGlvbjpudWxsKSxcbiAgICAgICAgICAgIHBhcnRpY2xlQ291bnQ6ICh0aGlzLmRhdGEucGFydGljbGVDb3VudCE9PTA/dGhpcy5kYXRhLnBhcnRpY2xlQ291bnQ6MTAwMCksXG4gICAgICAgICAgICB0ZXh0dXJlOiAodGhpcy5kYXRhLnRleHR1cmUhPT0nJz90aGlzLmRhdGEudGV4dHVyZTonaHR0cHM6Ly9jZG4ucmF3Z2l0LmNvbS9JZGVhU3BhY2VWUi9hZnJhbWUtcGFydGljbGUtc3lzdGVtLWNvbXBvbmVudC9tYXN0ZXIvZGlzdC9pbWFnZXMvc3RhcjIucG5nJyksXG4gICAgICAgICAgICByYW5kb21pemU6IGZhbHNlXG4gICAgICAgIH07XG5cblxuICAgICAgICB0aGlzLnByZXNldHNbJ2R1c3QnXSA9IHtcbiAgICAgICAgICAgIG1heEFnZTogKHRoaXMuZGF0YS5tYXhBZ2UhPT0wP3RoaXMuZGF0YS5tYXhBZ2U6MjApLFxuICAgICAgICAgICAgcG9zaXRpb25TcHJlYWQ6ICh0aGlzLmRhdGEucG9zaXRpb25TcHJlYWQueCE9PTB8fHRoaXMuZGF0YS5wb3NpdGlvblNwcmVhZC55IT09MHx8dGhpcy5kYXRhLnBvc2l0aW9uU3ByZWFkLnohPT0wP3RoaXMuZGF0YS5wb3NpdGlvblNwcmVhZDp7eDoxMDAseToxMDAsejoxMDB9KSxcbiAgICAgICAgICAgIHR5cGU6ICh0aGlzLmRhdGEudHlwZSE9PTA/dGhpcy5kYXRhLnR5cGU6U1BFLmRpc3RyaWJ1dGlvbnMuQk9YKSwgLyogU1BFLmRpc3RyaWJ1dGlvbnMuU1BIRVJFLCBTUEUuZGlzdHJpYnV0aW9ucy5ESVNDICovXG4gICAgICAgICAgICByb3RhdGlvbkF4aXM6ICh0aGlzLmRhdGEucm90YXRpb25BeGlzIT09Jyc/dGhpcy5kYXRhLnJvdGF0aW9uQXhpczoneCcpLFxuICAgICAgICAgICAgcm90YXRpb25BbmdsZTogKHRoaXMuZGF0YS5yb3RhdGlvbkFuZ2xlIT09MD90aGlzLmRhdGEucm90YXRpb25BbmdsZTozLjE0KSxcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvblZhbHVlOiAodGhpcy5kYXRhLmFjY2VsZXJhdGlvblZhbHVlLnghPT0wfHx0aGlzLmRhdGEuYWNjZWxlcmF0aW9uVmFsdWUueSE9PTB8fHRoaXMuZGF0YS5hY2NlbGVyYXRpb25WYWx1ZS56IT09MD90aGlzLmRhdGEuYWNjZWxlcmF0aW9uVmFsdWU6e3g6IDAsIHk6IDAsIHo6IDB9KSxcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvblNwcmVhZDogKHRoaXMuZGF0YS5hY2NlbGVyYXRpb25TcHJlYWQueCE9PTB8fHRoaXMuZGF0YS5hY2NlbGVyYXRpb25TcHJlYWQueSE9PTB8fHRoaXMuZGF0YS5hY2NlbGVyYXRpb25TcHJlYWQueiE9PTA/dGhpcy5kYXRhLmFjY2VsZXJhdGlvblNwcmVhZDp7eDogMCwgeTogMCwgejogMH0pLFxuICAgICAgICAgICAgdmVsb2NpdHlWYWx1ZTogKHRoaXMuZGF0YS52ZWxvY2l0eVZhbHVlLnghPT0wfHx0aGlzLmRhdGEudmVsb2NpdHlWYWx1ZS55IT09MHx8dGhpcy5kYXRhLnZlbG9jaXR5VmFsdWUueiE9PTA/dGhpcy5kYXRhLnZlbG9jaXR5VmFsdWU6e3g6IDEsIHk6IDAuMywgejogMX0pLFxuICAgICAgICAgICAgdmVsb2NpdHlTcHJlYWQ6ICh0aGlzLmRhdGEudmVsb2NpdHlTcHJlYWQueCE9PTB8fHRoaXMuZGF0YS52ZWxvY2l0eVNwcmVhZC55IT09MHx8dGhpcy5kYXRhLnZlbG9jaXR5U3ByZWFkLnohPT0wP3RoaXMuZGF0YS52ZWxvY2l0eVNwcmVhZDp7eDogMC41LCB5OiAxLCB6OiAwLjV9KSxcbiAgICAgICAgICAgIGNvbG9yOiAodGhpcy5kYXRhLmNvbG9yLmxlbmd0aD90aGlzLmRhdGEuY29sb3I6WycjRkZGRkZGJ10pLFxuICAgICAgICAgICAgc2l6ZTogKHRoaXMuZGF0YS5zaXplIT09MD90aGlzLmRhdGEuc2l6ZToxKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdmFsdWU6ICh0aGlzLmRhdGEub3BhY2l0eSE9MD90aGlzLmRhdGEub3BhY2l0eToxKSB9LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAodGhpcy5kYXRhLmRpcmVjdGlvbiE9PTA/dGhpcy5kYXRhLmRpcmVjdGlvbjoxKSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAodGhpcy5kYXRhLmR1cmF0aW9uIT0wP3RoaXMuZGF0YS5kdXJhdGlvbjpudWxsKSxcbiAgICAgICAgICAgIHBhcnRpY2xlQ291bnQ6ICh0aGlzLmRhdGEucGFydGljbGVDb3VudCE9PTA/dGhpcy5kYXRhLnBhcnRpY2xlQ291bnQ6MTAwKSxcbiAgICAgICAgICAgIHRleHR1cmU6ICh0aGlzLmRhdGEudGV4dHVyZSE9PScnP3RoaXMuZGF0YS50ZXh0dXJlOidodHRwczovL2Nkbi5yYXdnaXQuY29tL0lkZWFTcGFjZVZSL2FmcmFtZS1wYXJ0aWNsZS1zeXN0ZW0tY29tcG9uZW50L21hc3Rlci9kaXN0L2ltYWdlcy9zbW9rZXBhcnRpY2xlLnBuZycpLFxuICAgICAgICAgICAgcmFuZG9taXplOiBmYWxzZVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdGhpcy5wcmVzZXRzWydzbm93J10gPSB7XG4gICAgICAgICAgICBtYXhBZ2U6ICh0aGlzLmRhdGEubWF4QWdlIT09MD90aGlzLmRhdGEubWF4QWdlOjIwKSxcbiAgICAgICAgICAgIHBvc2l0aW9uU3ByZWFkOiAodGhpcy5kYXRhLnBvc2l0aW9uU3ByZWFkLnghPT0wfHx0aGlzLmRhdGEucG9zaXRpb25TcHJlYWQueSE9PTB8fHRoaXMuZGF0YS5wb3NpdGlvblNwcmVhZC56IT09MD90aGlzLmRhdGEucG9zaXRpb25TcHJlYWQ6e3g6MTAwLHk6MTAwLHo6MTAwfSksXG4gICAgICAgICAgICB0eXBlOiAodGhpcy5kYXRhLnR5cGUhPT0wP3RoaXMuZGF0YS50eXBlOlNQRS5kaXN0cmlidXRpb25zLkJPWCksIC8qIFNQRS5kaXN0cmlidXRpb25zLlNQSEVSRSwgU1BFLmRpc3RyaWJ1dGlvbnMuRElTQyAqL1xuICAgICAgICAgICAgcm90YXRpb25BeGlzOiAodGhpcy5kYXRhLnJvdGF0aW9uQXhpcyE9PScnP3RoaXMuZGF0YS5yb3RhdGlvbkF4aXM6J3gnKSxcbiAgICAgICAgICAgIHJvdGF0aW9uQW5nbGU6ICh0aGlzLmRhdGEucm90YXRpb25BbmdsZSE9PTA/dGhpcy5kYXRhLnJvdGF0aW9uQW5nbGU6My4xNCksXG4gICAgICAgICAgICBhY2NlbGVyYXRpb25WYWx1ZTogKHRoaXMuZGF0YS5hY2NlbGVyYXRpb25WYWx1ZS54IT09MHx8dGhpcy5kYXRhLmFjY2VsZXJhdGlvblZhbHVlLnkhPT0wfHx0aGlzLmRhdGEuYWNjZWxlcmF0aW9uVmFsdWUueiE9PTA/dGhpcy5kYXRhLmFjY2VsZXJhdGlvblZhbHVlOnt4OiAwLCB5OiAwLCB6OiAwfSksXG4gICAgICAgICAgICBhY2NlbGVyYXRpb25TcHJlYWQ6ICh0aGlzLmRhdGEuYWNjZWxlcmF0aW9uU3ByZWFkLnghPT0wfHx0aGlzLmRhdGEuYWNjZWxlcmF0aW9uU3ByZWFkLnkhPT0wfHx0aGlzLmRhdGEuYWNjZWxlcmF0aW9uU3ByZWFkLnohPT0wP3RoaXMuZGF0YS5hY2NlbGVyYXRpb25TcHJlYWQ6e3g6IDAuMiwgeTogMCwgejogMC4yfSksXG4gICAgICAgICAgICB2ZWxvY2l0eVZhbHVlOiAodGhpcy5kYXRhLnZlbG9jaXR5VmFsdWUueCE9PTB8fHRoaXMuZGF0YS52ZWxvY2l0eVZhbHVlLnkhPT0wfHx0aGlzLmRhdGEudmVsb2NpdHlWYWx1ZS56IT09MD90aGlzLmRhdGEudmVsb2NpdHlWYWx1ZTp7eDogMCwgeTogOCwgejogMH0pLFxuICAgICAgICAgICAgdmVsb2NpdHlTcHJlYWQ6ICh0aGlzLmRhdGEudmVsb2NpdHlTcHJlYWQueCE9PTB8fHRoaXMuZGF0YS52ZWxvY2l0eVNwcmVhZC55IT09MHx8dGhpcy5kYXRhLnZlbG9jaXR5U3ByZWFkLnohPT0wP3RoaXMuZGF0YS52ZWxvY2l0eVNwcmVhZDp7eDogMiwgeTogMCwgejogMn0pLFxuICAgICAgICAgICAgY29sb3I6ICh0aGlzLmRhdGEuY29sb3IubGVuZ3RoP3RoaXMuZGF0YS5jb2xvcjpbJyNGRkZGRkYnXSksXG4gICAgICAgICAgICBzaXplOiAodGhpcy5kYXRhLnNpemUhPT0wP3RoaXMuZGF0YS5zaXplOjEpLFxuICAgICAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogKHRoaXMuZGF0YS5vcGFjaXR5IT0wP3RoaXMuZGF0YS5vcGFjaXR5OjEpIH0sXG4gICAgICAgICAgICBkaXJlY3Rpb246ICh0aGlzLmRhdGEuZGlyZWN0aW9uIT09MD90aGlzLmRhdGEuZGlyZWN0aW9uOjEpLFxuICAgICAgICAgICAgZHVyYXRpb246ICh0aGlzLmRhdGEuZHVyYXRpb24hPTA/dGhpcy5kYXRhLmR1cmF0aW9uOm51bGwpLFxuICAgICAgICAgICAgcGFydGljbGVDb3VudDogKHRoaXMuZGF0YS5wYXJ0aWNsZUNvdW50IT09MD90aGlzLmRhdGEucGFydGljbGVDb3VudDoyMDApLFxuICAgICAgICAgICAgdGV4dHVyZTogKHRoaXMuZGF0YS50ZXh0dXJlIT09Jyc/dGhpcy5kYXRhLnRleHR1cmU6J2h0dHBzOi8vY2RuLnJhd2dpdC5jb20vSWRlYVNwYWNlVlIvYWZyYW1lLXBhcnRpY2xlLXN5c3RlbS1jb21wb25lbnQvbWFzdGVyL2Rpc3QvaW1hZ2VzL3Ntb2tlcGFydGljbGUucG5nJyksXG4gICAgICAgICAgICByYW5kb21pemU6IGZhbHNlXG4gICAgICAgIH07XG5cblxuICAgICAgICB0aGlzLnByZXNldHNbJ3JhaW4nXSA9IHtcbiAgICAgICAgICAgIG1heEFnZTogKHRoaXMuZGF0YS5tYXhBZ2UhPT0wP3RoaXMuZGF0YS5tYXhBZ2U6MSksXG4gICAgICAgICAgICBwb3NpdGlvblNwcmVhZDogKHRoaXMuZGF0YS5wb3NpdGlvblNwcmVhZC54IT09MHx8dGhpcy5kYXRhLnBvc2l0aW9uU3ByZWFkLnkhPT0wfHx0aGlzLmRhdGEucG9zaXRpb25TcHJlYWQueiE9PTA/dGhpcy5kYXRhLnBvc2l0aW9uU3ByZWFkOnt4OjEwMCx5OjEwMCx6OjEwMH0pLFxuICAgICAgICAgICAgdHlwZTogKHRoaXMuZGF0YS50eXBlIT09MD90aGlzLmRhdGEudHlwZTpTUEUuZGlzdHJpYnV0aW9ucy5CT1gpLCAvKiBTUEUuZGlzdHJpYnV0aW9ucy5TUEhFUkUsIFNQRS5kaXN0cmlidXRpb25zLkRJU0MgKi9cbiAgICAgICAgICAgIHJvdGF0aW9uQXhpczogKHRoaXMuZGF0YS5yb3RhdGlvbkF4aXMhPT0nJz90aGlzLmRhdGEucm90YXRpb25BeGlzOid4JyksXG4gICAgICAgICAgICByb3RhdGlvbkFuZ2xlOiAodGhpcy5kYXRhLnJvdGF0aW9uQW5nbGUhPT0wP3RoaXMuZGF0YS5yb3RhdGlvbkFuZ2xlOjMuMTQpLFxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uVmFsdWU6ICh0aGlzLmRhdGEuYWNjZWxlcmF0aW9uVmFsdWUueCE9PTB8fHRoaXMuZGF0YS5hY2NlbGVyYXRpb25WYWx1ZS55IT09MHx8dGhpcy5kYXRhLmFjY2VsZXJhdGlvblZhbHVlLnohPT0wP3RoaXMuZGF0YS5hY2NlbGVyYXRpb25WYWx1ZTp7eDogMCwgeTogMywgejogMH0pLFxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uU3ByZWFkOiAodGhpcy5kYXRhLmFjY2VsZXJhdGlvblNwcmVhZC54IT09MHx8dGhpcy5kYXRhLmFjY2VsZXJhdGlvblNwcmVhZC55IT09MHx8dGhpcy5kYXRhLmFjY2VsZXJhdGlvblNwcmVhZC56IT09MD90aGlzLmRhdGEuYWNjZWxlcmF0aW9uU3ByZWFkOnt4OiAyLCB5OiAxLCB6OiAyfSksXG4gICAgICAgICAgICB2ZWxvY2l0eVZhbHVlOiAodGhpcy5kYXRhLnZlbG9jaXR5VmFsdWUueCE9PTB8fHRoaXMuZGF0YS52ZWxvY2l0eVZhbHVlLnkhPT0wfHx0aGlzLmRhdGEudmVsb2NpdHlWYWx1ZS56IT09MD90aGlzLmRhdGEudmVsb2NpdHlWYWx1ZTp7eDogMCwgeTogNzUsIHo6IDB9KSxcbiAgICAgICAgICAgIHZlbG9jaXR5U3ByZWFkOiAodGhpcy5kYXRhLnZlbG9jaXR5U3ByZWFkLnghPT0wfHx0aGlzLmRhdGEudmVsb2NpdHlTcHJlYWQueSE9PTB8fHRoaXMuZGF0YS52ZWxvY2l0eVNwcmVhZC56IT09MD90aGlzLmRhdGEudmVsb2NpdHlTcHJlYWQ6e3g6IDEwLCB5OiA1MCwgejogMTB9KSxcbiAgICAgICAgICAgIGNvbG9yOiAodGhpcy5kYXRhLmNvbG9yLmxlbmd0aD90aGlzLmRhdGEuY29sb3I6WycjRkZGRkZGJ10pLFxuICAgICAgICAgICAgc2l6ZTogKHRoaXMuZGF0YS5zaXplIT09MD90aGlzLmRhdGEuc2l6ZTowLjQpLFxuICAgICAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogKHRoaXMuZGF0YS5vcGFjaXR5IT0wP3RoaXMuZGF0YS5vcGFjaXR5OjEpIH0sXG4gICAgICAgICAgICBkaXJlY3Rpb246ICh0aGlzLmRhdGEuZGlyZWN0aW9uIT09MD90aGlzLmRhdGEuZGlyZWN0aW9uOjEpLFxuICAgICAgICAgICAgZHVyYXRpb246ICh0aGlzLmRhdGEuZHVyYXRpb24hPTA/dGhpcy5kYXRhLmR1cmF0aW9uOm51bGwpLFxuICAgICAgICAgICAgcGFydGljbGVDb3VudDogKHRoaXMuZGF0YS5wYXJ0aWNsZUNvdW50IT09MD90aGlzLmRhdGEucGFydGljbGVDb3VudDoxMDAwKSxcbiAgICAgICAgICAgIHRleHR1cmU6ICh0aGlzLmRhdGEudGV4dHVyZSE9PScnP3RoaXMuZGF0YS50ZXh0dXJlOidodHRwczovL2Nkbi5yYXdnaXQuY29tL0lkZWFTcGFjZVZSL2FmcmFtZS1wYXJ0aWNsZS1zeXN0ZW0tY29tcG9uZW50L21hc3Rlci9kaXN0L2ltYWdlcy9yYWluZHJvcC5wbmcnKSxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogZmFsc2VcbiAgICAgICAgfTtcblxuXG4gICAgfSxcblxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuXG4gICAgICAgIC8vIFJlbW92ZSBvbGQgcGFydGljbGUgZ3JvdXAuXG4gICAgICAgIGlmICh0aGlzLnBhcnRpY2xlR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlT2JqZWN0M0QoJ3BhcnRpY2xlLXN5c3RlbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5wcmVzZXQgIT0gJycgJiYgdGhpcy5kYXRhLnByZXNldCBpbiB0aGlzLnByZXNldHMpIHtcblxuICAgICAgICAgICAgdGhpcy5pbml0UGFydGljbGVTeXN0ZW0odGhpcy5wcmVzZXRzW3RoaXMuZGF0YS5wcmVzZXRdKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmluaXRQYXJ0aWNsZVN5c3RlbSh0aGlzLnByZXNldHNbJ2RlZmF1bHQnXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmRhdGEuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBhcnRpY2xlcygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQYXJ0aWNsZXMoKVxuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgdGljazogZnVuY3Rpb24odGltZSwgZHQpIHtcblxuICAgICAgICB0aGlzLnBhcnRpY2xlR3JvdXAudGljayhkdCAvIDEwMDApO1xuICAgIH0sXG5cblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHBhcnRpY2xlIHN5c3RlbS5cbiAgICAgICAgaWYgKCF0aGlzLnBhcnRpY2xlR3JvdXApIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlT2JqZWN0M0QoJ3BhcnRpY2xlLXN5c3RlbScpO1xuICAgIH0sXG5cbiAgICBzdGFydFBhcnRpY2xlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucGFydGljbGVHcm91cC5lbWl0dGVycy5mb3JFYWNoKGZ1bmN0aW9uKGVtKSB7IGVtLmVuYWJsZSgpIH0pO1xuICAgIH0sXG5cbiAgICBzdG9wUGFydGljbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZUdyb3VwLmVtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24oZW0pIHsgZW0uZGlzYWJsZSgpIH0pO1xuICAgIH0sXG5cblxuICAgIGluaXRQYXJ0aWNsZVN5c3RlbTogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcbiAgICAgICAgdmFyIHBhcnRpY2xlX3RleHR1cmUgPSBsb2FkZXIubG9hZChcbiAgICAgICAgICAgIHNldHRpbmdzLnRleHR1cmUsXG4gICAgICAgICAgICBmdW5jdGlvbiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coKHhoci5sb2FkZWQgLyB4aHIudG90YWwgKiAxMDApICsgJyUgbG9hZGVkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQW4gZXJyb3Igb2NjdXJyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRpY2xlR3JvdXAgPSBuZXcgU1BFLkdyb3VwKHtcbiAgICAgICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFydGljbGVfdGV4dHVyZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heFBhcnRpY2xlQ291bnQ6IHRoaXMuZGF0YS5tYXhQYXJ0aWNsZUNvdW50LFxuICAgICAgICAgICAgYmxlbmRpbmc6IHRoaXMuZGF0YS5ibGVuZGluZ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZW1pdHRlciA9IG5ldyBTUEUuRW1pdHRlcih7XG4gICAgICAgICAgICBtYXhBZ2U6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2V0dGluZ3MubWF4QWdlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzZXR0aW5ncy50eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBzcHJlYWQ6IG5ldyBUSFJFRS5WZWN0b3IzKHNldHRpbmdzLnBvc2l0aW9uU3ByZWFkLngsIHNldHRpbmdzLnBvc2l0aW9uU3ByZWFkLnksIHNldHRpbmdzLnBvc2l0aW9uU3ByZWFkLnopLFxuICAgICAgICAgICAgICAgIHJhbmRvbWl6ZTogc2V0dGluZ3MucmFuZG9taXplXG4gICAgICAgICAgICAgICAgLy9zcHJlYWRDbGFtcDogbmV3IFRIUkVFLlZlY3RvcjMoIDIsIDIsIDIgKSxcbiAgICAgICAgICAgICAgICAvL3JhZGl1czogNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgYXhpczogKHNldHRpbmdzLnJvdGF0aW9uQXhpcz09J3gnP25ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApOihzZXR0aW5ncy5yb3RhdGlvbkF4aXM9PSd5Jz9uZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKTooc2V0dGluZ3Mucm90YXRpb25BeGlzPT0neic/bmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk6bmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCkpKSksXG4gICAgICAgICAgICAgICAgYW5nbGU6IHNldHRpbmdzLnJvdGF0aW9uQW5nbGUsXG4gICAgICAgICAgICAgICAgc3RhdGljOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IzKHNldHRpbmdzLmFjY2VsZXJhdGlvblZhbHVlLngsIHNldHRpbmdzLmFjY2VsZXJhdGlvblZhbHVlLnksIHNldHRpbmdzLmFjY2VsZXJhdGlvblZhbHVlLnopLFxuICAgICAgICAgICAgICAgIHNwcmVhZDogbmV3IFRIUkVFLlZlY3RvcjMoc2V0dGluZ3MuYWNjZWxlcmF0aW9uU3ByZWFkLngsIHNldHRpbmdzLmFjY2VsZXJhdGlvblNwcmVhZC55LCBzZXR0aW5ncy5hY2NlbGVyYXRpb25TcHJlYWQueilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2ZWxvY2l0eToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyhzZXR0aW5ncy52ZWxvY2l0eVZhbHVlLngsIHNldHRpbmdzLnZlbG9jaXR5VmFsdWUueSwgc2V0dGluZ3MudmVsb2NpdHlWYWx1ZS56KSxcbiAgICAgICAgICAgICAgICBzcHJlYWQ6IG5ldyBUSFJFRS5WZWN0b3IzKHNldHRpbmdzLnZlbG9jaXR5U3ByZWFkLngsIHNldHRpbmdzLnZlbG9jaXR5U3ByZWFkLnksIHNldHRpbmdzLnZlbG9jaXR5U3ByZWFkLnopXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2V0dGluZ3MuY29sb3IubWFwKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIG5ldyBUSFJFRS5Db2xvcihjKTsgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNldHRpbmdzLnNpemVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKndpZ2dsZTogeyB2YWx1ZTogNCwgc3ByZWFkOiAyIH0sIC8vc2V0dGluZ3Mud2lnZ2xlLCovXG4gICAgICAgICAgICAvKmRyYWc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2V0dGluZ3MuZHJhZ1xuICAgICAgICAgICAgfSwqL1xuICAgICAgICAgICAgZGlyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNldHRpbmdzLmRpcmVjdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzZXR0aW5ncy5kdXJhdGlvbixcbiAgICAgICAgICAgIG9wYWNpdHk6IHNldHRpbmdzLm9wYWNpdHksXG4gICAgICAgICAgICBwYXJ0aWNsZUNvdW50OiBzZXR0aW5ncy5wYXJ0aWNsZUNvdW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucGFydGljbGVHcm91cC5hZGRFbWl0dGVyKGVtaXR0ZXIpO1xuICAgICAgICB0aGlzLnBhcnRpY2xlR3JvdXAubWVzaC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWwuc2V0T2JqZWN0M0QoJ3BhcnRpY2xlLXN5c3RlbScsIHRoaXMucGFydGljbGVHcm91cC5tZXNoKTtcbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtcGFydGljbGUtc3lzdGVtLWNvbXBvbmVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBBRlJBTUUgKi9cblxuaWYgKHR5cGVvZiBBRlJBTUUgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGF0dGVtcHRlZCB0byByZWdpc3RlciBiZWZvcmUgQUZSQU1FIHdhcyBhdmFpbGFibGUuJyk7XG59XG5cbi8qKlxuICogUGFydGljbGUgUGxheWVyIGNvbXBvbmVudCBmb3IgQS1GcmFtZS5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdwYXJ0aWNsZXBsYXllcicsIHtcbiBtdWx0aXBsZTogdHJ1ZSxcbiAgc2NoZW1hOiB7XG4gICAgc3JjOiB7dHlwZTogJ3NlbGVjdG9yJ30sXG4gICAgb246IHtkZWZhdWx0OiAnaW5pdCd9LFxuICAgIGNvdW50OiB7ZGVmYXVsdDogJzEwMCUnfSxcbiAgICBkdXI6IHtkZWZhdWx0OiAxMDAwLCB0eXBlOiAnaW50J30sXG4gICAgbG9vcDoge2RlZmF1bHQ6ICdmYWxzZSd9LFxuICAgIGRlbGF5OiB7ZGVmYXVsdDogMCwgdHlwZTogJ2ludCd9LFxuICAgIHNjYWxlOiB7ZGVmYXVsdDogMS4wLCB0eXBlOiAnZmxvYXQnfSxcbiAgICBwc2NhbGU6IHtkZWZhdWx0OiAxLjAsIHR5cGU6ICdmbG9hdCd9LFxuICAgIHByb3RhdGlvbjoge3R5cGU6ICd2ZWMzJ30sXG4gICAgY2FjaGU6IHtkZWZhdWx0OiA1LCB0eXBlOiAnaW50J30sIC8vIG51bWJlciBvZiBzaW11bHRhbmVvdXMgcGFydGljbGUgc3lzdGVtc1xuICAgIHNoYWRlcjoge2RlZmF1bHQ6ICdmbGF0Jywgb25lT2Y6IFsnZmxhdCcsICdsYW1iZXJ0JywgJ3Bob25nJywgJ3N0YW5kYXJkJ119LFxuICAgIGNvbG9yOiB7ZGVmYXVsdDogJyNmZmYnLCB0eXBlOiAnY29sb3InfSxcbiAgICBibGVuZGluZzoge2RlZmF1bHQ6ICdhZGRpdGl2ZScsIG9uZU9mOiBbJ25vcm1hbCcsICdhZGRpdGl2ZScsICdtdWx0aXBseScsICdzdWJzdHJhY3RpdmUnXX0sXG4gICAgaW1nOiB7dHlwZTogJ3NlbGVjdG9yJ30sXG4gICAgaW50ZXJwb2xhdGU6IHtkZWZhdWx0OiBmYWxzZX1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mcmFtZWRhdGEgPSBudWxsO1xuICAgIHRoaXMucmVzdFBvc2l0aW9ucyA9IG51bGw7IC8vIHBvc2l0aW9uIGF0IGZpcnN0IGZyYW1lIGVhY2ggcGFydGljbGUgaXMgYWxpdmVcbiAgICB0aGlzLnJlc3RSb3RhdGlvbnMgPSBudWxsOyBcbiAgICB0aGlzLm51bUZyYW1lcyA9IDA7XG4gICAgdGhpcy5udW1QYXJ0aWNsZXMgPSAwOyAvLyB0b3RhbCBudW1iZXIgb2YgcGFydGljbGVzIHBlciBzeXN0ZW1cbiAgICB0aGlzLmNvdW50ID0gMDsgLy8gYWN0dWFsIG51bWJlciBvZiBwYXJ0aWNsZXMgdG8gc3Bhd24gcGVyIGV2ZW50IChkYXRhLmNvdW50KVxuICAgIHRoaXMuc3lzdGVtcyA9IG51bGw7XG4gICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgdGhpcy5sYXN0RnJhbWUgPSAwO1xuICAgIHRoaXMubXNQZXJGcmFtZSA9IDA7XG4gICAgdGhpcy51c2VSb3RhdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuc3ByaXRlX3JvdGF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5wcm90YXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmFsbFBhcnRpY2xlc0VsID0gbnVsbDtcblxuICAgIC8vIHRlbXBvcmFsIHZhcnMgZm9yIHByZXZlbnRpbmcgZ2NcbiAgICB0aGlzLnYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHRoaXMuaW5kZXhQb29sID0gbnVsbDtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKG9sZERhdGEpIHtcbiAgICB2YXIgcGFyYW1zO1xuICAgIGNvbnN0IEJMRU5ESU5HUyA9IHtcbiAgICAgICdub3JtYWwnOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAgICAgICdhZGRpdGl2ZSc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAnc3Vic3RyYWN0aXZlJzogVEhSRUUuU3Vic3RyYWN0aXZlQmxlbmRpbmcsXG4gICAgICAnbXVsdGlwbHknOiBUSFJFRS5NdWx0aXBseUJsZW5kaW5nXG4gICAgfTtcbiAgICBjb25zdCBTSEFERVJTID0ge1xuICAgICAgJ2ZsYXQnOiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCxcbiAgICAgICdsYW1iZXJ0JzogVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCxcbiAgICAgICdwaG9uZyc6IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLFxuICAgICAgJ3N0YW5kYXJkJzogVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWxcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAob2xkRGF0YS5vbiAhPT0gZGF0YS5vbikge1xuICAgICAgaWYgKG9sZERhdGEub24pIHsgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKG9sZERhdGEub24sIHRoaXMuc3RhcnQpfVxuICAgICAgaWYgKGRhdGEub24gIT09ICdwbGF5Jykge1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZGF0YS5vbiwgdGhpcy5zdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxvYWRQYXJ0aWNsZXNKU09OKGRhdGEuc3JjLCBkYXRhLnNjYWxlKTtcblxuICAgIHRoaXMubnVtRnJhbWVzID0gdGhpcy5mcmFtZWRhdGEubGVuZ3RoO1xuICAgIHRoaXMubnVtUGFydGljbGVzID0gdGhpcy5udW1GcmFtZXMgPiAwID8gdGhpcy5mcmFtZWRhdGFbMF0ubGVuZ3RoIDogMDtcblxuICAgIGlmIChkYXRhLmNvdW50W2RhdGEuY291bnQubGVuZ3RoLTFdID09ICclJykge1xuICAgICAgdGhpcy5jb3VudCA9IE1hdGguZmxvb3IocGFyc2VJbnQoZGF0YS5jb3VudCkgKiB0aGlzLm51bVBhcnRpY2xlcyAvIDEwMC4wKTtcbiAgICB9IGVsc2UgeyBcbiAgICAgIHRoaXMuY291bnQgPSBwYXJzZUludChkYXRhLmNvdW50KTsgXG4gICAgfVxuICAgIHRoaXMuY291bnQgPSBNYXRoLm1pbih0aGlzLm51bVBhcnRpY2xlcywgTWF0aC5tYXgoMCwgdGhpcy5jb3VudCkpO1xuXG4gICAgdGhpcy5tc1BlckZyYW1lID0gZGF0YS5kdXIgLyB0aGlzLm51bUZyYW1lcztcbiBcbiAgICB0aGlzLmluZGV4UG9vbCA9IG5ldyBBcnJheSh0aGlzLm51bVBhcnRpY2xlcyk7XG5cblxuICAgIHBhcmFtcyA9IHtcbiAgICAgIGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoZGF0YS5jb2xvciksXG4gICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuICAgICAgYmxlbmRpbmc6IEJMRU5ESU5HU1tkYXRhLmJsZW5kaW5nXSxcbiAgICAgIG1hcDogZGF0YS5pbWcgPyBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoZGF0YS5pbWcuc3JjKSA6IG51bGwsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIG9wYWNpdHk6IGRhdGEub3BhY2l0eSxcbiAgICAgIHRyYW5zcGFyZW50OiBkYXRhLmltZyB8fCBkYXRhLmJsZW5kaW5nICE9PSAnbm9ybWFsJyB8fCBkYXRhLm9wYWNpdHkgPCAxID8gdHJ1ZSA6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChTSEFERVJTW2RhdGEuc2hhZGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFNIQURFUlNbZGF0YS5zaGFkZXJdKHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgU0hBREVSU1snZmxhdCddKHBhcmFtcyk7XG4gICAgfVxuICAgIFxuICAgIHZhciByYXRpbyA9IGRhdGEuaW1nID8gZGF0YS5pbWcud2lkdGggLyBkYXRhLmltZy5oZWlnaHQgOiAxO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSgwLjEgKiByYXRpbyAqIGRhdGEucHNjYWxlLCAwLjEgKiBkYXRhLnBzY2FsZSk7XG5cbiAgICBpZiAoIXRoaXMuYWxsUGFydGljbGVzRWwpIHtcbiAgICAgIHRoaXMuYWxsUGFydGljbGVzRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhLWVudGl0eScpO1xuICAgICAgdGhpcy5hbGxQYXJ0aWNsZXNFbC5pZCA9IFwiX19qc29uLXBhcnRpY2xlcy1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwKTtcbiAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5hbGxQYXJ0aWNsZXNFbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3ByaXRlX3JvdGF0aW9uICE9PSBmYWxzZSl7XG4gICAgICB0aGlzLmdlb21ldHJ5LnJvdGF0ZVgodGhpcy5zcHJpdGVfcm90YXRpb24ueCk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnJvdGF0ZVkodGhpcy5zcHJpdGVfcm90YXRpb24ueSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnJvdGF0ZVoodGhpcy5zcHJpdGVfcm90YXRpb24ueik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5nZW9tZXRyeS5yb3RhdGVYKHRoaXMuZGF0YS5wcm90YXRpb24ueCAqIE1hdGguUEkgLyAxODApO1xuICAgICAgdGhpcy5nZW9tZXRyeS5yb3RhdGVZKHRoaXMuZGF0YS5wcm90YXRpb24ueSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgdGhpcy5nZW9tZXRyeS5yb3RhdGVaKHRoaXMuZGF0YS5wcm90YXRpb24ueiAqIE1hdGguUEkgLyAxODApO1xuICAgIH1cblxuICAgIHRoaXMuY2FjaGVQYXJ0aWNsZXMoZGF0YS5jYWNoZSk7XG5cbiAgICBpZiAoZGF0YS5vbiA9PT0gJ2luaXQnKSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICB9LFxuXG4gIGxvYWRQYXJ0aWNsZXNKU09OOiBmdW5jdGlvbiAoanNvbiwgc2NhbGUpIHtcbiAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoanNvbi5kYXRhKTtcbiAgICB2YXIgcDsgLy8gcGFydGljbGVcbiAgICB2YXIgYWxpdmU7XG4gICAgdmFyIGZyYW1lcyA9IGRhdGEuZnJhbWVzO1xuICAgIHZhciB2ZWxPZmZzZXQgPSBkYXRhLnJvdGF0aW9uID8gMyA6IDA7XG4gICAgdmFyIEYgPSBkYXRhLnByZWNpc2lvbjtcbiAgICB0aGlzLnJlc3RQb3NpdGlvbnMgPSBbXTtcbiAgICB0aGlzLnJlc3RSb3RhdGlvbnMgPSBbXTsgXG5cbiAgICB0aGlzLnVzZVJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcblxuICAgIGlmIChkYXRhLnNwcml0ZV9yb3RhdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuc3ByaXRlX3JvdGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMuc3ByaXRlX3JvdGF0aW9uLnggPSBkYXRhLnNwcml0ZV9yb3RhdGlvblswXSAvIEY7XG4gICAgICB0aGlzLnNwcml0ZV9yb3RhdGlvbi55ID0gZGF0YS5zcHJpdGVfcm90YXRpb25bMV0gLyBGO1xuICAgICAgdGhpcy5zcHJpdGVfcm90YXRpb24ueiA9IGRhdGEuc3ByaXRlX3JvdGF0aW9uWzJdIC8gRjtcbiAgICB9XG4gICAgZWxzZSB7IHRoaXMuc3ByaXRlX3JvdGF0aW9uID0gZmFsc2U7IH1cblxuICAgIHRoaXMuZnJhbWVkYXRhID0gbmV3IEFycmF5KGZyYW1lcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGYgPSAwOyBmIDwgZnJhbWVzLmxlbmd0aDsgZisrKSB7XG4gICAgICB0aGlzLmZyYW1lZGF0YVtmXSA9IG5ldyBBcnJheShmcmFtZXNbZl0ubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzW2ZdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHAgPSBmcmFtZXNbZl1baV07IC8vIGRhdGEgb2YgcGFydGljbGUgaSBpbiBmcmFtZSBmXG4gICAgICAgIGFsaXZlID0gcCAhPT0gMDtcblxuICAgICAgICB0aGlzLmZyYW1lZGF0YVtmXVtpXSA9IHtcbiAgICAgICAgICBwb3NpdGlvbjogYWxpdmUgPyBcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKHBbMF0gLyBGICogc2NhbGUsIHBbMV0gLyBGICogc2NhbGUsIHBbMl0gLyBGICogc2NhbGUpIDpcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgYWxpdmU6IGFsaXZlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRhdGEucm90YXRpb24pIHtcbiAgICAgICAgICB0aGlzLmZyYW1lZGF0YVtmXVtpXS5yb3RhdGlvbiA9IGFsaXZlID8gXG4gICAgICAgICAgICBuZXcgVEhSRUUuRXVsZXIocFszXSAvIEYsIHBbNF0gLyBGLCBwWzVdIC8gRikgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGl2ZSAmJiB0aGlzLnJlc3RQb3NpdGlvbnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmVzdFBvc2l0aW9uc1tpXSA9IHRoaXMuZnJhbWVkYXRhW2ZdW2ldLnBvc2l0aW9uO1xuICAgICAgICAgIGlmIChkYXRhLnJvdGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3RSb3RhdGlvbnNbaV0gPSB0aGlzLmZyYW1lZGF0YVtmXVtpXS5yb3RhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY2FjaGVQYXJ0aWNsZXM6IGZ1bmN0aW9uIChudW1QYXJ0aWNsZVN5c3RlbXMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgcDtcbiAgICB2YXIgYWxsUGFydGljbGVzO1xuICAgIHZhciBsb29wID0gcGFyc2VJbnQodGhpcy5kYXRhLmxvb3ApO1xuICAgIFxuICAgIC8vcmVtb3ZlIG9sZCBwYXJ0aWNsZXNcbiAgICBhbGxQYXJ0aWNsZXMgPSB0aGlzLmFsbFBhcnRpY2xlc0VsLm9iamVjdDNEO1xuICAgIHdoaWxlIChhbGxQYXJ0aWNsZXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBhbGxQYXJ0aWNsZXMucmVtb3ZlKGFsbFBhcnRpY2xlcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZSA9IFtdO1xuXG4gICAgaWYgKGlzTmFOKGxvb3ApKSB7IFxuICAgICAgbG9vcCA9IHRoaXMuZGF0YS5sb29wID09PSAndHJ1ZScgPyBOdW1iZXIuTUFYX1ZBTFVFIDogMDsgXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVBhcnRpY2xlU3lzdGVtczsgaSsrKSB7XG4gICAgICB2YXIgcHMgPSB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGxvb3BUb3RhbDogbG9vcCxcbiAgICAgICAgbG9vcENvdW50OiAwLFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBhY3RpdmVQYXJ0aWNsZXM6IG5ldyBBcnJheSh0aGlzLmNvdW50KSxcbiAgICAgICAgb2JqZWN0M0Q6IG5ldyBUSFJFRS5PYmplY3QzRCgpXG4gICAgICB9O1xuXG4gICAgICBwcy5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgIGZvciAocCA9IDA7IHAgPCB0aGlzLm51bVBhcnRpY2xlczsgcCsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgICAgIHBhcnQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBwcy5vYmplY3QzRC5hZGQocGFydCk7XG4gICAgICAgIGlmIChwIDwgdGhpcy5jb3VudCkge1xuICAgICAgICAgIHBzLmFjdGl2ZVBhcnRpY2xlc1twXSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWxsUGFydGljbGVzLmFkZChwcy5vYmplY3QzRCk7XG4gICAgICB0aGlzLmNhY2hlLnB1c2gocHMpO1xuICAgIH1cbiAgfSxcblxuICBzdGFydDogZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmICh0aGlzLmRhdGEuZGVsYXkgPiAwKSB7XG4gICAgICBzZXRUaW1lb3V0KCAoKSA9PiB0aGlzLnN0YXJ0QWZ0ZXJEZWxheShldnQpLCB0aGlzLmRhdGEuZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0QWZ0ZXJEZWxheShldnQpO1xuICAgIH1cbiAgfSxcblxuICBzdGFydEFmdGVyRGVsYXk6IGZ1bmN0aW9uIChldnQpIHsgXG4gICAgLy8gcG9zaXRpb24sIHJvdGF0aW9uXG4gICAgdmFyIGZvdW5kID0gLTE7XG4gICAgdmFyIHBzO1xuICAgIHZhciBpZDtcbiAgICB2YXIgb2xkZXN0VGltZSA9IDA7XG4gICAgdmFyIHBvc2l0aW9uID0gZXZ0ID8gZXZ0LmRldGFpbFsncG9zaXRpb24nXSA6IG51bGw7XG4gICAgdmFyIHJvdGF0aW9uID0gZXZ0ID8gZXZ0LmRldGFpbFsncm90YXRpb24nXSA6IG51bGw7XG5cbiAgICBpZiAoIShwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpKSB7IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTsgfVxuICAgIGlmICghKHJvdGF0aW9uIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIpKSB7IHJvdGF0aW9uID0gbmV3IFRIUkVFLkV1bGVyKCk7IH1cblxuICAgIC8vIGZpbmQgYXZhaWxhYmxlIChvciBvbGRlc3QpIHBhcnRpY2xlIHN5c3RlbVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2FjaGVbaV0uYWN0aXZlID09PSBmYWxzZSl7XG4gICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYWNoZVtpXS50aW1lID4gb2xkZXN0VGltZSkge1xuICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgIG9sZGVzdFRpbWUgPSB0aGlzLmNhY2hlW2ldLnRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHMgPSB0aGlzLmNhY2hlW2ZvdW5kXTtcblxuICAgIHBzLmFjdGl2ZSA9IHRydWU7XG4gICAgcHMubG9vcENvdW50ID0gMTtcbiAgICBwcy5vYmplY3QzRC52aXNpYmxlID0gdHJ1ZTtcbiAgICBwcy5vYmplY3QzRC5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcy5vYmplY3QzRC5yb3RhdGlvbi5jb3B5KHJvdGF0aW9uKTtcbiAgICBwcy50aW1lID0gMDtcblxuICAgIHRoaXMucmVzZXRQYXJ0aWNsZXMocHMpO1xuICB9LFxuXG4gIGRvTG9vcDogZnVuY3Rpb24gKHBzKSB7XG4gICAgcHMubG9vcENvdW50Kys7XG4gICAgcHMuZnJhbWUgPSAtMTtcbiAgICBwcy50aW1lID0gMDtcbiAgICB0aGlzLnJlc2V0UGFydGljbGVzKHBzKTtcbiAgfSxcblxuICByZXNldFBhcnRpY2xlOiBmdW5jdGlvbiAocGFydCwgaSkge1xuICAgIHBhcnQudmlzaWJsZSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnJlc3RQb3NpdGlvbnNbaV0pIHsgcGFydC5wb3NpdGlvbi5jb3B5KHRoaXMucmVzdFBvc2l0aW9uc1tpXSk7IH1cbiAgICBpZiAodGhpcy51c2VSb3RhdGlvbil7XG4gICAgICBpZiAodGhpcy5yZXN0Um90YXRpb25zW2ldKSB7IHBhcnQucm90YXRpb24uY29weSh0aGlzLnJlc3RSb3RhdGlvbnNbaV0pOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vcGFydC5sb29rQXQodGhpcy5jYW1lcmEucG9zaXRpb24pOyAvLyBsb29rQXQgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGVkIG9yIHRyYW5zbGF0ZWQgcGFyZW50cyEgOl8oXG4gICAgfVxuICB9LFxuXG4vKipcbiAqIFdoZW4gc3RhcnRpbmcgb3IgZmluaXNoaW5nIChsb29waW5nKSBhbmltYXRpb24sIHRoaXMgcmVzZXRzIHBhcnRpY2xlc1xuICogdG8gdGhlaXIgaW5pdGlhbCBwb3NpdGlvbiBhbmQsIGlmIHVzZXIgYXNrZWQgZm9yIHJlcGxheWluZyBsZXNzIHRoYW4gMTAwJVxuICogb2YgcGFydGljbGVzLCByYW5kb21seSBjaG9vc2UgdGhlbS5cbiAqL1xuICByZXNldFBhcnRpY2xlczogZnVuY3Rpb24gKHBzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHBpO1xuICAgIHZhciBwYXJ0O1xuICAgIHZhciByYW5kO1xuICAgIHZhciBhdXg7XG5cbiAgICAvLyBubyBwaWNraW5nLCBqdXN0IGhpZGUgYW5kIHJlc2V0XG4gICAgaWYgKHRoaXMuY291bnQgPT09IHRoaXMubnVtUGFydGljbGVzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1QYXJ0aWNsZXM7IGkrKykgeyBcbiAgICAgICAgdGhpcy5yZXNldFBhcnRpY2xlKHBzLm9iamVjdDNELmNoaWxkcmVuW2ldLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBoaWRlIHBhcnRpY2xlcyBmcm9tIGxhc3QgYW5pbWF0aW9uIGFuZCBpbml0aWFsaXplIGluZGV4UG9vbFxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bVBhcnRpY2xlczsgaSsrKSB7IFxuICAgICAgaWYgKGkgPCB0aGlzLmNvdW50KSB7XG4gICAgICAgIHBzLm9iamVjdDNELmNoaWxkcmVuWyBwcy5hY3RpdmVQYXJ0aWNsZXNbaV0gXS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmluZGV4UG9vbFtpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gc2NyYW1ibGUgaW5kZXhQb29sXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY291bnQgLSAxOyBpKyspIHsgXG4gICAgICByYW5kID0gaSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0aGlzLm51bVBhcnRpY2xlcyAtIGkpKTtcbiAgICAgIHBzLmFjdGl2ZVBhcnRpY2xlc1tpXSA9IHRoaXMuaW5kZXhQb29sW3JhbmRdO1xuICAgICAgdGhpcy5pbmRleFBvb2xbcmFuZF0gPSB0aGlzLmluZGV4UG9vbFtpXTtcbiAgICAgIHRoaXMucmVzZXRQYXJ0aWNsZShwcy5vYmplY3QzRC5jaGlsZHJlbltwcy5hY3RpdmVQYXJ0aWNsZXNbaV1dLCBpKTtcbiAgICB9XG4gIH0sXG5cbiAgdGljazogZnVuY3Rpb24gKHRpbWUsIGRlbHRhKSB7XG4gICAgdmFyIGosIGk7IC8vIGxvb3AgdmFyc1xuICAgIHZhciBwczsgLy8gY3VycmVudCBwYXJ0aWNsZSBzeXN0ZW1cbiAgICB2YXIgZnJhbWU7IC8vIGN1cnJlbnQgcGFydGljbGUgc3lzdGVtIGZyYW1lXG4gICAgdmFyIHBhcnRpY2xlOyAvLyBjdXJyZW50IHBhcnRpY2xlXG4gICAgdmFyIHBpOyAvLyBpbmRleCBvZiBjdXJyZW50IHBhcnRpY2xlXG4gICAgdmFyIGZkYXRhOyAvLyBhbGwgcGFydGljbGVzIGRhdGEgaW4gY3VycmVudCBmcmFtZVxuICAgIHZhciBmZGF0YU5leHQ7IC8vIG5leHQgZnJhbWUgKGZvciBpbnRlcnBvbGF0aW9uKVxuICAgIHZhciB1c2VSb3RhdGlvbiA9IHRoaXMudXNlUm90YXRpb247XG4gICAgdmFyIGZyYW1lVGltZTsgLy8gdGltZSBpbiBjdXJyZW50IGZyYW1lIChmb3IgaW50ZXJwb2xhdGlvbilcbiAgICB2YXIgcmVsVGltZTsgLy8gY3VycmVudCBwYXJ0aWNsZSBzeXN0ZW0gcmVsYXRpdmUgdGltZSAoMC0xKVxuICAgIHZhciBpbnRlcnBvbGF0ZTsgLy8gd2hldGhlciBpbnRlcnBvbGF0ZSBiZXR3ZWVuIGZyYW1lcyBvciBub3RcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcyA9IHRoaXMuY2FjaGVbaV07XG4gICAgICBpZiAoIXBzLmFjdGl2ZSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIGlmIHRoZSBkdXJhdGlvbiBpcyBzbyBzaG9ydCB0aGF0IHRoZXJlJ3Mgbm8gbmVlZCB0byBpbnRlcnBvbGF0ZSwgZG9uJ3QgZG8gaXRcbiAgICAgIC8vIGV2ZW4gaWYgdXNlciBhc2tlZCBmb3IgaXQuXG4gICAgICBpbnRlcnBvbGF0ZSA9IHRoaXMuZGF0YS5pbnRlcnBvbGF0ZSAmJiB0aGlzLmRhdGEuZHVyIC8gdGhpcy5udW1GcmFtZXMgPiBkZWx0YTtcblxuICAgICAgcmVsVGltZSA9IHBzLnRpbWUgLyB0aGlzLmRhdGEuZHVyO1xuICAgICAgZnJhbWUgPSByZWxUaW1lICogdGhpcy5udW1GcmFtZXM7XG4gICAgICBmZGF0YSA9IHRoaXMuZnJhbWVkYXRhW01hdGguZmxvb3IoZnJhbWUpXTtcbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBmcmFtZVRpbWUgPSBmcmFtZSAtIE1hdGguZmxvb3IoZnJhbWUpO1xuICAgICAgICBmZGF0YU5leHQgPSBmcmFtZSA8IHRoaXMubnVtRnJhbWVzIC0gMSA/IHRoaXMuZnJhbWVkYXRhW01hdGguZmxvb3IoZnJhbWUpICsgMV0gOiBudWxsO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IHBzLmFjdGl2ZVBhcnRpY2xlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBwaSA9IHBzLmFjdGl2ZVBhcnRpY2xlc1tqXTtcbiAgICAgICAgcGFydGljbGUgPSBwcy5vYmplY3QzRC5jaGlsZHJlbltwaV07XG4gICAgICAgIGlmICghZmRhdGFbcGldLmFsaXZlKXtcbiAgICAgICAgICBwYXJ0aWNsZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gXG5cbiAgICAgICAgcGFydGljbGUudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGludGVycG9sYXRlICYmIGZkYXRhTmV4dCAmJiBmZGF0YU5leHRbcGldLmFsaXZlKSB7XG4gICAgICAgICAgcGFydGljbGUucG9zaXRpb24ubGVycFZlY3RvcnMoZmRhdGFbcGldLnBvc2l0aW9uLCBmZGF0YU5leHRbcGldLnBvc2l0aW9uLCBmcmFtZVRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLmNvcHkoZmRhdGFbcGldLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VSb3RhdGlvbikge1xuICAgICAgICAgIHBhcnRpY2xlLnJvdGF0aW9uLmNvcHkoZmRhdGFbcGldLnJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcy50aW1lICs9IGRlbHRhO1xuICAgICAgaWYgKHBzLnRpbWUgPj0gdGhpcy5kYXRhLmR1cikge1xuICAgICAgICBpZiAocHMubG9vcENvdW50IDwgcHMubG9vcFRvdGFsKSB7XG4gICAgICAgICAgdGhpcy5lbC5lbWl0KCdsb29wJyk7XG4gICAgICAgICAgdGhpcy5kb0xvb3AocHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWwuZW1pdCgnZmluaXNoZWQnKTtcbiAgICAgICAgICBwcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICBwcy5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FmcmFtZS1wYXJ0aWNsZXBsYXllci1jb21wb25lbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIExpc3RlbiB0byBldmVudCBhbmQgZm9yd2FyZCB0byBhbm90aGVyIGVudGl0eSBvciBlbnRpdGllcy5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdwcm94eS1ldmVudCcsIHtcbiAgc2NoZW1hOiB7XG4gICAgY2FwdHVyZUJ1YmJsZXM6IHtkZWZhdWx0OiBmYWxzZX0sXG4gICAgZXZlbnQ6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgdG86IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgYXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgYnViYmxlczoge2RlZmF1bHQ6IGZhbHNlfVxuICB9LFxuXG4gIG11bHRpcGxlOiB0cnVlLFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciB0bztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZGF0YS50byA9PT0gJ0NISUxEUkVOJykge1xuICAgICAgdG8gPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnRvID09PSAnU0VMRicpIHtcbiAgICAgIHRvID0gW2VsXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRhdGEudG8pO1xuICAgIH1cblxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZGF0YS5ldmVudCwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyIGRhdGEgPSBzZWxmLmRhdGE7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmICghZGF0YS5jYXB0dXJlQnViYmxlcyAmJiBldnQudGFyZ2V0ICE9PSBlbCkgeyByZXR1cm47IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0by5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b1tpXS5lbWl0KGRhdGEuYXMgfHwgZGF0YS5ldmVudCwgbnVsbCwgZGF0YS5idWJibGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWZyYW1lLXByb3h5LWV2ZW50LWNvbXBvbmVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBBRlJBTUUgKi9cblxuaWYgKHR5cGVvZiBBRlJBTUUgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGF0dGVtcHRlZCB0byByZWdpc3RlciBiZWZvcmUgQUZSQU1FIHdhcyBhdmFpbGFibGUuJyk7XG59XG5cbi8qKlxuICogU2xpY2U5IGNvbXBvbmVudCBmb3IgQS1GcmFtZS5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdzbGljZTknLCB7XG4gIHNjaGVtYToge1xuICAgIHdpZHRoOiB7ZGVmYXVsdDogMSwgbWluOiAwfSxcbiAgICBoZWlnaHQ6IHtkZWZhdWx0OiAxLCBtaW46IDB9LFxuICAgIGxlZnQ6IHtkZWZhdWx0OiAwLCBtaW46IDB9LFxuICAgIHJpZ2h0OiB7ZGVmYXVsdDogMCwgbWluOiAwfSxcbiAgICBib3R0b206IHtkZWZhdWx0OiAwLCBtaW46IDB9LFxuICAgIHRvcDoge2RlZmF1bHQ6IDAsIG1pbjogMH0sXG4gICAgc2lkZToge2RlZmF1bHQ6ICdmcm9udCcsIG9uZU9mOiBbJ2Zyb250JywgJ2JhY2snLCAnZG91YmxlJ119LFxuICAgIHBhZGRpbmc6IHtkZWZhdWx0OiAwLjEsIG1pbjogMC4wMX0sXG4gICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0OiAnI2ZmZid9LFxuICAgIG9wYWNpdHk6IHtkZWZhdWx0OiAxLjAsIG1pbjogMCwgbWF4OiAxfSxcbiAgICB0cmFuc3BhcmVudDoge2RlZmF1bHQ6IHRydWV9LFxuICAgIGRlYnVnOiB7ZGVmYXVsdDogZmFsc2V9LFxuICAgIHNyYzoge3R5cGU6ICdtYXAnfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgaWYgY29tcG9uZW50IG5lZWRzIG11bHRpcGxlIGluc3RhbmNpbmcuXG4gICAqL1xuICBtdWx0aXBsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbmNlIHdoZW4gY29tcG9uZW50IGlzIGF0dGFjaGVkLiBHZW5lcmFsbHkgZm9yIGluaXRpYWwgc2V0dXAuXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6IGRhdGEuY29sb3IsIG9wYWNpdHk6IGRhdGEub3BhY2l0eSwgdHJhbnNwYXJlbnQ6IGRhdGEudHJhbnNwYXJlbnQsIHdpcmVmcmFtZTogZGF0YS5kZWJ1Z30pO1xuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgMywgMyk7XG5cbiAgICB2YXIgdGV4dHVyZUxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgdGhpcy5lbC5zZXRPYmplY3QzRCgnbWVzaCcsIHRoaXMucGxhbmUpO1xuICAgIHRoaXMudGV4dHVyZVNyYyA9IG51bGw7XG4gIH0sXG5cbiAgdXBkYXRlTWFwOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNyYyA9IHRoaXMuZGF0YS5zcmM7XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICBpZiAoc3JjID09PSB0aGlzLnRleHR1cmVTcmMpIHsgcmV0dXJuOyB9XG4gICAgICAvLyBUZXh0dXJlIGFkZGVkIG9yIGNoYW5nZWQuXG4gICAgICB0aGlzLnRleHR1cmVTcmMgPSBzcmM7XG4gICAgICB0aGlzLmVsLnNjZW5lRWwuc3lzdGVtcy5tYXRlcmlhbC5sb2FkVGV4dHVyZShzcmMsIHtzcmM6IHNyY30sIHNldE1hcC5iaW5kKHRoaXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUZXh0dXJlIHJlbW92ZWQuXG4gICAgaWYgKCF0aGlzLm1hdGVyaWFsLm1hcCkgeyByZXR1cm47IH1cbiAgICBzZXRNYXAobnVsbCk7XG5cblxuICAgIGZ1bmN0aW9uIHNldE1hcCAodGV4dHVyZSkge1xuICAgICAgdGhpcy5tYXRlcmlhbC5tYXAgPSB0ZXh0dXJlO1xuICAgICAgdGhpcy5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGVNZXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlZ2VuZXJhdGVNZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHBvcyA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICB2YXIgdXZzID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnV2LmFycmF5O1xuICAgIHZhciBpbWFnZSA9IHRoaXMubWF0ZXJpYWwubWFwLmltYWdlO1xuXG4gICAgaWYgKCFpbWFnZSkge3JldHVybjt9XG5cbiAgICAvKlxuICAgICAgMC0tMS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTItLTNcbiAgICAgIHwgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB8XG4gICAgICA0LS01LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tNi0tN1xuICAgICAgfCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHxcbiAgICAgIHwgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB8XG4gICAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgfFxuICAgICAgOC0tOS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tMTAtLTExXG4gICAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgfFxuICAgICAgMTItMTMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tMTQtLTE1XG4gICAgKi9cbiAgICBmdW5jdGlvbiBzZXRQb3MoaWQsIHgsIHkpIHtcbiAgICAgIHBvc1szICogaWRdID0geDtcbiAgICAgIHBvc1szICogaWQgKyAxXSA9IHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VVYoaWQsIHUsIHYpIHtcbiAgICAgIHV2c1syICogaWRdID0gdTtcbiAgICAgIHV2c1syICogaWQgKyAxXSA9IHY7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFVWU1xuICAgIHZhciB1diA9IHtcbiAgICAgIGxlZnQ6IGRhdGEubGVmdCAvIGltYWdlLndpZHRoLFxuICAgICAgcmlnaHQ6IGRhdGEucmlnaHQgLyBpbWFnZS53aWR0aCxcbiAgICAgIHRvcDogZGF0YS50b3AgLyBpbWFnZS5oZWlnaHQsXG4gICAgICBib3R0b206IGRhdGEuYm90dG9tIC8gaW1hZ2UuaGVpZ2h0XG4gICAgfTtcblxuICAgIHNldFVWKDEsICB1di5sZWZ0LCAgMSk7XG4gICAgc2V0VVYoMiwgIHV2LnJpZ2h0LCAxKTtcblxuICAgIHNldFVWKDQsICAwLCAgICAgICAgdXYuYm90dG9tKTtcbiAgICBzZXRVVig1LCAgdXYubGVmdCwgIHV2LmJvdHRvbSk7XG4gICAgc2V0VVYoNiwgIHV2LnJpZ2h0LCB1di5ib3R0b20pO1xuICAgIHNldFVWKDcsICAxLCAgICAgICAgdXYuYm90dG9tKTtcblxuICAgIHNldFVWKDgsICAwLCAgICAgICAgdXYudG9wKTtcbiAgICBzZXRVVig5LCAgdXYubGVmdCwgIHV2LnRvcCk7XG4gICAgc2V0VVYoMTAsIHV2LnJpZ2h0LCB1di50b3ApO1xuICAgIHNldFVWKDExLCAxLCAgICAgICAgdXYudG9wKTtcblxuICAgIHNldFVWKDEzLCB1di5sZWZ0LCAgMCk7XG4gICAgc2V0VVYoMTQsIHV2LnJpZ2h0LCAwKTtcblxuICAgIC8vIFVwZGF0ZSB2ZXJ0ZXggcG9zaXRpb25zXG4gICAgdmFyIHcyID0gZGF0YS53aWR0aCAvIDI7XG4gICAgdmFyIGgyID0gZGF0YS5oZWlnaHQgLyAyO1xuICAgIHZhciBsZWZ0ID0gLXcyICsgZGF0YS5wYWRkaW5nO1xuICAgIHZhciByaWdodCA9IHcyIC0gZGF0YS5wYWRkaW5nO1xuICAgIHZhciB0b3AgPSBoMiAtIGRhdGEucGFkZGluZztcbiAgICB2YXIgYm90dG9tID0gLWgyICsgZGF0YS5wYWRkaW5nO1xuXG4gICAgc2V0UG9zKDAsIC13MiwgICAgaDIpO1xuICAgIHNldFBvcygxLCBsZWZ0LCAgIGgyKTtcbiAgICBzZXRQb3MoMiwgcmlnaHQsICBoMik7XG4gICAgc2V0UG9zKDMsIHcyLCAgICAgaDIpO1xuXG4gICAgc2V0UG9zKDQsIC13MiwgICAgdG9wKTtcbiAgICBzZXRQb3MoNSwgbGVmdCwgICB0b3ApO1xuICAgIHNldFBvcyg2LCByaWdodCwgIHRvcCk7XG4gICAgc2V0UG9zKDcsIHcyLCAgICAgdG9wKTtcblxuICAgIHNldFBvcyg4LCAtdzIsICAgIGJvdHRvbSk7XG4gICAgc2V0UG9zKDksIGxlZnQsICAgYm90dG9tKTtcbiAgICBzZXRQb3MoMTAsIHJpZ2h0LCBib3R0b20pO1xuICAgIHNldFBvcygxMSwgdzIsICAgIGJvdHRvbSk7XG5cbiAgICBzZXRQb3MoMTMsIGxlZnQsICAtaDIpO1xuICAgIHNldFBvcygxNCwgcmlnaHQsIC1oMik7XG4gICAgc2V0UG9zKDEyLCAtdzIsICAgLWgyKTtcbiAgICBzZXRQb3MoMTUsIHcyLCAgICAtaDIpO1xuXG4gICAgdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMudXYubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBjb21wb25lbnQgaXMgYXR0YWNoZWQgYW5kIHdoZW4gY29tcG9uZW50IGRhdGEgY2hhbmdlcy5cbiAgICogR2VuZXJhbGx5IG1vZGlmaWVzIHRoZSBlbnRpdHkgYmFzZWQgb24gdGhlIGRhdGEuXG4gICAqL1xuICAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgICB0aGlzLm1hdGVyaWFsLmNvbG9yLnNldFN0eWxlKGRhdGEuY29sb3IpO1xuICAgICB0aGlzLm1hdGVyaWFsLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgIHRoaXMubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBkYXRhLnRyYW5zcGFyZW50O1xuICAgICB0aGlzLm1hdGVyaWFsLndpcmVmcmFtZSA9IGRhdGEuZGVidWc7XG4gICAgIHRoaXMubWF0ZXJpYWwuc2lkZSA9IHBhcnNlU2lkZShkYXRhLnNpZGUpO1xuXG4gICAgIHZhciBkaWZmID0gQUZSQU1FLnV0aWxzLmRpZmYoZGF0YSwgb2xkRGF0YSk7XG4gICAgIGlmICgnc3JjJyBpbiBkaWZmKSB7XG4gICAgICAgdGhpcy51cGRhdGVNYXAoKTtcbiAgICAgfVxuICAgICBlbHNlIGlmICgnd2lkdGgnIGluIGRpZmYgfHwgJ2hlaWdodCcgaW4gZGlmZiB8fCAncGFkZGluZycgaW4gZGlmZiB8fCAnbGVmdCcgaW4gZGlmZiB8fMKgJ3RvcCcgaW4gZGlmZiB8fMKgJ2JvdHRvbScgaW4gZGlmZiB8fMKgJ3JpZ2h0JyBpbiBkaWZmKSB7XG4gICAgICAgdGhpcy5yZWdlbmVyYXRlTWVzaCgpO1xuICAgICB9XG4gICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZW1vdmVkIChlLmcuLCB2aWEgcmVtb3ZlQXR0cmlidXRlKS5cbiAgICogR2VuZXJhbGx5IHVuZG9lcyBhbGwgbW9kaWZpY2F0aW9ucyB0byB0aGUgZW50aXR5LlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbiBlYWNoIHNjZW5lIHRpY2suXG4gICAqL1xuICAvLyB0aWNrOiBmdW5jdGlvbiAodCkgeyB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBlbnRpdHkgcGF1c2VzLlxuICAgKiBVc2UgdG8gc3RvcCBvciByZW1vdmUgYW55IGR5bmFtaWMgb3IgYmFja2dyb3VuZCBiZWhhdmlvciBzdWNoIGFzIGV2ZW50cy5cbiAgICovXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGVudGl0eSByZXN1bWVzLlxuICAgKiBVc2UgdG8gY29udGludWUgb3IgYWRkIGFueSBkeW5hbWljIG9yIGJhY2tncm91bmQgYmVoYXZpb3Igc3VjaCBhcyBldmVudHMuXG4gICAqL1xuICBwbGF5OiBmdW5jdGlvbiAoKSB7IH1cbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVNpZGUgKHNpZGUpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAnYmFjayc6IHtcbiAgICAgIHJldHVybiBUSFJFRS5CYWNrU2lkZTtcbiAgICB9XG4gICAgY2FzZSAnZG91YmxlJzoge1xuICAgICAgcmV0dXJuIFRIUkVFLkRvdWJsZVNpZGU7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIC8vIEluY2x1ZGluZyBjYXNlIGBmcm9udGAuXG4gICAgICByZXR1cm4gVEhSRUUuRnJvbnRTaWRlO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FmcmFtZS1zbGljZTktY29tcG9uZW50L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBBTkQgPSAnJiYnO1xudmFyIFFVT1RFX1JFID0gLycvZztcbnZhciBPUiA9ICd8fCc7XG52YXIgQ09NUEFSSVNPTlMgPSBbJz09JywgJz09PScsICchPScsICchPT0nXTtcbnZhciB0ZW1wVG9rZW5BcnJheSA9IFtdO1xudmFyIHRva2VuQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBTZWxlY3QgdmFsdWUgZnJvbSBzdG9yZS4gSGFuZGxlcyBib29sZWFuIG9wZXJhdGlvbnMsIGNhbGxzIGBzZWxlY3RQcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gU3RhdGUgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gRG90LWRlbGltaXRlZCBzdG9yZSBrZXlzIChlLmcuLCBnYW1lLnBsYXllci5oZWFsdGgpLlxuICovXG5mdW5jdGlvbiBzZWxlY3Qoc3RhdGUsIHNlbGVjdG9yLCBiaW5kRm9yLCBiaW5kRm9yS2V5KSB7XG4gIHZhciBjb21wYXJpc29uUmVzdWx0O1xuICB2YXIgZmlyc3RWYWx1ZTtcbiAgdmFyIGk7XG4gIHZhciBydW5uaW5nQm9vbDtcbiAgdmFyIHNlY29uZFZhbHVlO1xuICB2YXIgdG9rZW5zO1xuICB2YXIgdmFsdWU7XG5cbiAgLy8gSWYganVzdCBzaW5nbGUgc2VsZWN0b3IsIHRoZW4gZ3JhYiB2YWx1ZS5cbiAgdG9rZW5zID0gc3BsaXQoc2VsZWN0b3IsIC9cXHMrLyk7XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNlbGVjdFByb3BlcnR5KHN0YXRlLCBzZWxlY3RvciwgYmluZEZvciwgYmluZEZvcktleSk7XG4gIH1cblxuICAvLyBFdmFsdWF0ZSBjb21wYXJpc29ucy5cbiAgdG9rZW5BcnJheS5sZW5ndGggPSAwO1xuICBjb3B5QXJyYXkodGVtcFRva2VuQXJyYXksIHRva2Vucyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0ZW1wVG9rZW5BcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChDT01QQVJJU09OUy5pbmRleE9mKHRlbXBUb2tlbkFycmF5W2ldKSA9PT0gLTEpIHtcbiAgICAgIHRva2VuQXJyYXkucHVzaCh0ZW1wVG9rZW5BcnJheVtpXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDb21wYXJpc29uIChjb2xvciA9PT0gJ3JlZCcpLlxuICAgIC8vIFBvcCBwcmV2aW91cyB2YWx1ZSBzaW5jZSB0aGF0IGlzIG9uZSBvZiBjb21wYXJzaW9uIHZhbHVlLlxuICAgIGZpcnN0VmFsdWUgPSBzZWxlY3RQcm9wZXJ0eShzdGF0ZSwgdG9rZW5BcnJheS5wb3AoKSk7XG4gICAgLy8gTG9va3VwIHNlY29uZCB2YWx1ZS5cbiAgICBzZWNvbmRWYWx1ZSA9IHRlbXBUb2tlbkFycmF5W2kgKyAxXS5yZXBsYWNlKFFVT1RFX1JFLCAnJyk7XG4gICAgLy8gRXZhbHVhdGUgKGVxdWFscyBvciBub3QgZXF1YWxzKS5cbiAgICBmaXJzdFZhbHVlID0gZmlyc3RWYWx1ZSA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBmaXJzdFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgc2Vjb25kVmFsdWUgPSBzZWNvbmRWYWx1ZSA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBzZWNvbmRWYWx1ZS50b1N0cmluZygpO1xuICAgIGNvbXBhcmlzb25SZXN1bHQgPSB0ZW1wVG9rZW5BcnJheVtpXS5pbmRleE9mKCchJykgPT09IC0xID8gZmlyc3RWYWx1ZSA9PT0gc2Vjb25kVmFsdWUgOiBmaXJzdFZhbHVlICE9PSBzZWNvbmRWYWx1ZTtcbiAgICB0b2tlbkFycmF5LnB1c2goY29tcGFyaXNvblJlc3VsdCk7XG4gICAgaSsrO1xuICB9XG5cbiAgLy8gV2FzIHNpbmdsZSBjb21wYXJpc29uLlxuICBpZiAodG9rZW5BcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdG9rZW5BcnJheVswXTtcbiAgfVxuXG4gIC8vIElmIGhhcyBib29sZWFuIGV4cHJlc3Npb24sIGV2YWx1YXRlLlxuICBydW5uaW5nQm9vbCA9IHRva2VuQXJyYXlbMF0uY29uc3RydWN0b3IgPT09IEJvb2xlYW4gPyB0b2tlbkFycmF5WzBdIDogc2VsZWN0UHJvcGVydHkoc3RhdGUsIHRva2VuQXJyYXlbMF0sIGJpbmRGb3IsIGJpbmRGb3JLZXkpO1xuICBmb3IgKGkgPSAxOyBpIDwgdG9rZW5BcnJheS5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmICh0b2tlbkFycmF5W2ldICE9PSBPUiAmJiB0b2tlbkFycmF5W2ldICE9PSBBTkQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB3YXMgZXZhbHVhdGVkIGNvbXBhcmlzb24gKGJvb2wpIG9yIGEgc2VsZWN0b3IgKHN0cmluZykuXG4gICAgdG9rZW5BcnJheVtpICsgMV0gPSB0b2tlbkFycmF5W2kgKyAxXS5jb25zdHJ1Y3RvciA9PT0gQm9vbGVhbiA/IHRva2VuQXJyYXlbaSArIDFdIDogc2VsZWN0UHJvcGVydHkoc3RhdGUsIHRva2VuQXJyYXlbaSArIDFdKTtcblxuICAgIC8vIEV2YWx1YXRlIGJvb2xlYW4uXG4gICAgaWYgKHRva2VuQXJyYXlbaV0gPT09IE9SKSB7XG4gICAgICBydW5uaW5nQm9vbCA9IHJ1bm5pbmdCb29sIHx8IHRva2VuQXJyYXlbaSArIDFdO1xuICAgIH0gZWxzZSBpZiAodG9rZW5BcnJheVtpXSA9PT0gQU5EKSB7XG4gICAgICBydW5uaW5nQm9vbCA9IHJ1bm5pbmdCb29sICYmIHRva2VuQXJyYXlbaSArIDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnVubmluZ0Jvb2w7XG59XG5tb2R1bGUuZXhwb3J0cy5zZWxlY3QgPSBzZWxlY3Q7XG5cbi8qKlxuICogRG9lcyBhY3R1YWwgc2VsZWN0aW5nIGFuZCB3YWxraW5nIG9mIHN0YXRlLlxuICovXG5mdW5jdGlvbiBzZWxlY3RQcm9wZXJ0eShzdGF0ZSwgc2VsZWN0b3IsIGJpbmRGb3IsIGJpbmRGb3JLZXkpIHtcbiAgdmFyIGk7XG4gIHZhciBvcmlnaW5hbFNlbGVjdG9yO1xuICB2YXIgc3BsaXR0ZWQ7XG4gIHZhciB2YWx1ZTtcblxuICAvLyBJZiBiaW5kRm9yLCBzZWxlY3QgdGhlIGFycmF5LiBUaGVuIGxhdGVyLCB3ZSBmaWx0ZXIgdGhlIGFycmF5LlxuICBpZiAoYmluZEZvciAmJiBzZWxlY3Rvci5zdGFydHNXaXRoKGJpbmRGb3IuZm9yKSkge1xuICAgIG9yaWdpbmFsU2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICBzZWxlY3RvciA9IGJpbmRGb3IuaW47XG4gIH1cblxuICAvLyBXYWxrLlxuICB2YWx1ZSA9IHN0YXRlO1xuICBzcGxpdHRlZCA9IHNwbGl0KHN0cmlwTm90KHNlbGVjdG9yKSwgJy4nKTtcbiAgZm9yIChpID0gMDsgaSA8IHNwbGl0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPCBzcGxpdHRlZC5sZW5ndGggLSAxICYmICEoc3BsaXR0ZWRbaV0gaW4gdmFsdWUpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbc3RhdGVdIE5vdCBmb3VuZDonLCBzcGxpdHRlZCwgc3BsaXR0ZWRbaV0pO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlW3NwbGl0dGVkW2ldXTtcbiAgfVxuXG4gIGlmIChiaW5kRm9yICYmIG9yaWdpbmFsU2VsZWN0b3Iuc3RhcnRzV2l0aChiaW5kRm9yLmZvcikpIHtcbiAgICAvLyBTaW1wbGUgYXJyYXkuXG4gICAgaWYgKCFiaW5kRm9yLmtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlW2JpbmRGb3JLZXldO1xuICAgIH1cbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLlxuICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldW2JpbmRGb3Iua2V5XSAhPT0gYmluZEZvcktleSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gc2VsZWN0UHJvcGVydHkodmFsdWVbaV0sIG9yaWdpbmFsU2VsZWN0b3IucmVwbGFjZShiaW5kRm9yLmZvciArICcuJywgJycpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvb2xlYW4uXG4gIGlmIChzZWxlY3RvclswXSA9PT0gJyEnICYmIHNlbGVjdG9yWzFdID09PSAnIScpIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuICBpZiAoc2VsZWN0b3JbMF0gPT09ICchJykge1xuICAgIHJldHVybiAhdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxubW9kdWxlLmV4cG9ydHMuc2VsZWN0UHJvcGVydHkgPSBzZWxlY3RQcm9wZXJ0eTtcblxuZnVuY3Rpb24gY2xlYXJPYmplY3Qob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBkZWxldGUgb2JqW2tleV07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzLmNsZWFyT2JqZWN0ID0gY2xlYXJPYmplY3Q7XG5cbi8qKlxuICogSGVscGVyIHRvIGNvbXBvc2Ugb2JqZWN0IG9mIGhhbmRsZXJzLCBtZXJnaW5nIGZ1bmN0aW9ucyBoYW5kbGluZyBzYW1lIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZUhhbmRsZXJzKCkge1xuICB2YXIgYWN0aW9uTmFtZTtcbiAgdmFyIGk7XG4gIHZhciBpbnB1dEhhbmRsZXJzID0gYXJndW1lbnRzO1xuICB2YXIgb3V0cHV0SGFuZGxlcnM7XG5cbiAgb3V0cHV0SGFuZGxlcnMgPSB7fTtcbiAgZm9yIChpID0gMDsgaSA8IGlucHV0SGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGFjdGlvbk5hbWUgaW4gaW5wdXRIYW5kbGVyc1tpXSkge1xuICAgICAgaWYgKGFjdGlvbk5hbWUgaW4gb3V0cHV0SGFuZGxlcnMpIHtcbiAgICAgICAgLy8gSW5pdGlhbCBjb21wb3NlL21lcmdlIGZ1bmN0aW9ucyBpbnRvIGFycmF5cy5cbiAgICAgICAgaWYgKG91dHB1dEhhbmRsZXJzW2FjdGlvbk5hbWVdLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgIG91dHB1dEhhbmRsZXJzW2FjdGlvbk5hbWVdLnB1c2goaW5wdXRIYW5kbGVyc1tpXVthY3Rpb25OYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0SGFuZGxlcnNbYWN0aW9uTmFtZV0gPSBbb3V0cHV0SGFuZGxlcnNbYWN0aW9uTmFtZV0sIGlucHV0SGFuZGxlcnNbaV1bYWN0aW9uTmFtZV1dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXRIYW5kbGVyc1thY3Rpb25OYW1lXSA9IGlucHV0SGFuZGxlcnNbaV1bYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcG9zZSBmdW5jdGlvbnMgc3BlY2lmaWVkIHZpYSBhcnJheS5cbiAgZm9yIChhY3Rpb25OYW1lIGluIG91dHB1dEhhbmRsZXJzKSB7XG4gICAgaWYgKG91dHB1dEhhbmRsZXJzW2FjdGlvbk5hbWVdLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgb3V0cHV0SGFuZGxlcnNbYWN0aW9uTmFtZV0gPSBjb21wb3NlRnVuY3Rpb25zLmFwcGx5KHRoaXMsIG91dHB1dEhhbmRsZXJzW2FjdGlvbk5hbWVdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0SGFuZGxlcnM7XG59XG5tb2R1bGUuZXhwb3J0cy5jb21wb3NlSGFuZGxlcnMgPSBjb21wb3NlSGFuZGxlcnM7XG5cbmZ1bmN0aW9uIGNvbXBvc2VGdW5jdGlvbnMoKSB7XG4gIHZhciBmdW5jdGlvbnMgPSBhcmd1bWVudHM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZnVuY3Rpb25zW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMuY29tcG9zZUZ1bmN0aW9ucyA9IGNvbXBvc2VGdW5jdGlvbnM7XG5cbnZhciBOT19XQVRDSF9UT0tFTlMgPSBbJ3x8JywgJyYmJywgJyE9JywgJyE9PScsICc9PScsICc9PT0nXTtcbmZ1bmN0aW9uIHBhcnNlS2V5c1RvV2F0Y2goa2V5cywgc3RyLCBpc0JpbmRJdGVtKSB7XG4gIHZhciBpO1xuICB2YXIgdG9rZW5zO1xuICB0b2tlbnMgPSBzdHIuc3BsaXQoL1xccysvKTtcbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChOT19XQVRDSF9UT0tFTlMuaW5kZXhPZih0b2tlbnNbaV0pID09PSAtMSAmJiAhdG9rZW5zW2ldLnN0YXJ0c1dpdGgoXCInXCIpICYmIGtleXMuaW5kZXhPZih0b2tlbnNbaV0pID09PSAtMSkge1xuICAgICAgaWYgKGlzQmluZEl0ZW0gJiYgdG9rZW5zW2ldID09PSAnaXRlbScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBrZXlzLnB1c2gocGFyc2VLZXlUb1dhdGNoKHRva2Vuc1tpXSkpO1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMucGFyc2VLZXlzVG9XYXRjaCA9IHBhcnNlS2V5c1RvV2F0Y2g7XG5cbmZ1bmN0aW9uIHBhcnNlS2V5VG9XYXRjaChzdHIpIHtcbiAgdmFyIGRvdEluZGV4O1xuICBzdHIgPSBzdHJpcE5vdChzdHIudHJpbSgpKTtcbiAgZG90SW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIuaW5kZXhPZignLicpKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBOb3Qoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignISEnKSA9PT0gMCkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgnISEnLCAnJyk7XG4gIH0gZWxzZSBpZiAoc3RyLmluZGV4T2YoJyEnKSA9PT0gMCkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgnIScsICcnKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIENhY2hlZCBzcGxpdC5cbiAqL1xudmFyIFNQTElUX0NBQ0hFID0ge307XG5mdW5jdGlvbiBzcGxpdChzdHIsIGRlbGltaXRlcikge1xuICBpZiAoIVNQTElUX0NBQ0hFW2RlbGltaXRlcl0pIHtcbiAgICBTUExJVF9DQUNIRVtkZWxpbWl0ZXJdID0ge307XG4gIH1cbiAgaWYgKFNQTElUX0NBQ0hFW2RlbGltaXRlcl1bc3RyXSkge1xuICAgIHJldHVybiBTUExJVF9DQUNIRVtkZWxpbWl0ZXJdW3N0cl07XG4gIH1cbiAgU1BMSVRfQ0FDSEVbZGVsaW1pdGVyXVtzdHJdID0gc3RyLnNwbGl0KGRlbGltaXRlcik7XG4gIHJldHVybiBTUExJVF9DQUNIRVtkZWxpbWl0ZXJdW3N0cl07XG59XG5tb2R1bGUuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuXG5mdW5jdGlvbiBjb3B5QXJyYXkoZGVzdCwgc3JjKSB7XG4gIHZhciBpO1xuICBkZXN0Lmxlbmd0aCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXN0W2ldID0gc3JjW2ldO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cy5jb3B5QXJyYXkgPSBjb3B5QXJyYXk7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbl9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgZGlmZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciB3cmFwQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLndyYXBBcnJheTtcblxuLy8gU2luZ2xldG9uIHN0YXRlIGRlZmluaXRpb24uXG52YXIgU3RhdGUgPSB7XG4gIGluaXRpYWxTdGF0ZToge30sXG4gIG5vbkJpbmRlZFN0YXRlS2V5czogW10sXG4gIGhhbmRsZXJzOiB7fSxcbiAgY29tcHV0ZVN0YXRlOiBmdW5jdGlvbiBjb21wdXRlU3RhdGUoKSB7Lyogbm8tb3AgKi99XG59O1xuXG52YXIgU1RBVEVfVVBEQVRFX0VWRU5UID0gJ3N0YXRldXBkYXRlJztcbnZhciBUWVBFX09CSkVDVCA9ICdvYmplY3QnO1xudmFyIFdISVRFU1BBQ0VfUkVHRVggPSAvcysvO1xuXG5BRlJBTUUucmVnaXN0ZXJTdGF0ZSA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gIEFGUkFNRS51dGlscy5leHRlbmQoU3RhdGUsIGRlZmluaXRpb24pO1xufTtcblxuQUZSQU1FLnJlZ2lzdGVyU3lzdGVtKCdzdGF0ZScsIHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGtleTtcblxuICAgIHRoaXMuZGlmZiA9IHt9O1xuICAgIHRoaXMuc3RhdGUgPSBBRlJBTUUudXRpbHMuY2xvbmUoU3RhdGUuaW5pdGlhbFN0YXRlKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB0aGlzLmluaXRFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAvLyBXcmFwIGFycmF5IHRvIGRldGVjdCBkaXJ0eS5cbiAgICBmb3IgKGtleSBpbiB0aGlzLnN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZVtrZXldICYmIHRoaXMuc3RhdGVba2V5XS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVtrZXldLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICB3cmFwQXJyYXkodGhpcy5zdGF0ZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxhc3RTdGF0ZSA9IEFGUkFNRS51dGlscy5jbG9uZSh0aGlzLnN0YXRlKTtcblxuICAgIHRoaXMuZXZlbnREZXRhaWwgPSB7XG4gICAgICBsYXN0U3RhdGU6IHRoaXMubGFzdFN0YXRlLFxuICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICB9O1xuXG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIC8vIEluaXRpYWwgY29tcHV0ZS5cbiAgICAgIFN0YXRlLmNvbXB1dGVTdGF0ZShfdGhpcy5zdGF0ZSwgJ0BASU5JVCcpO1xuICAgICAgLy8gSW5pdGlhbCBkaXNwYXRjaC5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBfdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbnNbaV0ub25TdGF0ZVVwZGF0ZShfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGFjdGlvbi5cbiAgICovXG4gIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb25OYW1lLCBwYXlsb2FkKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGtleTtcbiAgICB2YXIgc3Vic2NyaXB0aW9uO1xuXG4gICAgLy8gTW9kaWZ5IHN0YXRlLlxuICAgIFN0YXRlLmhhbmRsZXJzW2FjdGlvbk5hbWVdKHRoaXMuc3RhdGUsIHBheWxvYWQpO1xuXG4gICAgLy8gUG9zdC1jb21wdXRlLlxuICAgIFN0YXRlLmNvbXB1dGVTdGF0ZSh0aGlzLnN0YXRlLCBhY3Rpb25OYW1lLCBwYXlsb2FkKTtcblxuICAgIC8vIEdldCBhIGRpZmYgdG8gb3B0aW1pemUgYmluZCB1cGRhdGVzLlxuICAgIGZvciAoa2V5IGluIHRoaXMuZGlmZikge1xuICAgICAgZGVsZXRlIHRoaXMuZGlmZltrZXldO1xuICAgIH1cbiAgICBkaWZmKHRoaXMubGFzdFN0YXRlLCB0aGlzLnN0YXRlLCB0aGlzLmRpZmYsIFN0YXRlLm5vbkJpbmRlZFN0YXRlS2V5cyk7XG5cbiAgICAvLyBOb3RpZnkgc3Vic2NyaXB0aW9ucyAvIGJpbmRlcnMuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uc1tpXS5uYW1lID09PSAnYmluZC1mb3InKSB7XG4gICAgICAgIC8vIEZvciBhcnJheXMgYW5kIGJpbmQtZm9yLCBjaGVjayBfX2RpcnR5IGZsYWcgb24gYXJyYXkgcmF0aGVyIHRoYW4gdGhlIGRpZmYuXG4gICAgICAgIGlmICghdGhpcy5zdGF0ZVt0aGlzLnN1YnNjcmlwdGlvbnNbaV0ua2V5c1RvV2F0Y2hbMF1dLl9fZGlydHkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZFVwZGF0ZSh0aGlzLnN1YnNjcmlwdGlvbnNbaV0ua2V5c1RvV2F0Y2gsIHRoaXMuZGlmZikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaV0ub25TdGF0ZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIFVuc2V0IGFycmF5IGRpcnR5LlxuICAgIGZvciAoa2V5IGluIHRoaXMuc3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlW2tleV0gJiYgdGhpcy5zdGF0ZVtrZXldLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICB0aGlzLnN0YXRlW2tleV0uX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0b3JlIGxhc3Qgc3RhdGUuXG4gICAgLy8gVE9ETzogY29weVN0YXRlIG1lc3NlcyB3aXRoIHRoZSBkaWZmLlxuICAgIHRoaXMuY29weVN0YXRlKHRoaXMubGFzdFN0YXRlLCB0aGlzLnN0YXRlKTtcblxuICAgIC8vIEVtaXQuXG4gICAgdGhpcy5ldmVudERldGFpbC5hY3Rpb24gPSBhY3Rpb25OYW1lO1xuICAgIHRoaXMuZXZlbnREZXRhaWwucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5lbC5lbWl0KFNUQVRFX1VQREFURV9FVkVOVCwgdGhpcy5ldmVudERldGFpbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3JlIGxhc3Qgc3RhdGUgdGhyb3VnaCBhIGRlZXAgZXh0ZW5kLCBidXQgbm90IGZvciBhcnJheXMuXG4gICAqL1xuICBjb3B5U3RhdGU6IGZ1bmN0aW9uIGNvcHlTdGF0ZShsYXN0U3RhdGUsIHN0YXRlLCBpc1JlY3Vyc2l2ZSkge1xuICAgIHZhciBrZXk7XG5cbiAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgLy8gRG9uJ3QgY29weSBwaWVjZXMgb2Ygc3RhdGUga2V5cyB0aGF0IGFyZSBub24tYmluZGVkIG9yIHVudHJhY2tlZC5cbiAgICAgIGlmICghaXNSZWN1cnNpdmUgJiYgU3RhdGUubm9uQmluZGVkU3RhdGVLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lc3RlZCBzdGF0ZS5cbiAgICAgIGlmIChzdGF0ZVtrZXldICYmIHN0YXRlW2tleV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gbGFzdFN0YXRlKSkge1xuICAgICAgICAgIC8vIENsb25lIG9iamVjdCBpZiBkZXN0aW5hdGlvbiBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICBsYXN0U3RhdGVba2V5XSA9IEFGUkFNRS51dGlscy5jbG9uZShzdGF0ZVtrZXldKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb3B5IHN0YXRlLlxuICAgICAgICB0aGlzLmNvcHlTdGF0ZShsYXN0U3RhdGVba2V5XSwgc3RhdGVba2V5XSwgdHJ1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IGJ5IHZhbHVlLlxuICAgICAgbGFzdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgIH1cbiAgfSxcblxuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShjb21wb25lbnQpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChjb21wb25lbnQpO1xuICB9LFxuXG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZShjb21wb25lbnQpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc3BsaWNlKHRoaXMuc3Vic2NyaXB0aW9ucy5pbmRleE9mKGNvbXBvbmVudCksIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBzdGF0ZSBjaGFuZ2VzIHdlcmUgcmVsZXZhbnQgdG8gdGhpcyBiaW5kaW5nLiBJZiBub3QsIGRvbid0IGNhbGwuXG4gICAqL1xuICBzaG91bGRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShrZXlzVG9XYXRjaCwgZGlmZikge1xuICAgIHZhciBzdGF0ZUtleTtcbiAgICBmb3IgKHN0YXRlS2V5IGluIGRpZmYpIHtcbiAgICAgIGlmIChrZXlzVG9XYXRjaC5pbmRleE9mKHN0YXRlS2V5KSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUHJveHkgZXZlbnRzIHRvIGFjdGlvbiBkaXNwYXRjaGVzIHNvIGNvbXBvbmVudHMgY2FuIGp1c3QgYnViYmxlIGFjdGlvbnMgdXAgYXMgZXZlbnRzLlxuICAgKiBIYW5kbGVycyBkZWZpbmUgd2hpY2ggYWN0aW9ucyB0aGV5IGhhbmRsZS4gR28gdGhyb3VnaCBhbGwgYW5kIGFkZCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBpbml0RXZlbnRIYW5kbGVyczogZnVuY3Rpb24gaW5pdEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgdmFyIGFjdGlvbk5hbWU7XG4gICAgdmFyIHJlZ2lzdGVyZWRBY3Rpb25zID0gW107XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmVnaXN0ZXJMaXN0ZW5lciA9IHJlZ2lzdGVyTGlzdGVuZXIuYmluZCh0aGlzKTtcblxuICAgIC8vIFVzZSBkZWNsYXJlZCBoYW5kbGVycyB0byBrbm93IHdoYXQgZXZlbnRzIHRvIGxpc3RlbiB0by5cbiAgICBmb3IgKGFjdGlvbk5hbWUgaW4gU3RhdGUuaGFuZGxlcnMpIHtcbiAgICAgIC8vIE9ubHkgbmVlZCB0byByZWdpc3RlciBvbmUgaGFuZGxlciBmb3IgZWFjaCBldmVudC5cbiAgICAgIGlmIChyZWdpc3RlcmVkQWN0aW9ucy5pbmRleE9mKGFjdGlvbk5hbWUpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyZWRBY3Rpb25zLnB1c2goYWN0aW9uTmFtZSk7XG4gICAgICByZWdpc3Rlckxpc3RlbmVyKGFjdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIoYWN0aW9uTmFtZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb25OYW1lLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIF90aGlzMi5kaXNwYXRjaChhY3Rpb25OYW1lLCBldnQuZGV0YWlsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIHRlbXBsYXRlIHRvIHN0cmluZyB3aXRoIGl0ZW0gZGF0YS5cbiAgICovXG4gIHJlbmRlclRlbXBsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQnJhY2VzLCB3aGl0ZXNwYWNlLCBvcHRpb25hbCBpdGVtIG5hbWUsIGl0ZW0ga2V5LCB3aGl0ZXNwYWNlLCBicmFjZXMuXG4gICAgdmFyIGludGVycFJlZ2V4ID0gL3t7XFxzKihcXHcqXFwuKT8oW1xcdy5dKylcXHMqfX0vZztcblxuICAgIHJldHVybiBmdW5jdGlvbiAodGVtcGxhdGUsIGRhdGEsIGFzU3RyaW5nKSB7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgc3RyO1xuXG4gICAgICBzdHIgPSB0ZW1wbGF0ZTtcblxuICAgICAgLy8gRGF0YSB3aWxsIGJlIG51bGwgaWYgaW5pdGlhbGl6ZSBwb29sIGZvciBiaW5kLWZvci51cGRhdGVJblBsYWNlLlxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgd2hpbGUgKG1hdGNoID0gaW50ZXJwUmVnZXguZXhlYyh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgPT09IFRZUEVfT0JKRUNUID8gbGliLnNlbGVjdChkYXRhLCBtYXRjaFsyXSkgfHwgJycgOiBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYXMgc3RyaW5nLlxuICAgICAgaWYgKGFzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhcyBET00uXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoc3RyKTtcbiAgICB9O1xuICB9KCksXG5cbiAgc2VsZWN0OiBsaWIuc2VsZWN0XG59KTtcblxuLyoqXG4gKiBCaW5kIGNvbXBvbmVudCBwcm9wZXJ0eSB0byBhIHZhbHVlIGluIHN0YXRlLlxuICpcbiAqIGJpbmQ9XCJnZW9tZXRyeS53aWR0aDogY2FyLndpZHRoXCJcIlxuICogYmluZF9fbWF0ZXJpYWw9XCJjb2xvcjogZW5lbXkuY29sb3I7IG9wYWNpdHk6IGVuZW15Lm9wYWNpdHlcIlxuICogYmluZF9fdmlzaWJsZT1cInBsYXllci52aXNpYmxlXCJcbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdiaW5kJywge1xuICBzY2hlbWE6IHtcbiAgICBkZWZhdWx0OiB7fSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgICAgIC8vIFBhcnNlIHN0eWxlLWxpa2Ugb2JqZWN0LlxuICAgICAgdmFyIGRhdGE7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgICAgdmFyIHBhaXI7XG5cbiAgICAgIC8vIFVzaW5nIHNldEF0dHJpYnV0ZSB3aXRoIG9iamVjdCwgbm8gbmVlZCB0byBwYXJzZS5cbiAgICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNpbmcgaW5zdGFuY2VkIElEIGFzIGNvbXBvbmVudCBuYW1lc3BhY2UgZm9yIHNpbmdsZS1wcm9wZXJ0eSBjb21wb25lbnQsXG4gICAgICAvLyBub3RoaW5nIHRvIHNlcGFyYXRlLlxuICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXJzZSBzdHlsZS1saWtlIG9iamVjdCBhcyBrZXlzIHRvIHZhbHVlcy5cbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHByb3BlcnRpZXMgPSBsaWIuc3BsaXQodmFsdWUsICc7Jyk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYWlyID0gbGliLnNwbGl0KHByb3BlcnRpZXNbaV0udHJpbSgpLCAnOicpO1xuICAgICAgICBkYXRhW3BhaXJbMF1dID0gcGFpclsxXS50cmltKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgbXVsdGlwbGU6IHRydWUsXG5cbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgYmluZEZvckVsO1xuICAgIHZhciBiaW5kRm9yTmFtZTtcbiAgICB2YXIgY29tcG9uZW50SWQ7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGtleTtcblxuICAgIHRoaXMua2V5c1RvV2F0Y2ggPSBbXTtcbiAgICB0aGlzLm9uU3RhdGVVcGRhdGUgPSB0aGlzLm9uU3RhdGVVcGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbSA9IHRoaXMuZWwuc2NlbmVFbC5zeXN0ZW1zLnN0YXRlO1xuXG4gICAgLy8gV2hldGhlciB3ZSBhcmUgYmluZGluZyBieSBuYW1lc3BhY2UgKGUuZy4sIGJpbmRfX2Zvbz1cInByb3AxOiB0cnVlXCIpLlxuICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICBjb21wb25lbnRJZCA9IGxpYi5zcGxpdCh0aGlzLmlkLCAnX18nKVswXTtcbiAgICB9XG4gICAgdGhpcy5pc05hbWVzcGFjZWRCaW5kID0gdGhpcy5pZCAmJiBjb21wb25lbnRJZCBpbiBBRlJBTUUuY29tcG9uZW50cyAmJiAhQUZSQU1FLmNvbXBvbmVudHNbY29tcG9uZW50SWRdLmlzU2luZ2xlUHJvcCB8fCBjb21wb25lbnRJZCBpbiBBRlJBTUUuc3lzdGVtcztcblxuICAgIHRoaXMubGFzdERhdGEgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZU9iaiA9IHt9O1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHN0b3JlIGFuZCByZWdpc3RlciBoYW5kbGVyIHRvIGRvIGRhdGEtYmluZGluZyB0byBjb21wb25lbnRzLlxuICAgIHRoaXMuc3lzdGVtLnN1YnNjcmliZSh0aGlzKTtcblxuICAgIHRoaXMucm9vdEVsID0gdGhpcy5lbC5jbG9zZXN0KCdbZGF0YS1iaW5kLWZvci1rZXldJyk7XG4gICAgdGhpcy5vblN0YXRlVXBkYXRlID0gdGhpcy5vblN0YXRlVXBkYXRlLmJpbmQodGhpcyk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGJpbmRGb3JFbDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIga2V5O1xuICAgIHZhciBwcm9wZXJ0eTtcblxuICAgIC8vIEluZGV4IGBrZXlzVG9XYXRjaGAgdG8gb25seSB1cGRhdGUgc3RhdGUgb24gcmVsZXZhbnQgY2hhbmdlcy5cbiAgICB0aGlzLmtleXNUb1dhdGNoLmxlbmd0aCA9IDA7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgbGliLnBhcnNlS2V5c1RvV2F0Y2godGhpcy5rZXlzVG9XYXRjaCwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIGRhdGEpIHtcbiAgICAgICAgbGliLnBhcnNlS2V5c1RvV2F0Y2godGhpcy5rZXlzVG9XYXRjaCwgZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbnkgcHJvcGVydGllcyBhcmUgcGFydCBvZiBhbiBpdGVyYXRpb24gaW4gYmluZC1mb3IuXG4gICAgYmluZEZvckVsID0gdGhpcy5lbC5jbG9zZXN0KCdbYmluZC1mb3JdJyk7XG4gICAgaWYgKGJpbmRGb3JFbCAmJiBiaW5kRm9yRWwgIT09IHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuYmluZEZvckVsID0gYmluZEZvckVsO1xuICAgICAgdGhpcy5iaW5kUm9vdEVsID0gdGhpcy5lbC5jbG9zZXN0KCdbZGF0YS1iaW5kLWZvci1rZXldJyk7XG4gICAgICB0aGlzLmJpbmRGb3IgPSB0aGlzLmJpbmRGb3JFbC5nZXRBdHRyaWJ1dGUoJ2JpbmQtZm9yJyk7XG4gICAgICB0aGlzLmJpbmRGb3JLZXkgPSB0aGlzLmJpbmRSb290RWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJpbmQtZm9yLWtleScpO1xuICAgICAgdGhpcy5rZXlzVG9XYXRjaC5wdXNoKHRoaXMuYmluZEZvci5pbik7XG4gICAgICB0aGlzLnJvb3RFbC5hZGRFdmVudExpc3RlbmVyKCdiaW5kZm9ydXBkYXRlJywgdGhpcy5vblN0YXRlVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kRm9yID0gJyc7XG4gICAgICB0aGlzLmJpbmRGb3JLZXkgPSAnJztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUuXG4gICAgdGhpcy5vblN0YXRlVXBkYXRlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzdGF0ZSB1cGRhdGUuXG4gICAqL1xuICBvblN0YXRlVXBkYXRlOiBmdW5jdGlvbiBvblN0YXRlVXBkYXRlKCkge1xuICAgIC8vIFVwZGF0ZSBjb21wb25lbnQgd2l0aCB0aGUgc3RhdGUuXG4gICAgdmFyIGhhc0tleXMgPSBmYWxzZTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBwcm9wZXJ0eU5hbWU7XG4gICAgdmFyIHN0YXRlU2VsZWN0b3I7XG4gICAgdmFyIHN0YXRlO1xuICAgIHZhciB0ZW1wTm9kZTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICBpZiAoIWVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNOYW1lc3BhY2VkQmluZCkge1xuICAgICAgbGliLmNsZWFyT2JqZWN0KHRoaXMudXBkYXRlT2JqKTtcbiAgICB9XG5cbiAgICBzdGF0ZSA9IHRoaXMuc3lzdGVtLnN0YXRlO1xuXG4gICAgLy8gVXBkYXRlIGJpbmQtZm9yLWtleSBpZiBuZWNlc3NhcnkgaWYgc2ltcGxlIGxpc3Qgb2Ygc3RyaW5ncy5cbiAgICAvLyBTb3J0IG9mIGEgaGFjay5cbiAgICBpZiAodGhpcy5iaW5kRm9yICYmIHRoaXMuYmluZEZvcktleSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmJpbmRGb3Iua2V5KSB7XG4gICAgICB0ZW1wTm9kZSA9IGVsO1xuICAgICAgd2hpbGUgKHRlbXBOb2RlLnBhcmVudE5vZGUgJiYgdGVtcE5vZGUucGFyZW50Tm9kZSAhPT0gdGhpcy5iaW5kRm9yRWwpIHtcbiAgICAgICAgaWYgKHRlbXBOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYmluZEZvcktleSA9IHBhcnNlSW50KHRlbXBOb2RlLmRhdGFzZXQuYmluZEZvcktleSwgMTApO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZS1wcm9wZXJ0eSBiaW5kLlxuICAgIGlmIChfdHlwZW9mKHRoaXMuZGF0YSkgIT09IFRZUEVfT0JKRUNUKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IGxpYi5zZWxlY3Qoc3RhdGUsIHRoaXMuZGF0YSwgdGhpcy5iaW5kRm9yLCB0aGlzLmJpbmRGb3JLZXkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1thZnJhbWUtc3RhdGUtY29tcG9uZW50XSBLZXkgXFwnJyArIHRoaXMuZGF0YSArICdcXCcgbm90IGZvdW5kIGluIHN0YXRlLicgKyAoJyAjJyArIHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdpZCcpICsgJ1snICsgdGhpcy5hdHRyTmFtZSArICddJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSAhPT0gVFlQRV9PQkpFQ1QgJiYgX3R5cGVvZih0aGlzLmxhc3REYXRhKSAhPT0gVFlQRV9PQkpFQ1QgJiYgdGhpcy5sYXN0RGF0YSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBBRlJBTUUudXRpbHMuZW50aXR5LnNldENvbXBvbmVudFByb3BlcnR5KGVsLCB0aGlzLmlkLCB2YWx1ZSk7XG4gICAgICB0aGlzLmxhc3REYXRhID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAvLyBQb2ludGVyIHRvIGEgdmFsdWUgaW4gdGhlIHN0YXRlIChlLmcuLCBgcGxheWVyLmhlYWx0aGApLlxuICAgICAgc3RhdGVTZWxlY3RvciA9IHRoaXMuZGF0YVtwcm9wZXJ0eU5hbWVdLnRyaW0oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gbGliLnNlbGVjdChzdGF0ZSwgc3RhdGVTZWxlY3RvciwgdGhpcy5iaW5kRm9yLCB0aGlzLmJpbmRGb3JLZXkpO1xuICAgICAgICBpZiAodGhpcy5iaW5kRm9yICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbYWZyYW1lLXN0YXRlLWNvbXBvbmVudF0gS2V5IFxcJycgKyBzdGF0ZVNlbGVjdG9yICsgJ1xcJyBub3QgZm91bmQgaW4gc3RhdGUuJyArICgnICMnICsgdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2lkJykgKyAnWycgKyB0aGlzLmF0dHJOYW1lICsgJ10nKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICE9PSBUWVBFX09CSkVDVCAmJiBfdHlwZW9mKHRoaXMubGFzdERhdGFbcHJvcGVydHlOYW1lXSkgIT09IFRZUEVfT0JKRUNUICYmIHRoaXMubGFzdERhdGFbcHJvcGVydHlOYW1lXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBjb21wb25lbnQgaWYgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAgICBpZiAocHJvcGVydHlOYW1lIGluIEFGUkFNRS5jb21wb25lbnRzICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5TmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVzaW5nIGRvdC1kZWxpbWl0ZWQgcHJvcGVydHkgbmFtZS5cbiAgICAgIGlmICh0aGlzLmlzTmFtZXNwYWNlZEJpbmQpIHtcbiAgICAgICAgLy8gQmF0Y2ggaWYgZG9pbmcgbmFtZXNwYWNlZCBiaW5kLlxuICAgICAgICB0aGlzLnVwZGF0ZU9ialtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBRlJBTUUudXRpbHMuZW50aXR5LnNldENvbXBvbmVudFByb3BlcnR5KGVsLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0RGF0YVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gQmF0Y2ggaWYgZG9pbmcgbmFtZXNwYWNlZCBiaW5kLlxuICAgIGZvciAoaGFzS2V5cyBpbiB0aGlzLnVwZGF0ZU9iaikge1xuICAgICAgLy8gU2VlIGlmIG9iamVjdCBpcyBlbXB0eS5cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNOYW1lc3BhY2VkQmluZCAmJiBoYXNLZXlzKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUodGhpcy5pZCwgdGhpcy51cGRhdGVPYmopO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICB0aGlzLnN5c3RlbS51bnN1YnNjcmliZSh0aGlzKTtcbiAgICBpZiAodGhpcy5iaW5kRm9yRWwpIHtcbiAgICAgIHRoaXMuYmluZEZvckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JpbmRmb3J1cGRhdGUnLCB0aGlzLm9uU3RhdGVVcGRhdGUpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogVG9nZ2xlIGNvbXBvbmVudCBhdHRhY2ggYW5kIGRldGFjaCBiYXNlZCBvbiBib29sZWFuIHZhbHVlLlxuICpcbiAqIGJpbmRfX3JheWNhc3RhYmxlPVwiaXNSYXljYXN0YWJsZVwiXCJcbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdiaW5kLXRvZ2dsZScsIHtcbiAgc2NoZW1hOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG5cbiAgbXVsdGlwbGU6IHRydWUsXG5cbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLnN5c3RlbSA9IHRoaXMuZWwuc2NlbmVFbC5zeXN0ZW1zLnN0YXRlO1xuICAgIHRoaXMua2V5c1RvV2F0Y2ggPSBbXTtcbiAgICB0aGlzLm9uU3RhdGVVcGRhdGUgPSB0aGlzLm9uU3RhdGVVcGRhdGUuYmluZCh0aGlzKTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBzdG9yZSBhbmQgcmVnaXN0ZXIgaGFuZGxlciB0byBkbyBkYXRhLWJpbmRpbmcgdG8gY29tcG9uZW50cy5cbiAgICB0aGlzLnN5c3RlbS5zdWJzY3JpYmUodGhpcyk7XG5cbiAgICB0aGlzLm9uU3RhdGVVcGRhdGUoKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmtleXNUb1dhdGNoLmxlbmd0aCA9IDA7XG4gICAgbGliLnBhcnNlS2V5c1RvV2F0Y2godGhpcy5rZXlzVG9XYXRjaCwgdGhpcy5kYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIG9uU3RhdGVVcGRhdGU6IGZ1bmN0aW9uIG9uU3RhdGVVcGRhdGUoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgc3RhdGU7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgc3RhdGUgPSB0aGlzLnN5c3RlbS5zdGF0ZTtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGxpYi5zZWxlY3Qoc3RhdGUsIHRoaXMuZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbYWZyYW1lLXN0YXRlLWNvbXBvbmVudF0gS2V5IFxcJycgKyB0aGlzLmRhdGEgKyAnXFwnIG5vdCBmb3VuZCBpbiBzdGF0ZS4nICsgKCcgIycgKyB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnaWQnKSArICdbJyArIHRoaXMuYXR0ck5hbWUgKyAnXScpKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSh0aGlzLmlkLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmlkKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdGhpcy5zeXN0ZW0udW5zdWJzY3JpYmUodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcG9zZUZ1bmN0aW9uczogbGliLmNvbXBvc2VGdW5jdGlvbnMsXG4gIGNvbXBvc2VIYW5kbGVyczogbGliLmNvbXBvc2VIYW5kbGVycyxcbiAgc2VsZWN0OiBsaWIuc2VsZWN0XG59O1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBJVEVNX1BSRUZJWF9SRSA9IC9pdGVtLi87XG52YXIgSVRFTV9TRUxFQ1RPUl9SRSA9IC9pdGVtLihcXHcrKS87XG5cbi8qKlxuICogUmVuZGVyIGFycmF5IGZyb20gc3RhdGUuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnYmluZC1mb3InLCB7XG4gIHNjaGVtYToge1xuICAgIGRlbGF5OiB7IGRlZmF1bHQ6IDAgfSxcbiAgICBmb3I6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICdpdGVtJyB9LFxuICAgIGluOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAga2V5OiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgcG9vbDogeyBkZWZhdWx0OiAwIH0sXG4gICAgdGVtcGxhdGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICB1cGRhdGVJblBsYWNlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgIC8vIFN1YnNjcmliZSB0byBzdG9yZSBhbmQgcmVnaXN0ZXIgaGFuZGxlciB0byBkbyBkYXRhLWJpbmRpbmcgdG8gY29tcG9uZW50cy5cbiAgICB0aGlzLnN5c3RlbSA9IHRoaXMuZWwuc2NlbmVFbC5zeXN0ZW1zLnN0YXRlO1xuICAgIHRoaXMub25TdGF0ZVVwZGF0ZSA9IHRoaXMub25TdGF0ZVVwZGF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5rZXlzVG9XYXRjaCA9IFtdO1xuICAgIHRoaXMucmVuZGVyZWRLZXlzID0gW107IC8vIEtleXMgdGhhdCBhcmUgY3VycmVudGx5IHJlbmRlcmVkLlxuICAgIHRoaXMuc3lzdGVtLnN1YnNjcmliZSh0aGlzKTtcblxuICAgIGlmICh0aGlzLmVsLmNoaWxkcmVuWzBdICYmIHRoaXMuZWwuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuZWwuY2hpbGRyZW5bMF0uaW5uZXJIVE1MLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5kYXRhLnRlbXBsYXRlKS5pbm5lckhUTUwudHJpbSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmRhdGEucG9vbDsgX2krKykge1xuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmdlbmVyYXRlRnJvbVRlbXBsYXRlKG51bGwsIF9pKSk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMua2V5c1RvV2F0Y2hbMF0gPSBsaWIuc3BsaXQodGhpcy5kYXRhLmluLCAnLicpWzBdO1xuICAgIHRoaXMub25TdGF0ZVVwZGF0ZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIGl0ZW1zIGFyZSBzd2FwcGVkIG91dCwgdGhlIG9sZCBvbmVzIGFyZSByZW1vdmVkLCBhbmQgbmV3IG9uZXMgYXJlIGFkZGVkLiBBbGxcbiAgICogZW50aXRpZXMgd2lsbCBiZSByZWluaXRpYWxpemVkLlxuICAgKi9cbiAgb25TdGF0ZVVwZGF0ZU5haXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjdGl2ZUtleXMgPSBbXTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICB2YXIgbGlzdDtcbiAgICAgIHZhciBrZXk7XG4gICAgICB2YXIga2V5VmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3QgPSBsaWIuc2VsZWN0KHRoaXMuc3lzdGVtLnN0YXRlLCBkYXRhLmluKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbYWZyYW1lLXN0YXRlLWNvbXBvbmVudF0gS2V5IFxcJycgKyBkYXRhLmluICsgJ1xcJyBub3QgZm91bmQgaW4gc3RhdGUuJyArICgnICMnICsgZWwuZ2V0QXR0cmlidXRlKCdpZCcpICsgJ1snICsgdGhpcy5hdHRyTmFtZSArICddJykpO1xuICAgICAgfVxuXG4gICAgICBhY3RpdmVLZXlzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsaXN0Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBsaXN0W19pMl07XG4gICAgICAgIC8vIElmIGtleSBub3QgZGVmaW5lZCwgdXNlIGluZGV4IChlLmcuLCBhcnJheSBvZiBzdHJpbmdzKS5cbiAgICAgICAgYWN0aXZlS2V5cy5wdXNoKGRhdGEua2V5ID8gaXRlbVtkYXRhLmtleV0udG9TdHJpbmcoKSA6IGl0ZW0udG9TdHJpbmcoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBpdGVtcyBieSByZW1vdmluZyBlbnRpdGllcy5cbiAgICAgIHZhciB0b1JlbW92ZUVscyA9IHRoaXMuZ2V0RWxzVG9SZW1vdmUoYWN0aXZlS2V5cywgdGhpcy5yZW5kZXJlZEtleXMpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRvUmVtb3ZlRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvUmVtb3ZlRWxzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9SZW1vdmVFbHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJJdGVtcyhsaXN0LCBhY3RpdmVLZXlzLCAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCksXG5cbiAgLyoqXG4gICAqIEFkZCBvciB1cGRhdGUgaXRlbSB3aXRoIGRlbGF5IHN1cHBvcnQuXG4gICAqL1xuICByZW5kZXJJdGVtczogZnVuY3Rpb24gcmVuZGVySXRlbXMobGlzdCwgYWN0aXZlS2V5cywgaSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBpdGVtRWw7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuXG4gICAgLy8gSWYga2V5IG5vdCBkZWZpbmVkLCB1c2UgaW5kZXggKGUuZy4sIGFycmF5IG9mIHN0cmluZ3MpLlxuICAgIGtleVZhbHVlID0gZGF0YS5rZXkgPyBpdGVtW2RhdGEua2V5XS50b1N0cmluZygpIDogaXRlbS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVuZGVyZWRLZXlzLmluZGV4T2Yoa2V5VmFsdWUpID09PSAtMSkge1xuICAgICAgLy8gQWRkLlxuICAgICAgaXRlbUVsID0gdGhpcy5nZW5lcmF0ZUZyb21UZW1wbGF0ZShpdGVtLCBpKTtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGl0ZW1FbCk7XG4gICAgICB0aGlzLnJlbmRlcmVkS2V5cy5wdXNoKGtleVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlLlxuICAgICAgaWYgKGxpc3QubGVuZ3RoICYmIGxpc3RbMF0uY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAvLyBVcGRhdGUgaW5kZXggZm9yIHNpbXBsZSBsaXN0LlxuICAgICAgICB2YXIgX2tleVZhbHVlID0gZGF0YS5rZXkgPyBpdGVtW2RhdGEua2V5XS50b1N0cmluZygpIDogaXRlbS50b1N0cmluZygpO1xuICAgICAgICBpdGVtRWwgPSBlbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1iaW5kLWZvci12YWx1ZT1cIicgKyBfa2V5VmFsdWUgKyAnXCJdJyk7XG4gICAgICAgIGl0ZW1FbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYmluZC1mb3Ita2V5JywgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmluZEZvcktleSA9IHRoaXMuZ2V0QmluZEZvcktleShpdGVtLCBpKTtcbiAgICAgICAgaXRlbUVsID0gZWwucXVlcnlTZWxlY3RvcignW2RhdGEtYmluZC1mb3Ita2V5PVwiJyArIGJpbmRGb3JLZXkgKyAnXCJdJyk7XG4gICAgICB9XG4gICAgICBpdGVtRWwuZW1pdCgnYmluZGZvcnVwZGF0ZScsIGl0ZW0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoIWxpc3RbaSArIDFdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0YS5kZWxheSkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlckl0ZW1zKGxpc3QsIGFjdGl2ZUtleXMsIGkgKyAxKTtcbiAgICAgIH0sIHRoaXMuZGF0YS5kZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVySXRlbXMobGlzdCwgYWN0aXZlS2V5cywgaSArIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiBpdGVtcyBhcmUgc3dhcHBlZCBvdXQsIHRoaXMgYWxnb3JpdGhtIHdpbGwgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMgaW4tcGxhY2UgdXNpbmdcbiAgICogYmluZC1pdGVtLlxuICAgKi9cbiAgb25TdGF0ZVVwZGF0ZUluUGxhY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aXZlS2V5cyA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgIHZhciBsaXN0O1xuICAgICAgdmFyIGtleTtcbiAgICAgIHZhciBrZXlWYWx1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdCA9IGxpYi5zZWxlY3QodGhpcy5zeXN0ZW0uc3RhdGUsIGRhdGEuaW4pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1thZnJhbWUtc3RhdGUtY29tcG9uZW50XSBLZXkgXFwnJyArIGRhdGEuaW4gKyAnXFwnIG5vdCBmb3VuZCBpbiBzdGF0ZS4nICsgKCcgIycgKyBlbC5nZXRBdHRyaWJ1dGUoJ2lkJykgKyAnWycgKyB0aGlzLmF0dHJOYW1lICsgJ10nKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBrZXlzIHRoYXQgc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICAgIGFjdGl2ZUtleXMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxpc3QubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGxpc3RbX2kzXTtcbiAgICAgICAga2V5VmFsdWUgPSBkYXRhLmtleSA/IGl0ZW1bZGF0YS5rZXldLnRvU3RyaW5nKCkgOiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIGFjdGl2ZUtleXMucHVzaChrZXlWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBpdGVtcyBieSBwb29saW5nLiBEbyBiZWZvcmUgYWRkaW5nLlxuICAgICAgdmFyIHRvUmVtb3ZlRWxzID0gdGhpcy5nZXRFbHNUb1JlbW92ZShhY3RpdmVLZXlzLCB0aGlzLnJlbmRlcmVkS2V5cyk7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB0b1JlbW92ZUVscy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHRvUmVtb3ZlRWxzW19pNF0ub2JqZWN0M0QudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0b1JlbW92ZUVsc1tfaTRdLnNldEF0dHJpYnV0ZSgnZGF0YS1iaW5kLWZvci1hY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgdG9SZW1vdmVFbHNbX2k0XS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYmluZC1mb3Ita2V5Jyk7XG4gICAgICAgIHRvUmVtb3ZlRWxzW19pNF0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWJpbmQtZm9yLXZhbHVlJyk7XG4gICAgICAgIHRvUmVtb3ZlRWxzW19pNF0uZW1pdCgnYmluZGZvcmRlYWN0aXZhdGUnLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHRvUmVtb3ZlRWxzW19pNF0ucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVuZGVySXRlbXNJblBsYWNlKGxpc3QsIGFjdGl2ZUtleXMsIDApO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSxcblxuICAvKipcbiAgICogQWRkLCB0YWtlb3Zlciwgb3IgdXBkYXRlIGl0ZW0gd2l0aCBkZWxheSBzdXBwb3J0LlxuICAgKi9cbiAgcmVuZGVySXRlbXNJblBsYWNlOiBmdW5jdGlvbiByZW5kZXJJdGVtc0luUGxhY2UobGlzdCwgYWN0aXZlS2V5cywgaSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaXRlbUVsO1xuXG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBiaW5kRm9yS2V5ID0gdGhpcy5nZXRCaW5kRm9yS2V5KGl0ZW0sIGkpO1xuICAgIHZhciBrZXlWYWx1ZSA9IGRhdGEua2V5ID8gaXRlbVtkYXRhLmtleV0udG9TdHJpbmcoKSA6IGl0ZW0udG9TdHJpbmcoKTtcblxuICAgIC8vIEFkZCBpdGVtLlxuICAgIGlmICh0aGlzLnJlbmRlcmVkS2V5cy5pbmRleE9mKGtleVZhbHVlKSA9PT0gLTEpIHtcbiAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvcignOnNjb3BlID4gW2RhdGEtYmluZC1mb3ItYWN0aXZlPVwiZmFsc2VcIl0nKSkge1xuICAgICAgICAvLyBObyBpdGVtcyBhdmFpbGFibGUgaW4gcG9vbC4gR2VuZXJhdGUgbmV3IGVudGl0eS5cbiAgICAgICAgdmFyIF9pdGVtRWwgPSB0aGlzLmdlbmVyYXRlRnJvbVRlbXBsYXRlKGl0ZW0sIGkpO1xuICAgICAgICBfaXRlbUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfaXRlbUVsLmVtaXQoJ2JpbmRmb3J1cGRhdGVpbnBsYWNlJywgaXRlbSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoX2l0ZW1FbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUYWtlIG92ZXIgaW5hY3RpdmUgaXRlbS5cbiAgICAgICAgaXRlbUVsID0gZWwucXVlcnlTZWxlY3RvcignW2RhdGEtYmluZC1mb3ItYWN0aXZlPVwiZmFsc2VcIl0nKTtcbiAgICAgICAgaXRlbUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1iaW5kLWZvci1rZXknLCBiaW5kRm9yS2V5KTtcbiAgICAgICAgaXRlbUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1iaW5kLWZvci12YWx1ZScsIGtleVZhbHVlKTtcbiAgICAgICAgaXRlbUVsLm9iamVjdDNELnZpc2libGUgPSB0cnVlO1xuICAgICAgICBpdGVtRWwucGxheSgpO1xuICAgICAgICBpdGVtRWwuc2V0QXR0cmlidXRlKCdkYXRhLWJpbmQtZm9yLWFjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgIGl0ZW1FbC5lbWl0KCdiaW5kZm9ydXBkYXRlaW5wbGFjZScsIGl0ZW0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyZWRLZXlzLnB1c2goa2V5VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlS2V5cy5pbmRleE9mKGtleVZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIC8vIFVwZGF0ZSBpdGVtLlxuICAgICAgaWYgKGxpc3QubGVuZ3RoICYmIGxpc3RbMF0uY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAvLyBVcGRhdGUgaW5kZXggZm9yIHNpbXBsZSBsaXN0LlxuICAgICAgICBpdGVtRWwgPSBlbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1iaW5kLWZvci12YWx1ZT1cIicgKyBrZXlWYWx1ZSArICdcIl0nKTtcbiAgICAgICAgaXRlbUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1iaW5kLWZvci1rZXknLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1FbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWJpbmQtZm9yLWtleT1cIicgKyBiaW5kRm9yS2V5ICsgJ1wiXScpO1xuICAgICAgfVxuICAgICAgaXRlbUVsLmVtaXQoJ2JpbmRmb3J1cGRhdGVpbnBsYWNlJywgaXRlbSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICghbGlzdFtpICsgMV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLmRlbGF5KSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlbmRlckl0ZW1zSW5QbGFjZShsaXN0LCBhY3RpdmVLZXlzLCBpICsgMSk7XG4gICAgICB9LCB0aGlzLmRhdGEuZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlckl0ZW1zSW5QbGFjZShsaXN0LCBhY3RpdmVLZXlzLCBpICsgMSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBlbnRpdHkgZnJvbSB0ZW1wbGF0ZS5cbiAgICovXG4gIGdlbmVyYXRlRnJvbVRlbXBsYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZUZyb21UZW1wbGF0ZShpdGVtLCBpKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuc3lzdGVtLnJlbmRlclRlbXBsYXRlKHRoaXMudGVtcGxhdGUsIGl0ZW0pKTtcbiAgICB2YXIgbmV3RWwgPSB0aGlzLmVsLmNoaWxkcmVuW3RoaXMuZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV07O1xuXG4gICAgLy8gRnJvbSBwb29sLnRydWVcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIG5ld0VsLnNldEF0dHJpYnV0ZSgnZGF0YS1iaW5kLWZvci1rZXknLCAnJyk7XG4gICAgICBuZXdFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYmluZC1mb3ItYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICByZXR1cm4gbmV3RWw7XG4gICAgfVxuXG4gICAgdmFyIGJpbmRGb3JLZXkgPSB0aGlzLmdldEJpbmRGb3JLZXkoaXRlbSwgaSk7XG4gICAgbmV3RWwuc2V0QXR0cmlidXRlKCdkYXRhLWJpbmQtZm9yLWtleScsIGJpbmRGb3JLZXkpO1xuICAgIGlmICghZGF0YS5rZXkpIHtcbiAgICAgIG5ld0VsLnNldEF0dHJpYnV0ZSgnZGF0YS1iaW5kLWZvci12YWx1ZScsIGl0ZW0pO1xuICAgIH1cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgcG9vbGVkIGFuZCBub24tcG9vbGVkIGVudGl0aWVzIGlmIHVwZGF0aW5nIGluIHBsYWNlLlxuICAgIG5ld0VsLnNldEF0dHJpYnV0ZSgnZGF0YS1iaW5kLWZvci1hY3RpdmUnLCAndHJ1ZScpO1xuICAgIHJldHVybiBuZXdFbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGVudGl0aWVzIG1hcmtlZCBmb3IgcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gYWN0aXZlS2V5cyAtIExpc3Qgb2Yga2V5IHZhbHVlcyB0aGF0IHNob3VsZCBiZSBhY3RpdmUuXG4gICAqIEBwYXJhbSB7YXJyYXl9IHJlbmRlcmVkS2V5cyAtIExpc3Qgb2Yga2V5IHZhbHVlcyBjdXJyZW50bHkgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRFbHNUb1JlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3RpdmVLZXlzLCByZW5kZXJlZEtleXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgdG9SZW1vdmUubGVuZ3RoID0gMDtcbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGVsLmNoaWxkcmVuLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgaWYgKGVsLmNoaWxkcmVuW19pNV0udGFnTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBkYXRhLmtleSA/IGVsLmNoaWxkcmVuW19pNV0uZ2V0QXR0cmlidXRlKCdkYXRhLWJpbmQtZm9yLWtleScpIDogZWwuY2hpbGRyZW5bX2k1XS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmluZC1mb3ItdmFsdWUnKTtcbiAgICAgICAgaWYgKGFjdGl2ZUtleXMuaW5kZXhPZihrZXkpID09PSAtMSAmJiByZW5kZXJlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIHRvUmVtb3ZlLnB1c2goZWwuY2hpbGRyZW5bX2k1XSk7XG4gICAgICAgICAgcmVuZGVyZWRLZXlzLnNwbGljZShyZW5kZXJlZEtleXMuaW5kZXhPZihrZXkpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRvUmVtb3ZlO1xuICAgIH07XG4gIH0oKSxcblxuICAvKipcbiAgICogR2V0IHZhbHVlIHRvIHVzZSBhcyB0aGUgZGF0YS1iaW5kLWZvci1rZXkuXG4gICAqIEZvciBpdGVtcywgd2lsbCBiZSB2YWx1ZSBzcGVjaWZpZWQgYnkgYGJpbmQtZm9yLmtleWAuXG4gICAqIEZvciBzaW1wbGUgbGlzdCwgd2lsbCBiZSB0aGUgaW5kZXguXG4gICAqL1xuICBnZXRCaW5kRm9yS2V5OiBmdW5jdGlvbiBnZXRCaW5kRm9yS2V5KGl0ZW0sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmtleSA/IGl0ZW1bdGhpcy5kYXRhLmtleV0udG9TdHJpbmcoKSA6IGkudG9TdHJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIG9uU3RhdGVVcGRhdGU6IGZ1bmN0aW9uIG9uU3RhdGVVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS51cGRhdGVJblBsYWNlKSB7XG4gICAgICB0aGlzLm9uU3RhdGVVcGRhdGVJblBsYWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25TdGF0ZVVwZGF0ZU5haXZlKCk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBIYW5kbGUgcGFyc2luZyBhbmQgdXBkYXRlIGluLXBsYWNlIHVwZGF0ZXMgdW5kZXIgYmluZC1mb3IuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnYmluZC1pdGVtJywge1xuICBzY2hlbWE6IHtcbiAgICB0eXBlOiAnc3RyaW5nJ1xuICB9LFxuXG4gIG11bHRpcGxlOiB0cnVlLFxuXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5pdGVtRGF0YSA9IG51bGw7XG4gICAgdGhpcy5rZXlzVG9XYXRjaCA9IFtdO1xuICAgIHRoaXMucHJldlZhbHVlcyA9IHt9O1xuXG4gICAgLy8gTGlzdGVuIHRvIHJvb3QgaXRlbSBmb3IgZXZlbnRzLlxuICAgIHZhciByb290RWwgPSB0aGlzLnJvb3RFbCA9IHRoaXMuZWwuY2xvc2VzdCgnW2RhdGEtYmluZC1mb3Ita2V5XScpO1xuICAgIGlmICghcm9vdEVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQtaXRlbSBjb21wb25lbnQgbXVzdCBiZSBhdHRhY2hlZCB0byBlbnRpdHkgdW5kZXIgYSBiaW5kLWZvciBpdGVtLicpO1xuICAgIH1cbiAgICByb290RWwuYWRkRXZlbnRMaXN0ZW5lcignYmluZGZvcnVwZGF0ZWlucGxhY2UnLCB0aGlzLnVwZGF0ZUluUGxhY2UuYmluZCh0aGlzKSk7XG4gICAgcm9vdEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JpbmRmb3JkZWFjdGl2YXRlJywgdGhpcy5kZWFjdGl2YXRlLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMuc3RhdGUuc3Vic2NyaWJlKHRoaXMpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMucGFyc2VTZWxlY3RvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSdW4gd2l0aCBiaW5kLWZvciB0ZWxscyB0byB2aWEgZXZlbnQgYGJpbmRmb3J1cGRhdGVpbnBsYWNlYCwgcGFzc2luZyBpdGVtIGRhdGEuXG4gICAqL1xuICB1cGRhdGVJblBsYWNlOiBmdW5jdGlvbiB1cGRhdGVJblBsYWNlKGV2dCkge1xuICAgIHZhciBwcm9wZXJ0eU1hcCA9IHRoaXMucHJvcGVydHlNYXA7XG5cbiAgICBpZiAodGhpcy5yb290RWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJpbmQtZm9yLWFjdGl2ZScpID09PSAnZmFsc2UnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2dCkge1xuICAgICAgdGhpcy5pdGVtRGF0YSA9IGV2dC5kZXRhaWw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydHlNYXApIHtcbiAgICAgIC8vIEdldCB2YWx1ZSBmcm9tIGl0ZW0uXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnNlbGVjdCh0aGlzLml0ZW1EYXRhLCBwcm9wZXJ0eU1hcFtwcm9wZXJ0eV0pO1xuXG4gICAgICAvLyBEaWZmIGFnYWluc3QgcHJldmlvdXMgdmFsdWUuXG4gICAgICBpZiAodmFsdWUgPT09IHRoaXMucHJldlZhbHVlc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZS5cbiAgICAgIEFGUkFNRS51dGlscy5lbnRpdHkuc2V0Q29tcG9uZW50UHJvcGVydHkodGhpcy5lbCwgcHJvcGVydHksIHZhbHVlKTtcblxuICAgICAgdGhpcy5wcmV2VmFsdWVzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBvblN0YXRlVXBkYXRlOiBmdW5jdGlvbiBvblN0YXRlVXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlSW5QbGFjZSgpO1xuICB9LFxuXG4gIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGl0ZW1EYXRhLCBzZWxlY3Rvcikge1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGlmIChzZWxlY3Rvci5pbmRleE9mKCc9JykgIT09IC0xKSB7XG4gICAgICAvLyBJbnRlcnBvbGF0ZS5cbiAgICAgIHZhciBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKElURU1fU0VMRUNUT1JfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhbHVlID0gbGliLnNlbGVjdChpdGVtRGF0YSwgbWF0Y2hbMF0ucmVwbGFjZShJVEVNX1BSRUZJWF9SRSwgJycpKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKElURU1fU0VMRUNUT1JfUkUsIFwiJ1wiICsgdmFsdWUgKyBcIidcIik7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbGliLnNlbGVjdCh0aGlzLmVsLnNjZW5lRWwuc3lzdGVtcy5zdGF0ZS5zdGF0ZSwgc2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgdmFsdWUgZnJvbSBpdGVtLlxuICAgICAgdmFsdWUgPSBzZWxlY3RvciA9PT0gJ2l0ZW0nID8gaXRlbURhdGEgLy8gU2ltcGxlIGxpc3QuXG4gICAgICA6IGxpYi5zZWxlY3QoaXRlbURhdGEsIHNlbGVjdG9yLnJlcGxhY2UoSVRFTV9QUkVGSVhfUkUsICcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIGRlYWN0aXZhdGU6IGZ1bmN0aW9uIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5wcmV2VmFsdWVzID0ge307XG4gIH0sXG5cbiAgcGFyc2VTZWxlY3RvcjogZnVuY3Rpb24gcGFyc2VTZWxlY3RvcigpIHtcbiAgICB2YXIgcHJvcGVydHlNYXAgPSB0aGlzLnByb3BlcnR5TWFwID0ge307XG4gICAgdGhpcy5rZXlzVG9XYXRjaC5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBsaWIuc3BsaXQodGhpcy5pZCwgJ19fJylbMF07XG5cbiAgICAvLyBEaWZmZXJlbnQgcGFyc2luZyBmb3IgbXVsdGktcHJvcCBjb21wb25lbnRzLlxuICAgIGlmIChjb21wb25lbnROYW1lIGluIEFGUkFNRS5jb21wb25lbnRzICYmICFBRlJBTUUuY29tcG9uZW50c1tjb21wb25lbnROYW1lXS5pc1NpbmdsZVByb3ApIHtcbiAgICAgIHZhciBwcm9wZXJ0eVNwbGl0TGlzdCA9IGxpYi5zcGxpdCh0aGlzLmRhdGEsICc7Jyk7XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBwcm9wZXJ0eVNwbGl0TGlzdC5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eVNwbGl0ID0gbGliLnNwbGl0KHByb3BlcnR5U3BsaXRMaXN0W19pNl0sICc6Jyk7XG4gICAgICAgIHByb3BlcnR5TWFwW3RoaXMuaWQgKyAnLicgKyBwcm9wZXJ0eVNwbGl0WzBdLnRyaW0oKV0gPSBwcm9wZXJ0eVNwbGl0WzFdLnRyaW0oKTtcbiAgICAgICAgbGliLnBhcnNlS2V5c1RvV2F0Y2godGhpcy5rZXlzVG9XYXRjaCwgcHJvcGVydHlTcGxpdFsxXS50cmltKCksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb3BlcnR5TWFwW3RoaXMuaWRdID0gdGhpcy5kYXRhO1xuICAgIGxpYi5wYXJzZUtleXNUb1dhdGNoKHRoaXMua2V5c1RvV2F0Y2gsIHRoaXMuZGF0YSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBvYmplY3RzIHdpdGggYWJpbGl0eSB0byBpZ25vcmUga2V5cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYSAtIEZpcnN0IG9iamVjdCB0byBjb21wYXJlIChlLmcuLCBvbGREYXRhKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBiIC0gU2Vjb25kIG9iamVjdCB0byBjb21wYXJlIChlLmcuLCBuZXdEYXRhKS5cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKiAgIERpZmZlcmVuY2Ugb2JqZWN0IHdoZXJlIHNldCBvZiBrZXlzIG5vdGUgd2hpY2ggdmFsdWVzIHdlcmUgbm90IGVxdWFsLCBhbmQgdmFsdWVzIGFyZVxuICogICBgYmAncyB2YWx1ZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgdGFyZ2V0T2JqZWN0LCBpZ25vcmVLZXlzKSB7XG4gICAgdmFyIGFWYWw7XG4gICAgdmFyIGJWYWw7XG4gICAgdmFyIGJLZXk7XG4gICAgdmFyIGRpZmY7XG4gICAgdmFyIGtleTtcbiAgICB2YXIgaTtcbiAgICB2YXIgaXNDb21wYXJpbmdPYmplY3RzO1xuXG4gICAgZGlmZiA9IHRhcmdldE9iamVjdCB8fCB7fTtcblxuICAgIC8vIENvbGxlY3QgQSBrZXlzLlxuICAgIGtleXMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGtleSBpbiBhKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoIWIpIHtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgQiBrZXlzLlxuICAgIGZvciAoYktleSBpbiBiKSB7XG4gICAgICBpZiAoa2V5cy5pbmRleE9mKGJLZXkpID09PSAtMSkge1xuICAgICAgICBrZXlzLnB1c2goYktleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIC8vIElnbm9yZSBzcGVjaWZpZWQga2V5cy5cbiAgICAgIGlmIChpZ25vcmVLZXlzICYmIGlnbm9yZUtleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYVZhbCA9IGFba2V5XTtcbiAgICAgIGJWYWwgPSBiW2tleV07XG4gICAgICBpc0NvbXBhcmluZ09iamVjdHMgPSBhVmFsICYmIGJWYWwgJiYgYVZhbC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIGJWYWwuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICAgIGlmIChpc0NvbXBhcmluZ09iamVjdHMgJiYgIUFGUkFNRS51dGlscy5kZWVwRXF1YWwoYVZhbCwgYlZhbCkgfHwgIWlzQ29tcGFyaW5nT2JqZWN0cyAmJiBhVmFsICE9PSBiVmFsKSB7XG4gICAgICAgIGRpZmZba2V5XSA9IGJWYWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmO1xuICB9O1xufSgpO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGZucyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnXTtcblxuZnVuY3Rpb24gd3JhcEFycmF5KGFycikge1xuICB2YXIgaTtcbiAgaWYgKGFyci5fX3dyYXBwZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIG1ha2VDYWxsRGlydHkoYXJyLCBmbnNbaV0pO1xuICB9XG4gIGFyci5fX3dyYXBwZWQgPSB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMud3JhcEFycmF5ID0gd3JhcEFycmF5O1xuXG5mdW5jdGlvbiBtYWtlQ2FsbERpcnR5KGFyciwgZm4pIHtcbiAgdmFyIG9yaWdpbmFsRm4gPSBhcnJbZm5dO1xuICBhcnJbZm5dID0gZnVuY3Rpb24gKCkge1xuICAgIG9yaWdpbmFsRm4uYXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuICAgIGFyci5fX2RpcnR5ID0gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FmcmFtZS1zdGF0ZS1jb21wb25lbnQvZGlzdC9hZnJhbWUtc3RhdGUtY29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFsIEFGUkFNRSAqL1xudmFyIEtFWUJPQVJEUyA9IHJlcXVpcmUoJy4va2V5Ym9hcmRzJyk7XG5cbmlmICh0eXBlb2YgQUZSQU1FID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBhdHRlbXB0ZWQgdG8gcmVnaXN0ZXIgYmVmb3JlIEFGUkFNRSB3YXMgYXZhaWxhYmxlLicpO1xufVxuXG52YXIgRm9udEZhY3RvcnMgPSB7XG4gIHJvYm90bzogMTcsXG4gIGFpbGVyb25zZW1pYm9sZDogMjAsXG4gIGRlamF2dTogMjAuNSxcbiAgZXhvMmJvbGQ6IDIwLFxuICBleG8yc2VtaWJvbGQ6IDIwLjMsXG4gIGtlbHNvbnNhbnM6IDIyLjgsXG4gIG1vbm9pZDogMTkuNSxcbiAgbW96aWxsYXZyOiA5LjUsXG4gIHNvdXJjZWNvZGVwcm86IDIwLjNcbn07XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc3VwZXIta2V5Ym9hcmQnLCB7XG4gIHNjaGVtYToge1xuICAgIGFsaWduOiB7ZGVmYXVsdDogJ2xlZnQnLCBvbmVPZjogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddfSxcbiAgICBibGlua2luZ1NwZWVkOiB7dHlwZTogJ2ludCcsIGRlZmF1bHQ6IDQwMH0sXG4gICAgZmlsdGVyczoge3R5cGU6ICdhcnJheSd9LFxuICAgIC8vIHJvYm90byBhaWxlcm9uc2VtaWJvbGQgZGVqYXZ1IGV4bzJib2xkIGV4bzJzZW1pYm9sZCBrZWxzb25zYW5zIG1vbm9pZCBzb3VyY2Vjb2RlcHJvXG4gICAgZm9udDoge2RlZmF1bHQ6ICdhaWxlcm9uc2VtaWJvbGQnfSxcbiAgICBoYW5kOiB7dHlwZTogJ3NlbGVjdG9yJ30sXG4gICAgaW1hZ2VQYXRoOiB7ZGVmYXVsdDogJy4nfSxcbiAgICBpbmplY3RUb1JheWNhc3Rlck9iamVjdHM6IHtkZWZhdWx0OiB0cnVlfSxcbiAgICBpbnB1dENvbG9yOiB7dHlwZTogJ2NvbG9yJywgZGVmYXVsdDogJyM2Njk5ZmYnfSxcbiAgICBpbnRlcnZhbDoge3R5cGU6ICdpbnQnLCBkZWZhdWx0OiA1MH0sXG4gICAga2V5QmdDb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHQ6ICcjMDAwJ30sXG4gICAga2V5Q29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0OiAnIzY2OTlmZid9LFxuICAgIGtleUhvdmVyQ29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0OiAnIzFBNDA3Rid9LFxuICAgIGtleVByZXNzQ29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0OiAnIzUyOTBGNid9LFxuICAgIGxhYmVsOiB7dHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnfSxcbiAgICBsYWJlbENvbG9yOiB7dHlwZTogJ2NvbG9yJywgZGVmYXVsdDogJyNhYWEnfSxcbiAgICBtYXhMZW5ndGg6IHt0eXBlOiAnaW50JywgZGVmYXVsdDogMH0sXG4gICAgbW9kZWw6IHtkZWZhdWx0OiAnYmFzaWMnfSxcbiAgICBzaG93OiB7ZGVmYXVsdDogdHJ1ZX0sXG4gICAgdmFsdWU6IHt0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJyd9LFxuICAgIHdpZHRoOiB7ZGVmYXVsdDogMC44fVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbGljay5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmNoYW5nZUV2ZW50RGV0YWlsID0ge307XG4gICAgdGhpcy50ZXh0SW5wdXRPYmplY3QgPSB7fTtcblxuICAgIHRoaXMua2V5cyA9IG51bGw7XG4gICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXlIb3ZlciA9IG51bGw7XG4gICAgdGhpcy5wcmV2Q2hlY2tUaW1lID0gbnVsbDtcbiAgICB0aGlzLnNoaWZ0ID0gZmFsc2U7XG5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdGhpcy5kYXRhLnZhbHVlO1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLnZhbHVlO1xuXG4gICAgdGhpcy51c2VyRmlsdGVyRnVuYyA9IG51bGw7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gMDtcblxuICAgIC8vIENyZWF0ZSBrZXlib2FyZCBpbWFnZS5cbiAgICB0aGlzLmtiSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICB0aGlzLmtiSW1nLmNsYXNzTGlzdC5hZGQoJ2tleWJvYXJkUmF5Y2FzdGFibGUnKTtcbiAgICB0aGlzLmtiSW1nLmNsYXNzTGlzdC5hZGQoJ3N1cGVyS2V5Ym9hcmRJbWFnZScpO1xuICAgIHRoaXMua2JJbWcuYWRkRXZlbnRMaXN0ZW5lcigncmF5Y2FzdGVyLWludGVyc2VjdGVkJywgdGhpcy5ob3Zlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmtiSW1nLmFkZEV2ZW50TGlzdGVuZXIoJ3JheWNhc3Rlci1pbnRlcnNlY3RlZC1jbGVhcmVkJywgdGhpcy5ibHVyLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5rYkltZyk7XG5cbiAgICAvLyBDcmVhdGUgbGFiZWwuXG4gICAgdGhpcy5sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EtZW50aXR5Jyk7XG4gICAgdGhpcy5sYWJlbC5zZXRBdHRyaWJ1dGUoJ3RleHQnLCB7XG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBmb250OiB0aGlzLmRhdGEuZm9udCxcbiAgICAgIGJhc2VsaW5lOiAnYm90dG9tJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDQwLFxuICAgICAgdmFsdWU6IHRoaXMuZGF0YS5sYWJlbCxcbiAgICAgIGNvbG9yOiB0aGlzLmRhdGEubGFiZWxDb2xvcixcbiAgICAgIHdpZHRoOiB0aGlzLmRhdGEud2lkdGgsXG4gICAgICB3cmFwQ291bnQ6IDMwfSk7XG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsKTtcblxuICAgIC8vIENyZWF0ZSBpbnB1dC5cbiAgICB0aGlzLnRleHRJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EtZW50aXR5Jyk7XG4gICAgdGhpcy50ZXh0SW5wdXQuc2V0QXR0cmlidXRlKCd0ZXh0Jywge1xuICAgICAgYWxpZ246IHRoaXMuZGF0YS5hbGlnbixcbiAgICAgIGZvbnQ6IHRoaXMuZGF0YS5mb250LFxuICAgICAgdmFsdWU6IHRoaXMuZGF0YS52YWx1ZSxcbiAgICAgIGNvbG9yOiB0aGlzLmRhdGEuaW5wdXRDb2xvcixcbiAgICAgIHdpZHRoOiB0aGlzLmRhdGEud2lkdGgsXG4gICAgICB3cmFwQ291bnQ6IDIwXG4gICAgfSk7XG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLnRleHRJbnB1dCk7XG5cbiAgICB0aGlzLmN1cnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EtZW50aXR5Jyk7XG4gICAgdGhpcy5jdXJzb3Iub2JqZWN0M0QucG9zaXRpb24uc2V0KDAsIDAsIDAuMDAxKTtcbiAgICB0aGlzLmN1cnNvci5zZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywge3NoYWRlcjogJ2ZsYXQnLCBjb2xvcjogdGhpcy5kYXRhLmlucHV0Q29sb3J9KTtcbiAgICB0aGlzLnRleHRJbnB1dC5hcHBlbmRDaGlsZCh0aGlzLmN1cnNvcik7XG4gICAgdGhpcy5jdXJzb3JVcGRhdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleUJnQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgICB0aGlzLmtleUhvdmVyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgICB0aGlzLmtleVByZXNzQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoZXYua2V5ID09PSAndCcpIHtcbiAgICAgICAgdmFyIHNzID0gJyc7XG4gICAgICAgIHZhciBzID0gJ2FiY2RlZmdoaWprbG1vcHFyc3R1dlFXSUVVVEdBU0RMSUdLQlhBQ1FXRVRMMTAyMzk0Njc2NDU3JztcbiAgICAgICAgdmFyIGwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBzcyArPSBzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHMubGVuZ3RoKV07XG4gICAgICAgIHNlbGYuZWwuc2V0QXR0cmlidXRlKCdzdXBlci1rZXlib2FyZCcsIHt2YWx1ZTogc3N9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Nob3cnLCB0aGlzLm9wZW4uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmhhbmQgPSBudWxsO1xuICAgIHRoaXMuaGFuZExpc3RlbmVyc1NldCA9IGZhbHNlO1xuICAgIHRoaXMucmF5Y2FzdGVyID0gbnVsbDtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChvbGREYXRhKSB7XG4gICAgdmFyIGtiZGF0YSA9IEtFWUJPQVJEU1t0aGlzLmRhdGEubW9kZWxdO1xuICAgIHZhciB3ID0gdGhpcy5kYXRhLndpZHRoO1xuICAgIHZhciBoID0gdGhpcy5kYXRhLndpZHRoIC8gMjtcbiAgICB2YXIgdzIgPSB3IC8gMjtcbiAgICB2YXIgaDIgPSBoIC8gMjtcblxuICAgIGlmIChrYmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcignc3VwZXIta2V5Ym9hcmQgRVJST1I6IG1vZGVsIFwiJyArIHRoaXMuZGF0YS5tb2RlbCArICdcIiB1bmRlZmluZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvbGREYXRhIHx8IHRoaXMuZGVmYXVsdFZhbHVlICE9PSBvbGREYXRhLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5yYXdWYWx1ZSA9IHRoaXMuZGF0YS52YWx1ZTtcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLnZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVUZXh0SW5wdXQodGhpcy5maWx0ZXIodGhpcy5kYXRhLnZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dElucHV0KHRoaXMuZmlsdGVyKHRoaXMucmF3VmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLndpZHRoICE9PSBvbGREYXRhLndpZHRoIHx8XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgIT09IG9sZERhdGEuaGVpZ2h0IHx8XG4gICAgICAgIHRoaXMuZGF0YS5rZXlDb2xvciAhPT0gb2xkRGF0YS5rZXlDb2xvcikge1xuICAgICAgdGhpcy5rYkltZy5zZXRBdHRyaWJ1dGUoJ2dlb21ldHJ5Jywge3ByaW1pdGl2ZTogJ3BsYW5lJywgd2lkdGg6IHcsIGhlaWdodDogaH0pO1xuICAgICAgdGhpcy5rYkltZy5zZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywge1xuICAgICAgICBzaGFkZXI6ICdmbGF0JyxcbiAgICAgICAgc3JjOiB0aGlzLmRhdGEuaW1hZ2VQYXRoICsgJy8nICsga2JkYXRhLmltZyxcbiAgICAgICAgY29sb3I6IHRoaXMuZGF0YS5rZXlDb2xvcixcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGEubGFiZWwgIT09IG9sZERhdGEubGFiZWwgfHxcbiAgICAgICAgdGhpcy5kYXRhLmxhYmVsQ29sb3IgIT09IG9sZERhdGEubGFiZWxDb2xvciB8fFxuICAgICAgICB0aGlzLmRhdGEud2lkdGggIT09IG9sZERhdGEud2lkdGgpIHtcbiAgICAgIHRoaXMubGFiZWwuc2V0QXR0cmlidXRlKCd0ZXh0Jywge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmxhYmVsLCBjb2xvcjogdGhpcy5kYXRhLmxhYmVsQ29sb3IsIHdpZHRoOiB0aGlzLmRhdGEud2lkdGh9KTtcbiAgICAgIHRoaXMubGFiZWwub2JqZWN0M0QucG9zaXRpb24uc2V0KDAsIDAuMyAqIHcsIC0wLjAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLndpZHRoICE9PSBvbGREYXRhLndpZHRoIHx8XG4gICAgICAgIHRoaXMuZGF0YS5rZXlCZ0NvbG9yICE9PSBvbGREYXRhLmtleUJnQ29sb3IpIHtcbiAgICAgIHRoaXMuaW5pdEtleUNvbG9yUGxhbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXR4ID0gdGhpcy5kYXRhLmFsaWduICE9PSAnY2VudGVyJyA/IGtiZGF0YS5pbnB1dE9mZnNldFggKiB3IDogMDtcbiAgICBpZiAodGhpcy5kYXRhLmFsaWduID09PSAncmlnaHQnKSB7IGlucHV0eCAqPSAtMTsgfVxuXG4gICAgaWYgKHRoaXMuZGF0YS5mb250ICE9PSBvbGREYXRhLmZvbnQgfHxcbiAgICAgICAgdGhpcy5kYXRhLmlucHV0Q29sb3IgIT09IG9sZERhdGEuaW5wdXRDb2xvciB8fFxuICAgICAgICB0aGlzLmRhdGEud2lkdGggIT09IG9sZERhdGEud2lkdGggfHxcbiAgICAgICAgdGhpcy5kYXRhLmFsaWduICE9PSBvbGREYXRhLmFsaWduKSB7XG4gICAgICB0aGlzLnRleHRJbnB1dC5zZXRBdHRyaWJ1dGUoJ3RleHQnLCB7XG4gICAgICAgIGZvbnQ6IHRoaXMuZGF0YS5mb250LFxuICAgICAgICBjb2xvcjogdGhpcy5kYXRhLmlucHV0Q29sb3IsXG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICB3cmFwQ291bnQ6IGtiZGF0YS53cmFwQ291bnQsXG4gICAgICAgIGFsaWduOiB0aGlzLmRhdGEuYWxpZ25cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNvbWUgaGFjayB3aGVyZSB0aGUgaW5wdXRSZWN0IGlzIHN0b3JlZCBpbiB0aGUgSW5zZXJ0IGtleS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtiZGF0YS5sYXlvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZGF0YSA9IGtiZGF0YS5sYXlvdXRbaV07XG4gICAgICBpZiAoa2RhdGEua2V5ID09PSAnSW5zZXJ0Jykge1xuICAgICAgICB0aGlzLmlucHV0UmVjdCA9IGtkYXRhO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dElucHV0Lm9iamVjdDNELnBvc2l0aW9uLnNldChcbiAgICAgIGlucHV0eCxcbiAgICAgICh3IC8gNCkgLSAodGhpcy5pbnB1dFJlY3QueSArIHRoaXMuaW5wdXRSZWN0LmggLyAyKSAqIHcgLyAyICsga2JkYXRhLmlucHV0T2Zmc2V0WSAqIHcsXG4gICAgICAwLjAwMlxuICAgICk7XG5cbiAgICBpZiAodGhpcy5kYXRhLndpZHRoICE9PSBvbGREYXRhLndpZHRoKSB7XG4gICAgICB0aGlzLmN1cnNvci5zZXRBdHRyaWJ1dGUoJ2dlb21ldHJ5Jywge1xuICAgICAgICBwcmltaXRpdmU6ICdwbGFuZScsIHdpZHRoOiAwLjAzICogdywgaGVpZ2h0OiAwLjAxICogd30pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQ3Vyc29yUG9zaXRpb24oKTtcbiAgICB0aGlzLnNldHVwSGFuZCgpO1xuXG4gICAgdGhpcy5rZXlCZ0NvbG9yLnNldCh0aGlzLmRhdGEua2V5QmdDb2xvcik7XG4gICAgdGhpcy5rZXlIb3ZlckNvbG9yLnNldCh0aGlzLmRhdGEua2V5SG92ZXJDb2xvcik7XG4gICAgdGhpcy5rZXlQcmVzc0NvbG9yLnNldCh0aGlzLmRhdGEua2V5UHJlc3NDb2xvcik7XG5cbiAgICBpZiAodGhpcy5kYXRhLnNob3cpIHtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdmFyIGludGVyc2VjdGlvbjtcblxuICAgIGlmICh0aGlzLnByZXZDaGVja1RpbWUgJiYgKHRpbWUgLSB0aGlzLnByZXZDaGVja1RpbWUgPCB0aGlzLmRhdGEuaW50ZXJ2YWwpKSB7IHJldHVybjsgfVxuICAgIGlmICghdGhpcy5wcmV2Q2hlY2tUaW1lKSB7XG4gICAgICB0aGlzLnByZXZDaGVja1RpbWUgPSB0aW1lO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmF5Y2FzdGVyKSB7IHJldHVybjsgfVxuICAgIGlmICghdGhpcy5mb2N1c2VkKSB7IHJldHVybjsgfVxuXG4gICAgaW50ZXJzZWN0aW9uID0gdGhpcy5yYXljYXN0ZXIuZ2V0SW50ZXJzZWN0aW9uKHRoaXMua2JJbWcpO1xuICAgIGlmICghaW50ZXJzZWN0aW9uKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHV2ID0gaW50ZXJzZWN0aW9uLnV2O1xuICAgIHZhciBrZXlzID0gS0VZQk9BUkRTW3RoaXMuZGF0YS5tb2RlbF0ubGF5b3V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgICAgaWYgKHV2LnggPiBrLnggJiYgdXYueCA8IGsueCArIGsudyAmJiAoMS4wIC0gdXYueSkgPiBrLnkgJiYgKDEuMCAtIHV2LnkpIDwgay55ICsgay5oKSB7XG4gICAgICAgIGlmICh0aGlzLmtleUhvdmVyICE9PSBrKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIGtleSBob3Zlci5cbiAgICAgICAgICB0aGlzLmtleUhvdmVyID0gaztcbiAgICAgICAgICB0aGlzLnVwZGF0ZUtleUNvbG9yUGxhbmUodGhpcy5rZXlIb3Zlci5rZXksIHRoaXMua2V5SG92ZXJDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHBsYXk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY3Vyc29yVXBkYXRlZCkgeyByZXR1cm47IH1cbiAgICB0aGlzLnN0YXJ0QmxpbmtpbmcoKTtcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcEJsaW5raW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBwbGFuZSBmb3IgdmlzdWFsIGZlZWRiYWNrIHdoZW4gYSBrZXkgaXMgaG92ZXJlZCBvciBjbGlja2VkXG4gICAqL1xuICBpbml0S2V5Q29sb3JQbGFuZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXlDb2xvclBsYW5lID0gdGhpcy5rZXlDb2xvclBsYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICBrZXlDb2xvclBsYW5lLmNsYXNzTGlzdC5hZGQoJ3N1cGVyS2V5Ym9hcmRLZXlDb2xvclBsYW5lJyk7XG4gICAga2V5Q29sb3JQbGFuZS5vYmplY3QzRC5wb3NpdGlvbi56ID0gMC4wMDE7XG4gICAga2V5Q29sb3JQbGFuZS5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XG4gICAga2V5Q29sb3JQbGFuZS5zZXRBdHRyaWJ1dGUoJ2dlb21ldHJ5Jywge3ByaW1pdGl2ZTogJ3BsYW5lJ30pO1xuICAgIGtleUNvbG9yUGxhbmUuc2V0QXR0cmlidXRlKCdtYXRlcmlhbCcsIHtzaGFkZXI6ICdmbGF0JywgY29sb3I6IHRoaXMuZGF0YS5rZXlCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZX0pO1xuICAgIGtleUNvbG9yUGxhbmUuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9uZW50aW5pdGlhbGl6ZWQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmRldGFpbC5uYW1lICE9PSAnbWF0ZXJpYWwnKSB7IHJldHVybjsgfVxuICAgICAgdGhpcy5nZXRPYmplY3QzRCgnbWVzaCcpLm1hdGVyaWFsLmJsZW5kaW5nID0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZztcbiAgICB9KTtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGtleUNvbG9yUGxhbmUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGtleSBjb2xvciBwbGFuZSB0byBhcHByb3ByaWF0ZSBwb3NpdGlvbiwgc2NhbGUsIGFuZCBjaGFuZ2UgY29sb3IuXG4gICAqL1xuICB1cGRhdGVLZXlDb2xvclBsYW5lOiBmdW5jdGlvbiAoa2V5LCBjb2xvcikge1xuICAgIHZhciBrYmRhdGEgPSBLRVlCT0FSRFNbdGhpcy5kYXRhLm1vZGVsXTtcbiAgICB2YXIga2V5Q29sb3JQbGFuZSA9IHRoaXMua2V5Q29sb3JQbGFuZTtcblxuICAgIC8vIFVuc2V0LlxuICAgIGlmICgha2V5KSB7XG4gICAgICBrZXlDb2xvclBsYW5lLm9iamVjdDNELnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtiZGF0YS5sYXlvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZGF0YSA9IGtiZGF0YS5sYXlvdXRbaV07XG4gICAgICBpZiAoa2RhdGEua2V5ICE9PSBrZXkpIHsgY29udGludWU7IH1cbiAgICAgIHZhciB3ID0gdGhpcy5kYXRhLndpZHRoO1xuICAgICAgdmFyIGggPSB0aGlzLmRhdGEud2lkdGggLyAyO1xuICAgICAgdmFyIHcyID0gdyAvIDI7XG4gICAgICB2YXIgaDIgPSBoIC8gMjtcbiAgICAgIHZhciBrZXl3ID0ga2RhdGEudyAqIHc7XG4gICAgICB2YXIga2V5aCA9IGtkYXRhLmggKiBoO1xuICAgICAgLy8gU2l6ZS5cbiAgICAgIGtleUNvbG9yUGxhbmUub2JqZWN0M0Quc2NhbGUueCA9IGtleXc7XG4gICAgICBrZXlDb2xvclBsYW5lLm9iamVjdDNELnNjYWxlLnkgPSBrZXloO1xuICAgICAgLy8gUG9zaXRpb24uXG4gICAgICBrZXlDb2xvclBsYW5lLm9iamVjdDNELnBvc2l0aW9uLnggPSBrZGF0YS54ICogdyAtIHcyICsga2V5dyAvIDI7XG4gICAgICBrZXlDb2xvclBsYW5lLm9iamVjdDNELnBvc2l0aW9uLnkgPSAoMSAtIGtkYXRhLnkpICogaCAtIGgyIC0ga2V5aCAvIDI7XG4gICAgICAvLyBDb2xvci5cbiAgICAgIGtleUNvbG9yUGxhbmUuZ2V0T2JqZWN0M0QoJ21lc2gnKS5tYXRlcmlhbC5jb2xvci5jb3B5KGNvbG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBrZXlDb2xvclBsYW5lLm9iamVjdDNELnZpc2libGUgPSB0cnVlO1xuICB9LFxuXG4gIHNldHVwSGFuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmhhbmQgJiYgdGhpcy5oYW5kLm93blJheWNhc3Rlcikge1xuICAgICAgdGhpcy5oYW5kLnJlbW92ZUF0dHJpYnV0ZSgncmF5Y2FzdGVyJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuaGFuZCkge1xuICAgICAgdGhpcy5oYW5kID0gdGhpcy5kYXRhLmhhbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoW1xuICAgICAgICAnW2N1cnNvcl0nLFxuICAgICAgICAnW3ZpdmUtY29udHJvbHNdJyxcbiAgICAgICAgJ1t0cmFja2VkLWNvbnRyb2xzXScsXG4gICAgICAgICdbb2N1bHVzLXRvdWNoLWNvbnRyb2xzXScsXG4gICAgICAgICdbd2luZG93cy1tb3Rpb24tY29udHJvbHNdJyxcbiAgICAgICAgJ1toYW5kLWNvbnRyb2xzXScsXG4gICAgICAgICdbZGF5ZHJlYW0tY29udHJvbHNdIFtjdXJzb3JdID4gW3JheWNhc3Rlcl0nXG4gICAgICBdLmpvaW4oJywnKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhbmQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3N1cGVyLWtleWJvYXJkOiBubyBjb250cm9sbGVyIGZvdW5kLiBBZGQgPGEtZW50aXR5PiB3aXRoIGNvbnRyb2xsZXIgb3Igc3BlY2lmeSB3aXRoIHN1cGVyLWtleWJvYXJkPVwiaGFuZDogI3NlbGVjdG9yVG9Db250cm9sbGVyXCIuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5oYW5kLmhhc0xvYWRlZCkge1xuICAgICAgICB0aGlzLmhhbmQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgdGhpcy5zZXR1cEhhbmQuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByYXljYXN0ZXIgPSB0aGlzLmhhbmQuY29tcG9uZW50c1sncmF5Y2FzdGVyJ107XG4gICAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICAgIGlmICghcmF5Y2FzdGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZC5vd25SYXljYXN0ZXIgPSB0cnVlO1xuICAgICAgICBwYXJhbXMuc2hvd0xpbmUgPSB0aGlzLmRhdGEuc2hvdztcbiAgICAgICAgcGFyYW1zLmVuYWJsZWQgPSB0aGlzLmRhdGEuc2hvdztcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5pbmplY3RUb1JheWNhc3Rlck9iamVjdHMpIHtcbiAgICAgICAgICBwYXJhbXMub2JqZWN0cyA9ICcua2V5Ym9hcmRSYXljYXN0YWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kLnNldEF0dHJpYnV0ZSgncmF5Y2FzdGVyJywgcGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZC5vd25SYXljYXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5pbmplY3RUb1JheWNhc3Rlck9iamVjdHMpIHtcbiAgICAgICAgICB2YXIgb2JqcyA9IHJheWNhc3Rlci5kYXRhLm9iamVjdHMuc3BsaXQoJywnKTtcbiAgICAgICAgICBpZiAob2Jqcy5pbmRleE9mKCcua2V5Ym9hcmRSYXljYXN0YWJsZScpID09PSAtMSkge1xuICAgICAgICAgICAgb2Jqcy5wdXNoKCcua2V5Ym9hcmRSYXljYXN0YWJsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbXMub2JqZWN0cyA9IG9ianMuam9pbignLCcpLnJlcGxhY2UoL14sLywgJycpO1xuICAgICAgICAgIHRoaXMuaGFuZC5zZXRBdHRyaWJ1dGUoJ3JheWNhc3RlcicsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXljYXN0ZXIgPSB0aGlzLmhhbmQuY29tcG9uZW50cy5yYXljYXN0ZXI7XG4gICAgfVxuICB9LFxuXG4gIGZpbHRlcjogZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgPT09ICcnKSB7IHJldHVybiAnJzsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5kYXRhLmZpbHRlcnNbaV0pIHtcbiAgICAgICAgY2FzZSAnY3VzdG9tJzoge1xuICAgICAgICAgIGlmICh0aGlzLnVzZXJGaWx0ZXJGdW5jKSBzdHIgPSB0aGlzLnVzZXJGaWx0ZXJGdW5jKHN0cik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYWxsdXBwZXInOiB7XG4gICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYWxsbG93ZXInOiB7XG4gICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGl0bGUnOiB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnN1YnN0cigxKTsgfSkuam9pbignICcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ251bWJlcnMnOiB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICFpc05hTihwYXJzZUludChjKSkgfHwgYyA9PT0gJy4nOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmaXJzdCc6IHtcbiAgICAgICAgICBzdHIgPSBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHIoMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndHJpbSc6IHtcbiAgICAgICAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGEubWF4TGVuZ3RoID4gMCA/IHN0ci5zdWJzdHIoMCwgdGhpcy5kYXRhLm1heExlbmd0aCkgOiBzdHI7XG4gIH0sXG5cbiAgY2xpY2s6IGZ1bmN0aW9uIChldikge1xuICAgIGlmICghdGhpcy5rZXlIb3ZlcikgeyByZXR1cm47IH1cblxuICAgIHN3aXRjaCAodGhpcy5rZXlIb3Zlci5rZXkpIHtcbiAgICAgIGNhc2UgJ0VudGVyJzoge1xuICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0luc2VydCc6IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSAnRGVsZXRlJzoge1xuICAgICAgICB0aGlzLnJhd1ZhbHVlID0gdGhpcy5yYXdWYWx1ZS5zdWJzdHIoMCwgdGhpcy5yYXdWYWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5maWx0ZXIodGhpcy5yYXdWYWx1ZSk7XG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdzdXBlci1rZXlib2FyZCcsICd2YWx1ZScsIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0SW5wdXQobmV3VmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZUV2ZW50RGV0YWlsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuZWwuZW1pdCgnc3VwZXJrZXlib2FyZGNoYW5nZScsIHRoaXMuY2hhbmdlRXZlbnREZXRhaWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1NoaWZ0Jzoge1xuICAgICAgICB0aGlzLnNoaWZ0ID0gIXRoaXMuc2hpZnQ7XG4gICAgICAgIHRoaXMua2V5SG92ZXIuZWwuc2V0QXR0cmlidXRlKCdtYXRlcmlhbCcsICdjb2xvcicsXG4gICAgICAgICAgdGhpcy5zaGlmdCA/IHRoaXMuZGF0YS5rZXlIb3ZlckNvbG9yIDogdGhpcy5kYXRhLmtleUJnQ29sb3JcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdFc2NhcGUnOiB7XG4gICAgICAgIHRoaXMuZGlzbWlzcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5tYXhMZW5ndGggPiAwICYmIHRoaXMucmF3VmFsdWUubGVuZ3RoID4gdGhpcy5kYXRhLm1heExlbmd0aCkgeyBicmVhazsgfVxuICAgICAgICB0aGlzLnJhd1ZhbHVlICs9IHRoaXMuc2hpZnQgPyB0aGlzLmtleUhvdmVyLmtleS50b1VwcGVyQ2FzZSgpIDogdGhpcy5rZXlIb3Zlci5rZXk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuZmlsdGVyKHRoaXMucmF3VmFsdWUpO1xuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnc3VwZXIta2V5Ym9hcmQnLCAndmFsdWUnLCBuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dElucHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VFdmVudERldGFpbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmVsLmVtaXQoJ3N1cGVya2V5Ym9hcmRjaGFuZ2UnLCB0aGlzLmNoYW5nZUV2ZW50RGV0YWlsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVLZXlDb2xvclBsYW5lKHRoaXMua2V5SG92ZXIua2V5LCB0aGlzLmtleVByZXNzQ29sb3IpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYudXBkYXRlS2V5Q29sb3JQbGFuZShzZWxmLmtleUhvdmVyLmtleSwgc2VsZi5rZXlIb3ZlckNvbG9yKTtcbiAgICB9LCAxMDApO1xuICAgIHRoaXMudXBkYXRlQ3Vyc29yUG9zaXRpb24oKTtcbiAgfSxcblxuICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5vYmplY3QzRC52aXNpYmxlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5oYW5kICYmIHRoaXMuaGFuZC5vd25SYXljYXN0ZXIpIHtcbiAgICAgIHRoaXMuaGFuZC5zZXRBdHRyaWJ1dGUoJ3JheWNhc3RlcicsIHtzaG93TGluZTogdHJ1ZSwgZW5hYmxlZDogdHJ1ZX0pO1xuICAgIH1cbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwub2JqZWN0M0QudmlzaWJsZSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmhhbmQgJiYgdGhpcy5oYW5kLm93blJheWNhc3Rlcikge1xuICAgICAgdGhpcy5oYW5kLnNldEF0dHJpYnV0ZSgncmF5Y2FzdGVyJywge3Nob3dMaW5lOiBmYWxzZSwgZW5hYmxlZDogZmFsc2V9KTtcbiAgICB9XG4gIH0sXG5cbiAgYWNjZXB0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaGFuZCAmJiB0aGlzLmhhbmQub3duUmF5Y2FzdGVyKSB7XG4gICAgICB0aGlzLmhhbmQuc2V0QXR0cmlidXRlKCdyYXljYXN0ZXInLCB7c2hvd0xpbmU6IGZhbHNlLCBlbmFibGVkOiBmYWxzZX0pO1xuICAgIH1cbiAgICB0aGlzLmVsLmVtaXQoJ3N1cGVya2V5Ym9hcmRpbnB1dCcsIHt2YWx1ZTogdGhpcy5kYXRhLnZhbHVlfSk7XG4gICAgdGhpcy5kYXRhLnNob3cgPSBmYWxzZTtcbiAgfSxcblxuICBkaXNtaXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kYXRhLnZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgdGhpcy51cGRhdGVUZXh0SW5wdXQoKTtcbiAgICB0aGlzLmVsLm9iamVjdDNELnZpc2libGUgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5oYW5kICYmIHRoaXMuaGFuZC5vd25SYXljYXN0ZXIpIHtcbiAgICAgIHRoaXMuaGFuZC5zZXRBdHRyaWJ1dGUoJ3JheWNhc3RlcicsIHtzaG93TGluZTogZmFsc2UsIGVuYWJsZWQ6IGZhbHNlfSk7XG4gICAgfVxuICAgIHRoaXMuZWwuZW1pdCgnc3VwZXJrZXlib2FyZGRpc21pc3MnKTtcbiAgICB0aGlzLmRhdGEuc2hvdyA9IGZhbHNlO1xuICB9LFxuXG4gIGJsdXI6IGZ1bmN0aW9uIChldikge1xuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmtleUhvdmVyICYmIHRoaXMua2V5SG92ZXIua2V5ICE9PSAnU2hpZnQnKSB7XG4gICAgICB0aGlzLnVwZGF0ZUtleUNvbG9yUGxhbmUodGhpcy5rZXlIb3Zlci5rZXksIHRoaXMua2V5QmdDb2xvcik7XG4gICAgfVxuICAgIHRoaXMua2V5SG92ZXIgPSBudWxsO1xuICB9LFxuXG4gIGhvdmVyOiBmdW5jdGlvbiAoZXYpIHtcbiAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICB9LFxuXG4gIHN0YXJ0Qmxpbmtpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0b3BCbGlua2luZygpO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmJsaW5rLmJpbmQodGhpcyksIHRoaXMuZGF0YS5ibGlua2luZ1NwZWVkKTtcbiAgfSxcblxuICBzdG9wQmxpbmtpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IDA7XG4gIH0sXG5cbiAgYmxpbms6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnNvci5vYmplY3QzRC52aXNpYmxlID0gIXRoaXMuY3Vyc29yLm9iamVjdDNELnZpc2libGU7XG4gIH0sXG5cbiAgc2V0Q3VzdG9tRmlsdGVyOiBmdW5jdGlvbiAoZikge1xuICAgIHRoaXMudXNlckZpbHRlckZ1bmMgPSBmO1xuICB9LFxuXG4gIGFkZEN1c3RvbU1vZGVsOiBmdW5jdGlvbiAobmFtZSwgbW9kZWwpIHtcbiAgICBpZiAoIW5hbWUpIHsgcmV0dXJuOyB9XG4gICAgS0VZQk9BUkRTW25hbWVdID0gbW9kZWw7XG4gIH0sXG5cbiAgdXBkYXRlQ3Vyc29yUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9udCA9IHRoaXMudGV4dElucHV0LmNvbXBvbmVudHMudGV4dC5jdXJyZW50Rm9udDtcbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuY3Vyc29yLm9iamVjdDNELnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGVDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICBzZWxmLnN0YXJ0QmxpbmtpbmcoKTtcbiAgICAgIH0sIDcwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHcgPSB0aGlzLmRhdGEud2lkdGg7XG4gICAgdmFyIGtiZGF0YSA9IEtFWUJPQVJEU1t0aGlzLmRhdGEubW9kZWxdO1xuICAgIHZhciBwb3N5ID0gLXRoaXMuaW5wdXRSZWN0LmggLyAyICogdyAvIDIuNCArIGtiZGF0YS5pbnB1dE9mZnNldFkgKiB3O1xuICAgIHZhciByYXRpbyA9IHRoaXMuZGF0YS53aWR0aCAvIHRoaXMudGV4dElucHV0LmNvbXBvbmVudHMudGV4dC5kYXRhLndyYXBDb3VudDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgZm9udEZhY3RvciA9IEZvbnRGYWN0b3JzW3RoaXMudGV4dElucHV0LmNvbXBvbmVudHMudGV4dC5kYXRhLmZvbnRdO1xuICAgIGlmIChmb250RmFjdG9yID09PSB1bmRlZmluZWQpIHsgZm9udEZhY3RvciA9IDIwOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFyID0gZmluZEZvbnRDaGFyKGZvbnQuY2hhcnMsIHRoaXMuZGF0YS52YWx1ZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgIHBvcyArPSBjaGFyLndpZHRoICsgY2hhci54YWR2YW5jZSAqIChjaGFyLmlkID09PSAzMiA/IDIgOiAxKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YS5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHBvcyA9IHBvcyAqIHJhdGlvICogZm9udEZhY3RvciAqIDAuMDAxMSAvIDIuMCArIDAuMDIgKiB3O1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHBvcyA9IHBvcyAqIHJhdGlvICogZm9udEZhY3RvciAqIDAuMDAxMSArIDAuMDIgKiB3O1xuICAgICAgcG9zIC09IHcgLyAyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICBwb3MgPSAtcG9zICogcmF0aW8gKiBmb250RmFjdG9yICogMC4wMDExIC0gMC4wMiAqIHc7XG4gICAgICBwb3MgKz0gdyAvIDI7XG4gICAgfVxuICAgIHRoaXMuY3Vyc29yLm9iamVjdDNELnBvc2l0aW9uLnNldChwb3MsIHBvc3ksIDAuMDAxKTtcbiAgICB0aGlzLmN1cnNvclVwZGF0ZWQgPSB0cnVlO1xuICB9LFxuXG4gIHVwZGF0ZVRleHRJbnB1dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy50ZXh0SW5wdXRPYmplY3QudmFsdWUgPSB2YWx1ZSB8fCB0aGlzLmRhdGEudmFsdWU7XG4gICAgdGhpcy50ZXh0SW5wdXQuc2V0QXR0cmlidXRlKCd0ZXh0JywgdGhpcy50ZXh0SW5wdXRPYmplY3QpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZmluZEZvbnRDaGFyIChjaGFycywgY29kZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNoYXJzW2ldLmlkID09PSBjb2RlKSB7IHJldHVybiBjaGFyc1tpXTsgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FmcmFtZS1zdXBlci1rZXlib2FyZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImlmICh0eXBlb2YgQUZSQU1FID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBhdHRlbXB0ZWQgdG8gcmVnaXN0ZXIgYmVmb3JlIEFGUkFNRSB3YXMgYXZhaWxhYmxlLicpO1xufVxuXG4vLyBTaW5nbGUgYXVkaW8gY29udGV4dC5cbnZhciBjb250ZXh0O1xuXG4vKipcbiAqIEF1ZGlvIHZpc3VhbGl6ZXIgc3lzdGVtIGZvciBBLUZyYW1lLiBTaGFyZSBBbmFseXNlck5vZGVzIGJldHdlZW4gY29tcG9uZW50cyB0aGF0IHNoYXJlIHRoZVxuICogdGhlIGBzcmNgLlxuICovXG5BRlJBTUUucmVnaXN0ZXJTeXN0ZW0oJ2F1ZGlvYW5hbHlzZXInLCB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuYWx5c2VycyA9IHt9O1xuICB9LFxuXG4gIGdldE9yQ3JlYXRlQW5hbHlzZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCFjb250ZXh0KSB7IGNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7IH1cbiAgICB2YXIgYW5hbHlzZXJzID0gdGhpcy5hbmFseXNlcnM7XG4gICAgdmFyIGFuYWx5c2VyID0gY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgIHZhciBhdWRpb0VsID0gZGF0YS5zcmM7XG4gICAgdmFyIHNyYyA9IGF1ZGlvRWwuZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuICAgIGlmIChhbmFseXNlcnNbc3JjXSkgeyByZXR1cm4gYW5hbHlzZXJzW3NyY107IH1cblxuICAgIHZhciBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShhdWRpb0VsKVxuICAgIHNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICBhbmFseXNlci5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IGRhdGEuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuICAgIGFuYWx5c2VyLmZmdFNpemUgPSBkYXRhLmZmdFNpemU7XG5cbiAgICAvLyBTdG9yZS5cbiAgICBhbmFseXNlcnNbc3JjXSA9IGFuYWx5c2VyO1xuICAgIHJldHVybiBhbmFseXNlcnNbc3JjXTtcbiAgfVxufSk7XG5cbi8qKlxuICogQXVkaW8gdmlzdWFsaXplciBjb21wb25lbnQgZm9yIEEtRnJhbWUgdXNpbmcgQW5hbHlzZXJOb2RlLlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2F1ZGlvYW5hbHlzZXInLCB7XG4gIHNjaGVtYToge1xuICAgIGVuYWJsZUJlYXREZXRlY3Rpb246IHtkZWZhdWx0OiB0cnVlfSxcbiAgICBlbmFibGVMZXZlbHM6IHtkZWZhdWx0OiB0cnVlfSxcbiAgICBlbmFibGVXYXZlZm9ybToge2RlZmF1bHQ6IHRydWV9LFxuICAgIGVuYWJsZVZvbHVtZToge2RlZmF1bHQ6IHRydWV9LFxuICAgIGZmdFNpemU6IHtkZWZhdWx0OiAyMDQ4fSxcbiAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IHtkZWZhdWx0OiAwLjh9LFxuICAgIHNyYzoge3R5cGU6ICdzZWxlY3Rvcid9LFxuICAgIHVuaXF1ZToge2RlZmF1bHQ6IGZhbHNlfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuYWx5c2VyID0gbnVsbDtcbiAgICB0aGlzLmxldmVscyA9IG51bGw7XG4gICAgdGhpcy53YXZlZm9ybSA9IG51bGw7XG4gICAgdGhpcy52b2x1bWUgPSAwO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3lzdGVtID0gdGhpcy5zeXN0ZW07XG5cbiAgICBpZiAoIWRhdGEuc3JjKSB7IHJldHVybjsgfVxuXG4gICAgLy8gR2V0IG9yIGNyZWF0ZSBBbmFseXNlck5vZGUuXG4gICAgaWYgKGRhdGEudW5pcXVlKSB7XG4gICAgICBpbml0KHN5c3RlbS5jcmVhdGVBbmFseXNlcihkYXRhKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQoc3lzdGVtLmdldE9yQ3JlYXRlQW5hbHlzZXIoZGF0YSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQgKGFuYWx5c2VyKSB7XG4gICAgICBzZWxmLmFuYWx5c2VyID0gYW5hbHlzZXI7XG4gICAgICBzZWxmLmxldmVscyA9IG5ldyBVaW50OEFycmF5KHNlbGYuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgICAgc2VsZi53YXZlZm9ybSA9IG5ldyBVaW50OEFycmF5KHNlbGYuYW5hbHlzZXIuZmZ0U2l6ZSk7XG4gICAgICBzZWxmLmVsLmVtaXQoJ2F1ZGlvYW5hbHlzZXItcmVhZHknLCB7YW5hbHlzZXI6IGFuYWx5c2VyfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3BlY3RydW0gb24gZWFjaCBmcmFtZS5cbiAgICovXG4gIHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoIXRoaXMuYW5hbHlzZXIpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBMZXZlbHMgKGZyZXF1ZW5jeSkuXG4gICAgaWYgKGRhdGEuZW5hYmxlTGV2ZWxzIHx8IGRhdGEuZW5hYmxlVm9sdW1lKSB7XG4gICAgICB0aGlzLmFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKHRoaXMubGV2ZWxzKTtcbiAgICB9XG5cbiAgICAvLyBXYXZlZm9ybS5cbiAgICBpZiAoZGF0YS5lbmFibGVXYXZlZm9ybSkge1xuICAgICAgdGhpcy5hbmFseXNlci5nZXRCeXRlVGltZURvbWFpbkRhdGEodGhpcy53YXZlZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gQXZlcmFnZSB2b2x1bWUuXG4gICAgaWYgKGRhdGEuZW5hYmxlVm9sdW1lIHx8IGRhdGEuZW5hYmxlQmVhdERldGVjdGlvbikge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSB0aGlzLmxldmVsc1tpXTs7XG4gICAgICB9XG4gICAgICB0aGlzLnZvbHVtZSA9IHN1bSAvIHRoaXMubGV2ZWxzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBCZWF0IGRldGVjdGlvbi5cbiAgICBpZiAoZGF0YS5lbmFibGVCZWF0RGV0ZWN0aW9uKSB7XG4gICAgICB2YXIgQkVBVF9ERUNBWV9SQVRFID0gMC45OTtcbiAgICAgIHZhciBCRUFUX0hPTEQgPSA2MDtcbiAgICAgIHZhciBCRUFUX01JTiA9IDAuMTU7ICAvLyBWb2x1bWUgbGVzcyB0aGFuIHRoaXMgaXMgbm8gYmVhdC5cblxuICAgICAgdm9sdW1lID0gdGhpcy52b2x1bWU7XG4gICAgICBpZiAoIXRoaXMuYmVhdEN1dE9mZikgeyB0aGlzLmJlYXRDdXRPZmYgPSB2b2x1bWU7IH1cbiAgICAgIGlmICh2b2x1bWUgPiB0aGlzLmJlYXRDdXRPZmYgJiYgdm9sdW1lID4gQkVBVF9NSU4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1thdWRpb2FuYWx5c2VyXSBCZWF0IGRldGVjdGVkLicpO1xuICAgICAgICB0aGlzLmVsLmVtaXQoJ2F1ZGlvYW5hbHlzZXItYmVhdCcpO1xuICAgICAgICB0aGlzLmJlYXRDdXRPZmYgPSB2b2x1bWUgKiAxLjU7XG4gICAgICAgIHRoaXMuYmVhdFRpbWUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYmVhdFRpbWUgPD0gQkVBVF9IT0xEKSB7XG4gICAgICAgICAgdGhpcy5iZWF0VGltZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYmVhdEN1dE9mZiAqPSBCRUFUX0RFQ0FZX1JBVEU7XG4gICAgICAgICAgdGhpcy5iZWF0Q3V0T2ZmID0gTWF0aC5tYXgodGhpcy5iZWF0Q3V0T2ZmLCBCRUFUX01JTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2tmcmFtZS9jb21wb25lbnRzL2F1ZGlvYW5hbHlzZXIvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWFwID0ge1xuXHRcIi4vYWN0aXZlLWNvbG9yLmpzXCI6IDE3Mixcblx0XCIuL2FuYWx5emVyLmpzXCI6IDE3Myxcblx0XCIuL2JlYXQtbG9hZGVyLmpzXCI6IDE3NCxcblx0XCIuL2NvbnNvbGUtc2hvcnRjdXRzLmpzXCI6IDE3NSxcblx0XCIuL2N1cnNvci1tZXNoLmpzXCI6IDE3Nixcblx0XCIuL2RlYnVnLWNvbnRyb2xsZXIuanNcIjogMTc3LFxuXHRcIi4vZGVidWctY3Vyc29yLmpzXCI6IDE3OCxcblx0XCIuL2hhbmQtc3dhcHBlci5qc1wiOiAxNzksXG5cdFwiLi9oaXN0b3J5LmpzXCI6IDE4MCxcblx0XCIuL2tleWJvYXJkLXJheWNhc3RhYmxlLmpzXCI6IDE4MSxcblx0XCIuL2xvZ29mbGlja2VyLmpzXCI6IDE4Mixcblx0XCIuL21hdGVyaWFscy5qc1wiOiAxODMsXG5cdFwiLi9tZW51LWRpZmZpY3VsdHktc2VsZWN0LmpzXCI6IDE4NCxcblx0XCIuL21lbnUtc2VsZWN0ZWQtY2hhbGxlbmdlLWltYWdlLmpzXCI6IDE4NSxcblx0XCIuL3BhdXNlci5qc1wiOiAxODYsXG5cdFwiLi9wbGF5LXNvdW5kLmpzXCI6IDE4Nyxcblx0XCIuL3ByZWxvYWRlci5qc1wiOiAxODgsXG5cdFwiLi9yYXljYXN0YWJsZS5qc1wiOiAxODksXG5cdFwiLi9yZWNlbnRlci5qc1wiOiAxOTAsXG5cdFwiLi9zYWJlci1jb250cm9scy5qc1wiOiAxOTEsXG5cdFwiLi9zZWFyY2guanNcIjogMTkyLFxuXHRcIi4vc29uZy1wcmV2aWV3LmpzXCI6IDE5Myxcblx0XCIuL3NvbmcuanNcIjogMTk0LFxuXHRcIi4vc3RhZ2UtY29sb3JzLmpzXCI6IDE5NSxcblx0XCIuL3RleHQtdXBwZXJjYXNlLmpzXCI6IDE5Nixcblx0XCIuL3RvZ2dsZS1wYXVzZS1wbGF5LmpzXCI6IDE5Nyxcblx0XCIuL3R3aXN0ZXIuanNcIjogMTk4XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG5cdHJldHVybiBpZDtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMTUyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMgXFwuanMkXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hcCA9IHtcblx0XCIuL2luZGV4LmpzXCI6IDIwMVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpO1xuXHRyZXR1cm4gaWQ7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDE1MztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdGF0ZSBcXC5qcyRcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG4gKiBQcm92aWRlcyBhIGRlY29yYXRvciBmdW5jdG9yIGZvciBhbm5vdGF0aW5nIGZ1bmN0aW9ucyBpbiBDb21wb25lbnQgZGVmaW5pdGlvbnMgc28gdGhhdCB0aGV5IGFyZSBhdXRvbWF0aWNhbGx5XHJcbiAqIGJvdW5kIGFuZCB1bmJvdW5kIGZyb20gZXZlbnRzIHdpdGhvdXQgbmVlZGluZyB0byBjYWxsIGVsLmFkZEV2ZW50TGlzdGVuZXIgb3IgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lciB5b3Vyc2VsZi5cclxuICpcclxuICogRGVjb3JhdGlvbnMgc2hvdWxkIGJlIG1hZGUgaW4gdGhlIENvbXBvbmVudHMgZGVmaW5pdGlvbiBvYmplY3QuIEhlcmUgaXMgdGhlIHNpbXBsZXN0IGV4YW1wbGU6XHJcbiAqXHJcbiAqIGNvbnN0IHtiaW5kRXZlbnR9ID0gcmVxdWlyZSgnZXZlbnQtYmluZGVyJyk7XHJcbiAqXHJcbiAqIEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudChcImZvb1wiLCB7XHJcbiAqICAgY29tcG9uZW50Y2hhbmdlZDogYmluZEV2ZW50KCBmdW5jdGlvbihldnQpIHtcclxuICogICAgIGNvbnNvbGUubG9nKGV2dC5kZXRhaWwpO1xyXG4gKiAgIH0pXHJcbiAqIH0pXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgYm91bmQgdG8gZXZlbnRzIGNvcnJlc3BvbmRpbmcgdG8gaXRzIHByb3BlcnR5IG5hbWUsIGluIHRoaXMgY2FzZTogJ2NvbXBvbmVudGNoYW5nZWQnLlxyXG4gKiBJdCB3aWxsIGxpc3RlbiBmb3IgZXZlbnRzIG9uIGl0cyBwYXJlbnQgZWxlbWVudCwgYW5kIHdpbGwgYmVnaW4gbGlzdGVuaW5nIG9yIGVuZCBsaXN0ZW5pbmcgd2hlbiBpbml0IG9yIHJlbW92ZSBpc1xyXG4gKiBjYWxsZWQuIEhvd2V2ZXIgdGhpcyBjYW4gYWxzbyBiZSBjb25maWd1cmVkIGJ5IHBhc3NpbmcgYSBjb25maWd1cmF0aW9uIG9iamVjdDpcclxuICpcclxuICogQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KFwiZm9vXCIsIHtcclxuICogICB3aGVuU2NlbmVMb2FkczogYmluZEV2ZW50KCB7XHJcbiAqICAgICBldmVudDogXCJsb2FkZWRcIiwgICAgLy8gRXZlbnQgdG8gbGlzdGVuIGZvci4gRGVmYXVsdHMgdG8gZnVuY3Rpb25zIHByb3BlcnkgbmFtZS5cclxuICogICAgIHRhcmdldDogXCJhLXNjZW5lXCIsICAvLyBTZWxlY3RvciBzdHJpbmcgZm9yIHdoaWNoIGVsZW1lbnQgdG8gbGlzdGVuIG9uLCBkZWZhdWx0cyB0byB0aGlzLmVsXHJcbiAqICAgICBsaXN0ZW5JbjogXCJpbml0XCIsICAgLy8gV2hpY2ggZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lciBpcyBjYWxsZWQgaW4sIGRlZmF1bHRzIHRvICdpbml0J1xyXG4gKiAgICAgcmVtb3ZlSW46IFwicmVtb3ZlXCIsIC8vIFdoaWNoIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIgaXMgY2FsbGVkIGluLCBkZWZhdWx0cyB0byAncmVtb3ZlJ1xyXG4gKiAgIH0sIGZ1bmN0aW9uKGV2dCkge1xyXG4gKiAgICAgY29uc29sZS5sb2coZXZ0LmRldGFpbCk7XHJcbiAqICAgfSlcclxuICogfSlcclxuICpcclxuICogRnVuY3Rpb25zIHdpbGwgb25seSBiZSBib3VuZCB0byBldmVudHMgd2hlbiBhIG5ldyBjb21wb25lbnQgaXMgY3JlYXRlZC4gRGVjb3JhdGluZyBhIGZ1bmN0aW9uIHdpdGggYmluZEV2ZW50KClcclxuICogaW4gYSBjb21wb25lbnRzIGluaXQsIG9yIHRpY2sgZnVuY3Rpb25zIGZvciBleGFtcGxlIHdpbGwgaGF2ZSBubyBlZmZlY3QuXHJcbiAqXHJcbiAqIERvbid0IGJpbmQgdG8gYXJyb3cgZnVuY3Rpb25zIGJlY2F1c2UgdGhleSBkb24ndCBoYXZlIHRoZWlyIG93biB0aGlzLlxyXG4gKlxyXG4gKi9cclxuXHJcbmNvbnN0IGRlY29yYXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnQtZGVjb3JhdG9ycycpLmRlY29yYXRlO1xyXG5cclxuLy8gSW1wbGVtZW50cyB0aGUgYXV0b21hdGljIGJpbmRpbmcgYW5kIHVuYmluZGluZyBvZiB0aGUgY2hvc2VuIGZ1bmN0aW9uLiBXcmFwcyBpdHMgbGlzdGVuSW4gYW5kIHJlbW92ZUluXHJcbi8vIGZ1bmN0aW9ucyB0byBhZGQgYW5kIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYXQgdGhlIGNvcnJlY3QgdGltZXMuXHJcbmZ1bmN0aW9uIEJpbmRUb0V2ZW50RGVjb3JhdG9yKF9ldmVudCwgX3RhcmdldCwgX2xpc3RlbkluLCBfcmVtb3ZlSW4pIHtcclxuICByZXR1cm4gZnVuY3Rpb24ocHJvcGVydHlOYW1lLCBmdW5jKSB7XHJcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XHJcbiAgICBjb25zdCBldmVudCA9IF9ldmVudCB8fCBwcm9wZXJ0eU5hbWU7XHJcbiAgICBjb25zdCB0YXJnZXQgPSAhX3RhcmdldCA/IHRoaXMuZWwgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF90YXJnZXQpO1xyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiQ291bGRuJ3Qgc3Vic2NyaWJlIFwiK3RoaXMubmFtZStcIi5cIitwcm9wZXJ0eU5hbWUrXCIgdG8gXCIrZXZlbnQrXCIgb24gXCIrX3RhcmdldFxyXG4gICAgICAgICtcIiBiZWNhdXNlIHF1ZXJ5U2VsZWN0b3IgcmV0dXJuZWQgdW5kZWZpbmVkLlwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGlzdGVuSW4gPSBfbGlzdGVuSW4gfHwgXCJpbml0XCI7XHJcbiAgICBjb25zdCByZW1vdmVJbiA9IF9yZW1vdmVJbiB8fCBcInJlbW92ZVwiO1xyXG5cclxuICAgIGNvbnN0IGxpc3RlbkZ1bmMgPSB0aGlzW2xpc3RlbkluXTtcclxuICAgIGNvbnN0IHJlbW92ZUZ1bmMgPSB0aGlzW3JlbW92ZUluXTtcclxuICAgIGNvbnN0IGJvdW5kRnVuYyA9IGZ1bmMuYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpc1tsaXN0ZW5Jbl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGxpc3RlbkZ1bmMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxpc3RlbkZ1bmMuYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGJvdW5kRnVuYyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpc1tyZW1vdmVJbl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHJlbW92ZUZ1bmMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlbW92ZUZ1bmMuYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGJvdW5kRnVuYyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmM7XHJcbiAgfVxyXG59XHJcblxyXG4vKlxyXG4gKiBEZWNvcmF0ZXMgYSBmdW5jdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb25zIGZvciBhdXRvbWF0aWNhbGx5IGJpbmRpbmcgdG8gYW4gZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBwMSAtIElmIHRoaXMgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIGJlIGRlY29yYXRlZCB3aXRoIGRlZmF1bHQgb3B0aW9ucyBhbmQgcDIgaXMgaWdub3JlZC4gT3RoZXJ3aXNlIHRoaXMgY2FuIGJlXHJcbiAqICAgYW4gb2JqZWN0IHdoaWNoIGZpbmUgdHVuZXMgdGhlIGJpbmRpbmcuXHJcbiAqIEBwYXJhbSBwMiAtIElmIHAxIGlzIGFuIG9iamVjdCB0aGVuIHRoaXMgd2lsbCBiZSB0aGUgZnVuY3Rpb24gdG8gYmluZCB0by5cclxuICpcclxuICogQHJldHVybnMge2Z1bmN0aW9ufSBEZWNvcmF0ZWQgZnVuY3Rpb24gd2hpY2ggd3JhcHMgdGhlIGlucHV0IGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gYmluZEV2ZW50KHAxLCBwMikge1xyXG4gIGlmICh0eXBlb2YgcDEgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgcmV0dXJuIGRlY29yYXRlKHAxLCBCaW5kVG9FdmVudERlY29yYXRvcigpKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBwMSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcDIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgcmV0dXJuIGRlY29yYXRlKHAyLCBCaW5kVG9FdmVudERlY29yYXRvcihwMS5ldmVudCwgcDEudGFyZ2V0LCBwMS5saXN0ZW5JbiwgcDEucmVtb3ZlSW4pKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmluZEV2ZW50IG11c3QgdGFrZTogKGZ1bmN0aW9uKSwgb3IgYSAoW29iamVjdF0sIGZ1bmN0aW9uKVwiKVxyXG4gIH1cclxufVxyXG5cclxuLypcclxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24sIHdpbGwgYWx3YXlzIGJpbmQvdW5iaW5kIGxpc3RlbmVyIGluIHBsYXkvcGF1c2UgZnVuY3Rpb24sIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGluaXQvcmVtb3ZlXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kRXZlbnRQbGF5UGF1c2UgKHAxLCBwMikge1xyXG4gIGlmICh0eXBlb2YgcDEgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgcmV0dXJuIGRlY29yYXRlKHAxLCBCaW5kVG9FdmVudERlY29yYXRvcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJwbGF5XCIsIFwicGF1c2VcIikpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwMiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICByZXR1cm4gZGVjb3JhdGUocDIsIEJpbmRUb0V2ZW50RGVjb3JhdG9yKHAxLmV2ZW50LCBwMS50YXJnZXQsIFwicGxheVwiLCBcInBhdXNlXCIpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmluZEV2ZW50UGxheVBhdXNlIG11c3QgdGFrZTogKGZ1bmN0aW9uKSwgb3IgYSAoW29iamVjdF0sIGZ1bmN0aW9uKVwiKVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMuYmluZEV2ZW50ID0gYmluZEV2ZW50O1xyXG5tb2R1bGUuZXhwb3J0cy5iaW5kRXZlbnRQbGF5UGF1c2UgPSBiaW5kRXZlbnRQbGF5UGF1c2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FmcmFtZS1ldmVudC1kZWNvcmF0b3JzL2V2ZW50LWJpbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cbiAqL1xuXG4vLyBUaGlzIHNldCBvZiBjb250cm9scyBwZXJmb3JtcyBvcmJpdGluZywgZG9sbHlpbmcgKHpvb21pbmcpLCBhbmQgcGFubmluZy5cbi8vIFVubGlrZSBUcmFja2JhbGxDb250cm9scywgaXQgbWFpbnRhaW5zIHRoZSBcInVwXCIgZGlyZWN0aW9uIG9iamVjdC51cCAoK1kgYnkgZGVmYXVsdCkuXG4vL1xuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxuLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28gZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbmdlciBzd2lwZVxuXG5USFJFRS5PcmJpdENvbnRyb2xzID0gZnVuY3Rpb24gKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0dGhpcy5kb21FbGVtZW50ID0gKCBkb21FbGVtZW50ICE9PSB1bmRlZmluZWQgKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcblx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuXHQvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgb2JqZWN0IG9yYml0cyBhcm91bmRcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdC8vIEhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0ICggUGVyc3BlY3RpdmVDYW1lcmEgb25seSApXG5cdHRoaXMubWluRGlzdGFuY2UgPSAwO1xuXHR0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG5cblx0Ly8gSG93IGZhciB5b3UgY2FuIHpvb20gaW4gYW5kIG91dCAoIE9ydGhvZ3JhcGhpY0NhbWVyYSBvbmx5IClcblx0dGhpcy5taW5ab29tID0gMDtcblx0dGhpcy5tYXhab29tID0gSW5maW5pdHk7XG5cblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG5cdC8vIFJhbmdlIGlzIDAgdG8gTWF0aC5QSSByYWRpYW5zLlxuXHR0aGlzLm1pblBvbGFyQW5nbGUgPSAwOyAvLyByYWRpYW5zXG5cdHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgaG9yaXpvbnRhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHQvLyBJZiBzZXQsIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgdGhlIGludGVydmFsIFsgLSBNYXRoLlBJLCBNYXRoLlBJIF0uXG5cdHRoaXMubWluQXppbXV0aEFuZ2xlID0gLSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXHR0aGlzLm1heEF6aW11dGhBbmdsZSA9IEluZmluaXR5OyAvLyByYWRpYW5zXG5cblx0Ly8gU2V0IHRvIHRydWUgdG8gZW5hYmxlIGRhbXBpbmcgKGluZXJ0aWEpXG5cdC8vIElmIGRhbXBpbmcgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG5cdHRoaXMuZW5hYmxlRGFtcGluZyA9IGZhbHNlO1xuXHR0aGlzLmRhbXBpbmdGYWN0b3IgPSAwLjI1O1xuXG5cdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHpvb21pbmdcblx0dGhpcy5lbmFibGVab29tID0gdHJ1ZTtcblx0dGhpcy56b29tU3BlZWQgPSAxLjA7XG5cblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcm90YXRpbmdcblx0dGhpcy5lbmFibGVSb3RhdGUgPSB0cnVlO1xuXHR0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHBhbm5pbmdcblx0dGhpcy5lbmFibGVQYW4gPSB0cnVlO1xuXHR0aGlzLmtleVBhblNwZWVkID0gNy4wO1x0Ly8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG5cdC8vIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgcm90YXRlIGFyb3VuZCB0aGUgdGFyZ2V0XG5cdC8vIElmIGF1dG8tcm90YXRlIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuXHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0dGhpcy5hdXRvUm90YXRlU3BlZWQgPSAyLjA7IC8vIDMwIHNlY29uZHMgcGVyIHJvdW5kIHdoZW4gZnBzIGlzIDYwXG5cblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXG5cdHRoaXMuZW5hYmxlS2V5cyA9IHRydWU7XG5cblx0Ly8gVGhlIGZvdXIgYXJyb3cga2V5c1xuXHR0aGlzLmtleXMgPSB7IExFRlQ6IDM3LCBVUDogMzgsIFJJR0hUOiAzOSwgQk9UVE9NOiA0MCB9O1xuXG5cdC8vIE1vdXNlIGJ1dHRvbnNcblx0dGhpcy5tb3VzZUJ1dHRvbnMgPSB7IE9SQklUOiBUSFJFRS5NT1VTRS5MRUZULCBaT09NOiBUSFJFRS5NT1VTRS5NSURETEUsIFBBTjogVEhSRUUuTU9VU0UuUklHSFQgfTtcblxuXHQvLyBmb3IgcmVzZXRcblx0dGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcblx0dGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuXHR0aGlzLnpvb20wID0gdGhpcy5vYmplY3Quem9vbTtcblxuXHQvL1xuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHQvL1xuXG5cdHRoaXMuZ2V0UG9sYXJBbmdsZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBzcGhlcmljYWwucGhpO1xuXG5cdH07XG5cblx0dGhpcy5nZXRBemltdXRoYWxBbmdsZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBzcGhlcmljYWwudGhldGE7XG5cblx0fTtcblxuXHR0aGlzLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHNjb3BlLnRhcmdldDAuY29weSggc2NvcGUudGFyZ2V0ICk7XG5cdFx0c2NvcGUucG9zaXRpb24wLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdHNjb3BlLnpvb20wID0gc2NvcGUub2JqZWN0Lnpvb207XG5cblx0fTtcblxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0c2NvcGUudGFyZ2V0LmNvcHkoIHNjb3BlLnRhcmdldDAgKTtcblx0XHRzY29wZS5vYmplY3QucG9zaXRpb24uY29weSggc2NvcGUucG9zaXRpb24wICk7XG5cdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBzY29wZS56b29tMDtcblxuXHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH07XG5cblx0Ly8gdGhpcyBtZXRob2QgaXMgZXhwb3NlZCwgYnV0IHBlcmhhcHMgaXQgd291bGQgYmUgYmV0dGVyIGlmIHdlIGNhbiBtYWtlIGl0IHByaXZhdGUuLi5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdC8vIHNvIGNhbWVyYS51cCBpcyB0aGUgb3JiaXQgYXhpc1xuXHRcdHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMoIG9iamVjdC51cCwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXHRcdHZhciBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnNlKCk7XG5cblx0XHR2YXIgbGFzdFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgbGFzdFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXG5cdFx0XHRvZmZzZXQuY29weSggcG9zaXRpb24gKS5zdWIoIHNjb3BlLnRhcmdldCApO1xuXG5cdFx0XHQvLyByb3RhdGUgb2Zmc2V0IHRvIFwieS1heGlzLWlzLXVwXCIgc3BhY2Vcblx0XHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXQgKTtcblxuXHRcdFx0Ly8gYW5nbGUgZnJvbSB6LWF4aXMgYXJvdW5kIHktYXhpc1xuXHRcdFx0c3BoZXJpY2FsLnNldEZyb21WZWN0b3IzKCBvZmZzZXQgKTtcblxuXHRcdFx0aWYgKCBzY29wZS5hdXRvUm90YXRlICYmIHN0YXRlID09PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRcdHJvdGF0ZUxlZnQoIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGE7XG5cdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaTtcblxuXHRcdFx0Ly8gcmVzdHJpY3QgdGhldGEgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0c3BoZXJpY2FsLnRoZXRhID0gTWF0aC5tYXgoIHNjb3BlLm1pbkF6aW11dGhBbmdsZSwgTWF0aC5taW4oIHNjb3BlLm1heEF6aW11dGhBbmdsZSwgc3BoZXJpY2FsLnRoZXRhICkgKTtcblxuXHRcdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdHNwaGVyaWNhbC5waGkgPSBNYXRoLm1heCggc2NvcGUubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oIHNjb3BlLm1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbC5waGkgKSApO1xuXG5cdFx0XHRzcGhlcmljYWwubWFrZVNhZmUoKTtcblxuXG5cdFx0XHRzcGhlcmljYWwucmFkaXVzICo9IHNjYWxlO1xuXG5cdFx0XHQvLyByZXN0cmljdCByYWRpdXMgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0c3BoZXJpY2FsLnJhZGl1cyA9IE1hdGgubWF4KCBzY29wZS5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHNjb3BlLm1heERpc3RhbmNlLCBzcGhlcmljYWwucmFkaXVzICkgKTtcblxuXHRcdFx0Ly8gbW92ZSB0YXJnZXQgdG8gcGFubmVkIGxvY2F0aW9uXG5cdFx0XHRzY29wZS50YXJnZXQuYWRkKCBwYW5PZmZzZXQgKTtcblxuXHRcdFx0b2Zmc2V0LnNldEZyb21TcGhlcmljYWwoIHNwaGVyaWNhbCApO1xuXG5cdFx0XHQvLyByb3RhdGUgb2Zmc2V0IGJhY2sgdG8gXCJjYW1lcmEtdXAtdmVjdG9yLWlzLXVwXCIgc3BhY2Vcblx0XHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXRJbnZlcnNlICk7XG5cblx0XHRcdHBvc2l0aW9uLmNvcHkoIHNjb3BlLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRcdHNjb3BlLm9iamVjdC5sb29rQXQoIHNjb3BlLnRhcmdldCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0c3BoZXJpY2FsRGVsdGEudGhldGEgKj0gKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXHRcdFx0XHRzcGhlcmljYWxEZWx0YS5waGkgKj0gKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNwaGVyaWNhbERlbHRhLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjYWxlID0gMTtcblx0XHRcdHBhbk9mZnNldC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGNvbmRpdGlvbiBpczpcblx0XHRcdC8vIG1pbihjYW1lcmEgZGlzcGxhY2VtZW50LCBjYW1lcmEgcm90YXRpb24gaW4gcmFkaWFucyleMiA+IEVQU1xuXHRcdFx0Ly8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cblx0XHRcdGlmICggem9vbUNoYW5nZWQgfHxcblx0XHRcdFx0bGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKCBzY29wZS5vYmplY3QucG9zaXRpb24gKSA+IEVQUyB8fFxuXHRcdFx0XHQ4ICogKCAxIC0gbGFzdFF1YXRlcm5pb24uZG90KCBzY29wZS5vYmplY3QucXVhdGVybmlvbiApICkgPiBFUFMgKSB7XG5cblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcblxuXHRcdFx0XHRsYXN0UG9zaXRpb24uY29weSggc2NvcGUub2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0XHRcdGxhc3RRdWF0ZXJuaW9uLmNvcHkoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICk7XG5cdFx0XHRcdHpvb21DaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51LCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xuXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIGZhbHNlICk7XG5cblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XG5cblx0XHQvL3Njb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTsgLy8gc2hvdWxkIHRoaXMgYmUgYWRkZWQgaGVyZT9cblxuXHR9O1xuXG5cdC8vXG5cdC8vIGludGVybmFsc1xuXHQvL1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIGNoYW5nZUV2ZW50ID0geyB0eXBlOiAnY2hhbmdlJyB9O1xuXHR2YXIgc3RhcnRFdmVudCA9IHsgdHlwZTogJ3N0YXJ0JyB9O1xuXHR2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnIH07XG5cblx0dmFyIFNUQVRFID0geyBOT05FOiAtIDEsIFJPVEFURTogMCwgRE9MTFk6IDEsIFBBTjogMiwgVE9VQ0hfUk9UQVRFOiAzLCBUT1VDSF9ET0xMWTogNCwgVE9VQ0hfUEFOOiA1IH07XG5cblx0dmFyIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHR2YXIgRVBTID0gMC4wMDAwMDE7XG5cblx0Ly8gY3VycmVudCBwb3NpdGlvbiBpbiBzcGhlcmljYWwgY29vcmRpbmF0ZXNcblx0dmFyIHNwaGVyaWNhbCA9IG5ldyBUSFJFRS5TcGhlcmljYWwoKTtcblx0dmFyIHNwaGVyaWNhbERlbHRhID0gbmV3IFRIUkVFLlNwaGVyaWNhbCgpO1xuXG5cdHZhciBzY2FsZSA9IDE7XG5cdHZhciBwYW5PZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgem9vbUNoYW5nZWQgPSBmYWxzZTtcblxuXHR2YXIgcm90YXRlU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHJvdGF0ZURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHR2YXIgcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHBhbkRlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHR2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciBkb2xseUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciBkb2xseURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRmdW5jdGlvbiBnZXRBdXRvUm90YXRpb25BbmdsZSgpIHtcblxuXHRcdHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMC45NSwgc2NvcGUuem9vbVNwZWVkICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJvdGF0ZUxlZnQoIGFuZ2xlICkge1xuXG5cdFx0c3BoZXJpY2FsRGVsdGEudGhldGEgLT0gYW5nbGU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJvdGF0ZVVwKCBhbmdsZSApIHtcblxuXHRcdHNwaGVyaWNhbERlbHRhLnBoaSAtPSBhbmdsZTtcblxuXHR9XG5cblx0dmFyIHBhbkxlZnQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuTGVmdCggZGlzdGFuY2UsIG9iamVjdE1hdHJpeCApIHtcblxuXHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDAgKTsgLy8gZ2V0IFggY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0di5tdWx0aXBseVNjYWxhciggLSBkaXN0YW5jZSApO1xuXG5cdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHR2YXIgcGFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuVXAoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdHYuc2V0RnJvbU1hdHJpeENvbHVtbiggb2JqZWN0TWF0cml4LCAxICk7IC8vIGdldCBZIGNvbHVtbiBvZiBvYmplY3RNYXRyaXhcblx0XHRcdHYubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICk7XG5cblx0XHRcdHBhbk9mZnNldC5hZGQoIHYgKTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdC8vIGRlbHRhWCBhbmQgZGVsdGFZIGFyZSBpbiBwaXhlbHM7IHJpZ2h0IGFuZCBkb3duIGFyZSBwb3NpdGl2ZVxuXHR2YXIgcGFuID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuKCBkZWx0YVgsIGRlbHRhWSApIHtcblxuXHRcdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0Ly8gcGVyc3BlY3RpdmVcblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXHRcdFx0XHRvZmZzZXQuY29weSggcG9zaXRpb24gKS5zdWIoIHNjb3BlLnRhcmdldCApO1xuXHRcdFx0XHR2YXIgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG5cblx0XHRcdFx0Ly8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXG5cdFx0XHRcdHRhcmdldERpc3RhbmNlICo9IE1hdGgudGFuKCAoIHNjb3BlLm9iamVjdC5mb3YgLyAyICkgKiBNYXRoLlBJIC8gMTgwLjAgKTtcblxuXHRcdFx0XHQvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XG5cdFx0XHRcdHBhbkxlZnQoIDIgKiBkZWx0YVggKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cdFx0XHRcdHBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0Ly8gb3J0aG9ncmFwaGljXG5cdFx0XHRcdHBhbkxlZnQoIGRlbHRhWCAqICggc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQgKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRwYW5VcCggZGVsdGFZICogKCBzY29wZS5vYmplY3QudG9wIC0gc2NvcGUub2JqZWN0LmJvdHRvbSApIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBub3IgcGVyc3BlY3RpdmVcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLicgKTtcblx0XHRcdFx0c2NvcGUuZW5hYmxlUGFuID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdGZ1bmN0aW9uIGRvbGx5SW4oIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRpZiAoIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KCBzY29wZS5taW5ab29tLCBNYXRoLm1pbiggc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gKiBkb2xseVNjYWxlICkgKTtcblx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHR6b29tQ2hhbmdlZCA9IHRydWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLicgKTtcblx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZG9sbHlPdXQoIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRpZiAoIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRzY2FsZSAqPSBkb2xseVNjYWxlO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KCBzY29wZS5taW5ab29tLCBNYXRoLm1pbiggc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gLyBkb2xseVNjYWxlICkgKTtcblx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHR6b29tQ2hhbmdlZCA9IHRydWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLicgKTtcblx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblx0Ly8gZXZlbnQgY2FsbGJhY2tzIC0gdXBkYXRlIHRoZSBvYmplY3Qgc3RhdGVcblx0Ly9cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93blJvdGF0ZScgKTtcblxuXHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Eb2xseSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duRG9sbHknICk7XG5cblx0XHRkb2xseVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93blBhbicgKTtcblxuXHRcdHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZVJvdGF0ZScgKTtcblxuXHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRyb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdHJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRyb3RhdGVTdGFydC5jb3B5KCByb3RhdGVFbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVEb2xseSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlRG9sbHknICk7XG5cblx0XHRkb2xseUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuXHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuXHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRvbGx5RGVsdGEueSA8IDAgKSB7XG5cblx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fVxuXG5cdFx0ZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVBhbiggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlUGFuJyApO1xuXG5cdFx0cGFuRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuXG5cdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCBldmVudCApIHtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VVcCcgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlV2hlZWwnICk7XG5cblx0XHRpZiAoIGV2ZW50LmRlbHRhWSA8IDAgKSB7XG5cblx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fSBlbHNlIGlmICggZXZlbnQuZGVsdGFZID4gMCApIHtcblxuXHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdH1cblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVLZXlEb3duJyApO1xuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxuXHRcdFx0XHRwYW4oIDAsIHNjb3BlLmtleVBhblNwZWVkICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcblx0XHRcdFx0cGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLkxFRlQ6XG5cdFx0XHRcdHBhbiggc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG5cdFx0XHRcdHBhbiggLSBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnRSb3RhdGUnICk7XG5cblx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydERvbGx5JyApO1xuXG5cdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xuXHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcblxuXHRcdHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblxuXHRcdGRvbGx5U3RhcnQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0UGFuKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0UGFuJyApO1xuXG5cdFx0cGFuU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZVJvdGF0ZScgKTtcblxuXHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHQvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXG5cdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHQvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcblx0XHRyb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZURvbGx5JyApO1xuXG5cdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xuXHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcblxuXHRcdHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblxuXHRcdGRvbGx5RW5kLnNldCggMCwgZGlzdGFuY2UgKTtcblxuXHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuXHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuXHRcdFx0ZG9sbHlPdXQoIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9IGVsc2UgaWYgKCBkb2xseURlbHRhLnkgPCAwICkge1xuXG5cdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fVxuXG5cdFx0ZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlUGFuJyApO1xuXG5cdFx0cGFuRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblxuXHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcblxuXHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoRW5kJyApO1xuXG5cdH1cblxuXHQvL1xuXHQvLyBldmVudCBoYW5kbGVycyAtIEZTTTogbGlzdGVuIGZvciBldmVudHMgYW5kIHJlc2V0IHN0YXRlXG5cdC8vXG5cblx0ZnVuY3Rpb24gb25Nb3VzZURvd24oIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRzd2l0Y2ggKCBldmVudC5idXR0b24gKSB7XG5cblx0XHRcdGNhc2Ugc2NvcGUubW91c2VCdXR0b25zLk9SQklUOlxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5ST1RBVEU7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUubW91c2VCdXR0b25zLlpPT006XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZURvd25Eb2xseSggZXZlbnQgKTtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLkRPTExZO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLm1vdXNlQnV0dG9ucy5QQU46XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlRG93blBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlBBTjtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0c3dpdGNoICggc3RhdGUgKSB7XG5cblx0XHRcdGNhc2UgU1RBVEUuUk9UQVRFOlxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgU1RBVEUuRE9MTFk6XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVEb2xseSggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBTVEFURS5QQU46XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZVVwKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRoYW5kbGVNb3VzZVVwKCBldmVudCApO1xuXG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblxuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgfHwgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSAmJiBzdGF0ZSAhPT0gU1RBVEUuUk9UQVRFICkgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG5cdFx0aGFuZGxlTW91c2VXaGVlbCggZXZlbnQgKTtcblxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uS2V5RG93biggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZUtleXMgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRoYW5kbGVLZXlEb3duKCBldmVudCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICkge1xuXG5cdFx0XHRjYXNlIDE6XHQvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDI6XHQvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvblRvdWNoTW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICkge1xuXG5cdFx0XHRjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUgKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfRE9MTFkgKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTiApIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXG5cblx0XHRcdFx0aGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Ub3VjaEVuZCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aGFuZGxlVG91Y2hFbmQoIGV2ZW50ICk7XG5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbkNvbnRleHRNZW51KCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdH1cblxuXHQvL1xuXG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UgKTtcblxuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG5cblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UgKTtcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSApO1xuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UgKTtcblxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XG5cblx0Ly8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuT3JiaXRDb250cm9scy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7XG5USFJFRS5PcmJpdENvbnRyb2xzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9yYml0Q29udHJvbHM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5PcmJpdENvbnRyb2xzLnByb3RvdHlwZSwge1xuXG5cdGNlbnRlcjoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5jZW50ZXIgaGFzIGJlZW4gcmVuYW1lZCB0byAudGFyZ2V0JyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGFyZ2V0O1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5cdG5vWm9vbToge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1pvb20gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVab29tIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVab29tO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vWm9vbSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVpvb20gaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZVpvb20gPSAhIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0bm9Sb3RhdGU6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9Sb3RhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVSb3RhdGUgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVJvdGF0ZTtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1JvdGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVJvdGF0ZSBpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMuZW5hYmxlUm90YXRlID0gISB2YWx1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdG5vUGFuOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vUGFuIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUGFuIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVQYW47XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9QYW4gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVQYW4gaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZVBhbiA9ICEgdmFsdWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRub0tleXM6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9LZXlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlS2V5cyBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlS2V5cztcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub0tleXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVLZXlzIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5lbmFibGVLZXlzID0gISB2YWx1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHN0YXRpY01vdmluZzoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5zdGF0aWNNb3ZpbmcgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVEYW1waW5nIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVEYW1waW5nO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLnN0YXRpY01vdmluZyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZURhbXBpbmcgaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZURhbXBpbmcgPSAhIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0ZHluYW1pY0RhbXBpbmdGYWN0b3I6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGFtcGluZ0ZhY3RvcjtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5keW5hbWljRGFtcGluZ0ZhY3RvciBoYXMgYmVlbiByZW5hbWVkLiBVc2UgLmRhbXBpbmdGYWN0b3IgaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmRhbXBpbmdGYWN0b3IgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9XG5cbn0gKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtb3JiaXQtY29udHJvbHMvbGliL09yYml0Q29udHJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBzaGFkZXItcGFydGljbGUtZW5naW5lIDEuMC41XG4gKiBcbiAqIChjKSAyMDE1IEx1a2UgTW9vZHkgKGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9zcXVhcmVmZWV0KVxuICogICAgIE9yaWdpbmFsbHkgYmFzZWQgb24gTGVlIFN0ZW1rb3NraSdzIG9yaWdpbmFsIHdvcmsgKGh0dHBzOi8vZ2l0aHViLmNvbS9zdGVta29za2kvc3RlbWtvc2tpLmdpdGh1Yi5jb20vYmxvYi9tYXN0ZXIvVGhyZWUuanMvanMvUGFydGljbGVFbmdpbmUuanMpLlxuICpcbiAqIHNoYWRlci1wYXJ0aWNsZS1lbmdpbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKFNlZSBMSUNFTlNFIGF0IHJvb3Qgb2YgdGhpcyByZXBvc2l0b3J5LilcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7TnVtYmVyfSBkaXN0cmlidXRpb25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBTUEUuZGlzdHJpYnV0aW9ucy5CT1ggVmFsdWVzIHdpbGwgYmUgZGlzdHJpYnV0ZWQgd2l0aGluIGEgYm94LlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFNQRS5kaXN0cmlidXRpb25zLlNQSEVSRSBWYWx1ZXMgd2lsbCBiZSBkaXN0cmlidXRlZCB3aXRoaW4gYSBzcGhlcmUuXG4gKiBAcHJvcGVydHkge051bWJlcn0gU1BFLmRpc3RyaWJ1dGlvbnMuRElTQyBWYWx1ZXMgd2lsbCBiZSBkaXN0cmlidXRlZCB3aXRoaW4gYSAyRCBkaXNjLlxuICovXG5cbi8qKlxuICogTmFtZXNwYWNlIGZvciBTaGFkZXIgUGFydGljbGUgRW5naW5lLlxuICpcbiAqIEFsbCBTUEUtcmVsYXRlZCBjb2RlIHNpdHMgdW5kZXIgdGhpcyBuYW1lc3BhY2UuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIFNQRSA9IHtcblxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHN1cHBvcnRlZCBkaXN0cmlidXRpb24gdHlwZXMgdXNlZFxuICAgICAqIGJ5IFNQRS5FbWl0dGVyIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIFRoZXNlIGRpc3RyaWJ1dGlvbiB0eXBlcyBjYW4gYmUgYXBwbGllZCB0b1xuICAgICAqIGFuIGVtaXR0ZXIgZ2xvYmFsbHksIHdoaWNoIHdpbGwgYWZmZWN0IHRoZVxuICAgICAqIGBwb3NpdGlvbmAsIGB2ZWxvY2l0eWAsIGFuZCBgYWNjZWxlcmF0aW9uYFxuICAgICAqIHZhbHVlIGNhbGN1bGF0aW9ucyBmb3IgYW4gZW1pdHRlciwgb3IgdGhleVxuICAgICAqIGNhbiBiZSBhcHBsaWVkIG9uIGEgcGVyLXByb3BlcnR5IGJhc2lzLlxuICAgICAqXG4gICAgICogQGVudW0ge051bWJlcn1cbiAgICAgKi9cbiAgICBkaXN0cmlidXRpb25zOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZXMgd2lsbCBiZSBkaXN0cmlidXRlZCB3aXRoaW4gYSBib3guXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBCT1g6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlcyB3aWxsIGJlIGRpc3RyaWJ1dGVkIG9uIGEgc3BoZXJlLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgU1BIRVJFOiAyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZXMgd2lsbCBiZSBkaXN0cmlidXRlZCBvbiBhIDJkLWRpc2Mgc2hhcGUuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBESVNDOiAzLFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHZhbHVlIHRvIGhvd2V2ZXIgbWFueSAnc3RlcHMnIHlvdVxuICAgICAqIHdhbnQgdmFsdWUtb3Zlci1saWZldGltZSBwcm9wZXJ0aWVzIHRvIGhhdmUuXG4gICAgICpcbiAgICAgKiBJdCdzIGFkanVzdGFibGUgdG8gZml4IGFuIGludGVycG9sYXRpb24gcHJvYmxlbTpcbiAgICAgKlxuICAgICAqIEFzc3VtaW5nIHlvdSBzcGVjaWZ5IGFuIG9wYWNpdHkgdmFsdWUgYXMgWzAsIDEsIDBdXG4gICAgICogICAgICBhbmQgdGhlIGB2YWx1ZU92ZXJMaWZldGltZUxlbmd0aGAgaXMgNCwgdGhlbiB0aGVcbiAgICAgKiAgICAgIG9wYWNpdHkgdmFsdWUgYXJyYXkgd2lsbCBiZSByZWludGVycG9sYXRlZCB0b1xuICAgICAqICAgICAgYmUgWzAsIDAuNjYsIDAuNjYsIDBdLlxuICAgICAqICAgVGhpcyBpc24ndCBpZGVhbCwgYXMgcGFydGljbGVzIHdvdWxkIG5ldmVyIHJlYWNoXG4gICAgICogICBmdWxsIG9wYWNpdHkuXG4gICAgICpcbiAgICAgKiBOT1RFOlxuICAgICAqICAgICBUaGlzIHByb3BlcnR5IGFmZmVjdHMgdGhlIGxlbmd0aCBvZiBBTExcbiAgICAgKiAgICAgICB2YWx1ZS1vdmVyLWxpZmV0aW1lIHByb3BlcnRpZXMgZm9yIEFMTFxuICAgICAqICAgICAgIGVtaXR0ZXJzIGFuZCBBTEwgZ3JvdXBzLlxuICAgICAqXG4gICAgICogICAgIE9ubHkgdmFsdWVzID49IDMgJiYgPD0gNCBhcmUgYWxsb3dlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdmFsdWVPdmVyTGlmZXRpbWVMZW5ndGg6IDRcbn07XG5cbi8vIE1vZHVsZSBsb2FkZXIgc3VwcG9ydDpcbmlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIGRlZmluZSggJ3NwZScsIFNQRSApO1xufVxuZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNQRTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyBmb3IgVHlwZWRBcnJheXMuXG4gKlxuICogQWxsb3dzIGZvciBlYXN5IHJlc2l6aW5nLCBhc3NpZ25tZW50IG9mIHZhcmlvdXMgY29tcG9uZW50LWJhc2VkXG4gKiB0eXBlcyAoVmVjdG9yMnMsIFZlY3RvcjNzLCBWZWN0b3I0cywgTWF0M3MsIE1hdDRzKSxcbiAqIGFzIHdlbGwgYXMgQ29sb3JzICh3aGVyZSBjb21wb25lbnRzIGFyZSBgcmAsIGBnYCwgYGJgKSxcbiAqIE51bWJlcnMsIGFuZCBzZXR0aW5nIGZyb20gb3RoZXIgVHlwZWRBcnJheXMuXG4gKlxuICogQGF1dGhvciBMdWtlIE1vb2R5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3IgdG8gdXNlIChGbG9hdDMyQXJyYXksIFVpbnQ4QXJyYXksIGV0Yy4pXG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAgICAgICAgICAgICAgICAgVGhlIHNpemUgb2YgdGhlIGFycmF5IHRvIGNyZWF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbXBvbmVudFNpemUgICAgICAgIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBwZXItdmFsdWUgKGllLiAzIGZvciBhIHZlYzMsIDkgZm9yIGEgTWF0MywgZXRjLilcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleE9mZnNldCAgICAgICAgICBUaGUgaW5kZXggaW4gdGhlIGFycmF5IGZyb20gd2hpY2ggdG8gc3RhcnQgYXNzaWduaW5nIHZhbHVlcy4gRGVmYXVsdCBgMGAgaWYgbm9uZSBwcm92aWRlZFxuICovXG5TUEUuVHlwZWRBcnJheUhlbHBlciA9IGZ1bmN0aW9uKCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIHNpemUsIGNvbXBvbmVudFNpemUsIGluZGV4T2Zmc2V0ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuY29tcG9uZW50U2l6ZSA9IGNvbXBvbmVudFNpemUgfHwgMTtcbiAgICB0aGlzLnNpemUgPSAoIHNpemUgfHwgMSApO1xuICAgIHRoaXMuVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yIHx8IEZsb2F0MzJBcnJheTtcbiAgICB0aGlzLmFycmF5ID0gbmV3IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvciggc2l6ZSAqIHRoaXMuY29tcG9uZW50U2l6ZSApO1xuICAgIHRoaXMuaW5kZXhPZmZzZXQgPSBpbmRleE9mZnNldCB8fCAwO1xufTtcblxuU1BFLlR5cGVkQXJyYXlIZWxwZXIuY29uc3RydWN0b3IgPSBTUEUuVHlwZWRBcnJheUhlbHBlcjtcblxuLyoqXG4gKiBTZXRzIHRoZSBzaXplIG9mIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqXG4gKiBEZWxlZ2F0ZXMgdG8gYHRoaXMuc2hyaW5rYCBvciBgdGhpcy5ncm93YCBkZXBlbmRpbmcgb24gc2l6ZVxuICogYXJndW1lbnQncyByZWxhdGlvbiB0byB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgdGhlIGFycmF5IGlzIHRvIGJlIHNocnVuaywgZGF0YSB3aWxsIGJlIGxvc3QuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVGhlIG5ldyBzaXplIG9mIHRoZSBhcnJheS5cbiAqL1xuU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiggc2l6ZSwgbm9Db21wb25lbnRNdWx0aXBseSApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgY3VycmVudEFycmF5U2l6ZSA9IHRoaXMuYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKCAhbm9Db21wb25lbnRNdWx0aXBseSApIHtcbiAgICAgICAgc2l6ZSA9IHNpemUgKiB0aGlzLmNvbXBvbmVudFNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBzaXplIDwgY3VycmVudEFycmF5U2l6ZSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hyaW5rKCBzaXplICk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCBzaXplID4gY3VycmVudEFycmF5U2l6ZSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3Jvdyggc2l6ZSApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCAnVHlwZWRBcnJheSBpcyBhbHJlYWR5IG9mIHNpemU6Jywgc2l6ZSArICcuJywgJ1dpbGwgbm90IHJlc2l6ZS4nICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaHJpbmtzIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNpemUgVGhlIG5ldyBzaXplIG9mIHRoZSB0eXBlZCBhcnJheS4gTXVzdCBiZSBzbWFsbGVyIHRoYW4gYHRoaXMuYXJyYXkubGVuZ3RoYC5cbiAqIEByZXR1cm4ge1NQRS5UeXBlZEFycmF5SGVscGVyfSAgICAgIEluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKi9cblNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zaHJpbmsgPSBmdW5jdGlvbiggc2l6ZSApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5zdWJhcnJheSggMCwgc2l6ZSApO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdyb3dzIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqIEBwYXJhbSAge051bWJlcn0gc2l6ZSBUaGUgbmV3IHNpemUgb2YgdGhlIHR5cGVkIGFycmF5LiBNdXN0IGJlIGxhcmdlciB0aGFuIGB0aGlzLmFycmF5Lmxlbmd0aGAuXG4gKiBAcmV0dXJuIHtTUEUuVHlwZWRBcnJheUhlbHBlcn0gICAgICBJbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5TUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuZ3JvdyA9IGZ1bmN0aW9uKCBzaXplICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBleGlzdGluZ0FycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgbmV3QXJyYXkgPSBuZXcgdGhpcy5UeXBlZEFycmF5Q29uc3RydWN0b3IoIHNpemUgKTtcblxuICAgIG5ld0FycmF5LnNldCggZXhpc3RpbmdBcnJheSApO1xuICAgIHRoaXMuYXJyYXkgPSBuZXdBcnJheTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogUGVyZm9ybSBhIHNwbGljZSBvcGVyYXRpb24gb24gdGhpcyBhcnJheSdzIGJ1ZmZlci5cbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBzcGxpY2UuIFdpbGwgYmUgbXVsdGlwbGllZCBieSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgZm9yIHRoaXMgYXR0cmlidXRlLlxuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleCBvZiB0aGUgc3BsaWNlLiBXaWxsIGJlIG11bHRpcGxpZWQgYnkgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciB0aGlzIGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBTUEUuVHlwZWRBcnJheUhlbHBlciBpbnN0YW5jZS5cbiAqL1xuU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKCBzdGFydCwgZW5kICkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBzdGFydCAqPSB0aGlzLmNvbXBvbmVudFNpemU7XG4gICAgZW5kICo9IHRoaXMuY29tcG9uZW50U2l6ZTtcblxuICAgIHZhciBkYXRhID0gW10sXG4gICAgICAgIGFycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7ICsraSApIHtcbiAgICAgICAgaWYgKCBpIDwgc3RhcnQgfHwgaSA+PSBlbmQgKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goIGFycmF5WyBpIF0gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcnJheVsgaSBdID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLnNldEZyb21BcnJheSggMCwgZGF0YSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ29waWVzIGZyb20gdGhlIGdpdmVuIFR5cGVkQXJyYXkgaW50byB0aGlzIG9uZSwgdXNpbmcgdGhlIGluZGV4IGFyZ3VtZW50XG4gKiBhcyB0aGUgc3RhcnQgcG9zaXRpb24uIEFsaWFzIGZvciBgVHlwZWRBcnJheS5zZXRgLiBXaWxsIGF1dG9tYXRpY2FsbHkgcmVzaXplXG4gKiBpZiB0aGUgZ2l2ZW4gc291cmNlIGFycmF5IGlzIG9mIGEgbGFyZ2VyIHNpemUgdGhhbiB0aGUgaW50ZXJuYWwgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgVGhlIHN0YXJ0IHBvc2l0aW9uIGZyb20gd2hpY2ggdG8gY29weSBpbnRvIHRoaXMgYXJyYXkuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGFycmF5IFRoZSBhcnJheSBmcm9tIHdoaWNoIHRvIGNvcHk7IHRoZSBzb3VyY2UgYXJyYXkuXG4gKiBAcmV0dXJuIHtTUEUuVHlwZWRBcnJheUhlbHBlcn0gSW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldEZyb21BcnJheSA9IGZ1bmN0aW9uKCBpbmRleCwgYXJyYXkgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHNvdXJjZUFycmF5U2l6ZSA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmV3U2l6ZSA9IGluZGV4ICsgc291cmNlQXJyYXlTaXplO1xuXG4gICAgaWYgKCBuZXdTaXplID4gdGhpcy5hcnJheS5sZW5ndGggKSB7XG4gICAgICAgIHRoaXMuZ3JvdyggbmV3U2l6ZSApO1xuICAgIH1cbiAgICBlbHNlIGlmICggbmV3U2l6ZSA8IHRoaXMuYXJyYXkubGVuZ3RoICkge1xuICAgICAgICB0aGlzLnNocmluayggbmV3U2l6ZSApO1xuICAgIH1cblxuICAgIHRoaXMuYXJyYXkuc2V0KCBhcnJheSwgdGhpcy5pbmRleE9mZnNldCArIGluZGV4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGEgVmVjdG9yMiB2YWx1ZSBhdCBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc2V0IHRoZSB2ZWMyIHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtWZWN0b3IyfSB2ZWMyICBBbnkgb2JqZWN0IHRoYXQgaGFzIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJuIHtTUEUuVHlwZWRBcnJheUhlbHBlcn0gSW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzIgPSBmdW5jdGlvbiggaW5kZXgsIHZlYzIgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0VmVjMkNvbXBvbmVudHMoIGluZGV4LCB2ZWMyLngsIHZlYzIueSApO1xufTtcblxuLyoqXG4gKiBTZXQgYSBWZWN0b3IyIHZhbHVlIHVzaW5nIHJhdyBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc2V0IHRoZSB2ZWMyIHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgIFRoZSBWZWMyJ3MgYHhgIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgICBUaGUgVmVjMidzIGB5YCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtTUEUuVHlwZWRBcnJheUhlbHBlcn0gSW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldFZlYzJDb21wb25lbnRzID0gZnVuY3Rpb24oIGluZGV4LCB4LCB5ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksXG4gICAgICAgIGkgPSB0aGlzLmluZGV4T2Zmc2V0ICsgKCBpbmRleCAqIHRoaXMuY29tcG9uZW50U2l6ZSApO1xuXG4gICAgYXJyYXlbIGkgXSA9IHg7XG4gICAgYXJyYXlbIGkgKyAxIF0gPSB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYSBWZWN0b3IzIHZhbHVlIGF0IGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIHZlYzMgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IHZlYzIgIEFueSBvYmplY3QgdGhhdCBoYXMgYHhgLCBgeWAsIGFuZCBgemAgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge1NQRS5UeXBlZEFycmF5SGVscGVyfSBJbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5TUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjMyA9IGZ1bmN0aW9uKCBpbmRleCwgdmVjMyApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRWZWMzQ29tcG9uZW50cyggaW5kZXgsIHZlYzMueCwgdmVjMy55LCB2ZWMzLnogKTtcbn07XG5cbi8qKlxuICogU2V0IGEgVmVjdG9yMyB2YWx1ZSB1c2luZyByYXcgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHNldCB0aGUgdmVjMyB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4ICAgICBUaGUgVmVjMydzIGB4YCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSAgICAgVGhlIFZlYzMncyBgeWAgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHogICAgIFRoZSBWZWMzJ3MgYHpgIGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge1NQRS5UeXBlZEFycmF5SGVscGVyfSBJbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5TUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0VmVjM0NvbXBvbmVudHMgPSBmdW5jdGlvbiggaW5kZXgsIHgsIHksIHogKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSxcbiAgICAgICAgaSA9IHRoaXMuaW5kZXhPZmZzZXQgKyAoIGluZGV4ICogdGhpcy5jb21wb25lbnRTaXplICk7XG5cbiAgICBhcnJheVsgaSBdID0geDtcbiAgICBhcnJheVsgaSArIDEgXSA9IHk7XG4gICAgYXJyYXlbIGkgKyAyIF0gPSB6O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYSBWZWN0b3I0IHZhbHVlIGF0IGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIHZlYzQgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge1ZlY3RvcjR9IHZlYzIgIEFueSBvYmplY3QgdGhhdCBoYXMgYHhgLCBgeWAsIGB6YCwgYW5kIGB3YCBwcm9wZXJ0aWVzLlxuICogQHJldHVybiB7U1BFLlR5cGVkQXJyYXlIZWxwZXJ9IEluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKi9cblNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWM0ID0gZnVuY3Rpb24oIGluZGV4LCB2ZWM0ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLnNldFZlYzRDb21wb25lbnRzKCBpbmRleCwgdmVjNC54LCB2ZWM0LnksIHZlYzQueiwgdmVjNC53ICk7XG59O1xuXG4vKipcbiAqIFNldCBhIFZlY3RvcjQgdmFsdWUgdXNpbmcgcmF3IGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIHZlYzQgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge051bWJlcn0geCAgICAgVGhlIFZlYzQncyBgeGAgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgIFRoZSBWZWM0J3MgYHlgIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6ICAgICBUaGUgVmVjNCdzIGB6YCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gdyAgICAgVGhlIFZlYzQncyBgd2AgY29tcG9uZW50LlxuICogQHJldHVybiB7U1BFLlR5cGVkQXJyYXlIZWxwZXJ9IEluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKi9cblNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRWZWM0Q29tcG9uZW50cyA9IGZ1bmN0aW9uKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LFxuICAgICAgICBpID0gdGhpcy5pbmRleE9mZnNldCArICggaW5kZXggKiB0aGlzLmNvbXBvbmVudFNpemUgKTtcblxuICAgIGFycmF5WyBpIF0gPSB4O1xuICAgIGFycmF5WyBpICsgMSBdID0geTtcbiAgICBhcnJheVsgaSArIDIgXSA9IHo7XG4gICAgYXJyYXlbIGkgKyAzIF0gPSB3O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYSBNYXRyaXgzIHZhbHVlIGF0IGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIG1hdHJpeCB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7TWF0cml4M30gbWF0MyBUaGUgM3gzIG1hdHJpeCB0byBzZXQgZnJvbS4gTXVzdCBoYXZlIGEgVHlwZWRBcnJheSBwcm9wZXJ0eSBuYW1lZCBgZWxlbWVudHNgIHRvIGNvcHkgZnJvbS5cbiAqIEByZXR1cm4ge1NQRS5UeXBlZEFycmF5SGVscGVyfSBJbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5TUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuc2V0TWF0MyA9IGZ1bmN0aW9uKCBpbmRleCwgbWF0MyApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tQXJyYXkoIHRoaXMuaW5kZXhPZmZzZXQgKyAoIGluZGV4ICogdGhpcy5jb21wb25lbnRTaXplICksIG1hdDMuZWxlbWVudHMgKTtcbn07XG5cbi8qKlxuICogU2V0IGEgTWF0cml4NCB2YWx1ZSBhdCBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc2V0IHRoZSBtYXRyaXggdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge01hdHJpeDR9IG1hdDMgVGhlIDR4NCBtYXRyaXggdG8gc2V0IGZyb20uIE11c3QgaGF2ZSBhIFR5cGVkQXJyYXkgcHJvcGVydHkgbmFtZWQgYGVsZW1lbnRzYCB0byBjb3B5IGZyb20uXG4gKiBAcmV0dXJuIHtTUEUuVHlwZWRBcnJheUhlbHBlcn0gSW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldE1hdDQgPSBmdW5jdGlvbiggaW5kZXgsIG1hdDQgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbUFycmF5KCB0aGlzLmluZGV4T2Zmc2V0ICsgKCBpbmRleCAqIHRoaXMuY29tcG9uZW50U2l6ZSApLCBtYXQ0LmVsZW1lbnRzICk7XG59O1xuXG4vKipcbiAqIFNldCBhIENvbG9yIHZhbHVlIGF0IGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIHZlYzMgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciAgQW55IG9iamVjdCB0aGF0IGhhcyBgcmAsIGBnYCwgYW5kIGBiYCBwcm9wZXJ0aWVzLlxuICogQHJldHVybiB7U1BFLlR5cGVkQXJyYXlIZWxwZXJ9IEluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKi9cblNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uKCBpbmRleCwgY29sb3IgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0VmVjM0NvbXBvbmVudHMoIGluZGV4LCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG59O1xuXG4vKipcbiAqIFNldCBhIE51bWJlciB2YWx1ZSBhdCBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc2V0IHRoZSB2ZWMzIHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWVyaWNWYWx1ZSAgVGhlIG51bWJlciB0byBhc3NpZ24gdG8gdGhpcyBpbmRleCBpbiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTUEUuVHlwZWRBcnJheUhlbHBlcn0gSW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuU1BFLlR5cGVkQXJyYXlIZWxwZXIucHJvdG90eXBlLnNldE51bWJlciA9IGZ1bmN0aW9uKCBpbmRleCwgbnVtZXJpY1ZhbHVlICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuYXJyYXlbIHRoaXMuaW5kZXhPZmZzZXQgKyAoIGluZGV4ICogdGhpcy5jb21wb25lbnRTaXplICkgXSA9IG51bWVyaWNWYWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBpbmRleCwgdGFraW5nIGludG8gYWNjb3VudFxuICogdGhlIGBpbmRleE9mZnNldGAgcHJvcGVydHkgb2YgdGhpcyBjbGFzcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpZ25vcmVzIHRoZSBjb21wb25lbnQgc2l6ZSBhbmQgd2lsbCBqdXN0IHJldHVybiBhXG4gKiBzaW5nbGUgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggaW4gdGhlIGFycmF5IHRvIGZldGNoLlxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICBUaGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICovXG5TUEUuVHlwZWRBcnJheUhlbHBlci5wcm90b3R5cGUuZ2V0VmFsdWVBdEluZGV4ID0gZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLmFycmF5WyB0aGlzLmluZGV4T2Zmc2V0ICsgaW5kZXggXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29tcG9uZW50IHZhbHVlIG9mIHRoZSBhcnJheSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIHRha2luZyBpbnRvIGFjY291bnRcbiAqIHRoZSBgaW5kZXhPZmZzZXRgIHByb3BlcnR5IG9mIHRoaXMgY2xhc3MuXG4gKlxuICogSWYgdGhlIGNvbXBvbmVudFNpemUgaXMgc2V0IHRvIDMsIHRoZW4gaXQgd2lsbCByZXR1cm4gYSBuZXcgVHlwZWRBcnJheVxuICogb2YgbGVuZ3RoIDMuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggaW4gdGhlIGFycmF5IHRvIGZldGNoLlxuICogQHJldHVybiB7VHlwZWRBcnJheX0gICAgICAgVGhlIGNvbXBvbmVudCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gKi9cblNQRS5UeXBlZEFycmF5SGVscGVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRWYWx1ZUF0SW5kZXggPSBmdW5jdGlvbiggaW5kZXggKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXkuc3ViYXJyYXkoIHRoaXMuaW5kZXhPZmZzZXQgKyAoIGluZGV4ICogdGhpcy5jb21wb25lbnRTaXplICkgKTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgdG8gaGFuZGxlIGNyZWF0aW5nIGFuZCB1cGRhdGluZyBhIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBpbnN0YW5jZS5cbiAqXG4gKiBAYXV0aG9yICBMdWtlIE1vb2R5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICAgICAgIFRoZSBidWZmZXIgYXR0cmlidXRlIHR5cGUuIFNlZSBTUEUuU2hhZGVyQXR0cmlidXRlLnR5cGVTaXplTWFwIGZvciB2YWxpZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSBkeW5hbWljQnVmZmVyIFdoZXRoZXIgdGhpcyBidWZmZXIgYXR0cmlidXRlIHNob3VsZCBiZSBtYXJrZWQgYXMgZHluYW1pYyBvciBub3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gYXJyYXlUeXBlICAgICBBIHJlZmVyZW5jZSB0byBhIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIERlZmF1bHRzIHRvIEZsb2F0MzJBcnJheSBpZiBub25lIHByb3ZpZGVkLlxuICovXG5TUEUuU2hhZGVyQXR0cmlidXRlID0gZnVuY3Rpb24oIHR5cGUsIGR5bmFtaWNCdWZmZXIsIGFycmF5VHlwZSApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgdHlwZU1hcCA9IFNQRS5TaGFkZXJBdHRyaWJ1dGUudHlwZVNpemVNYXA7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZU1hcC5oYXNPd25Qcm9wZXJ0eSggdHlwZSApID8gdHlwZSA6ICdmJztcbiAgICB0aGlzLmNvbXBvbmVudFNpemUgPSB0eXBlTWFwWyB0aGlzLnR5cGUgXTtcbiAgICB0aGlzLmFycmF5VHlwZSA9IGFycmF5VHlwZSB8fCBGbG9hdDMyQXJyYXk7XG4gICAgdGhpcy50eXBlZEFycmF5ID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlckF0dHJpYnV0ZSA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljQnVmZmVyID0gISFkeW5hbWljQnVmZmVyO1xuXG4gICAgdGhpcy51cGRhdGVNaW4gPSAwO1xuICAgIHRoaXMudXBkYXRlTWF4ID0gMDtcbn07XG5cblNQRS5TaGFkZXJBdHRyaWJ1dGUuY29uc3RydWN0b3IgPSBTUEUuU2hhZGVyQXR0cmlidXRlO1xuXG4vKipcbiAqIEEgbWFwIG9mIHVuaWZvcm0gdHlwZXMgdG8gdGhlaXIgY29tcG9uZW50IHNpemUuXG4gKiBAZW51bSB7TnVtYmVyfVxuICovXG5TUEUuU2hhZGVyQXR0cmlidXRlLnR5cGVTaXplTWFwID0ge1xuICAgIC8qKlxuICAgICAqIEZsb2F0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBmOiAxLFxuXG4gICAgLyoqXG4gICAgICogVmVjMlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdjI6IDIsXG5cbiAgICAvKipcbiAgICAgKiBWZWMzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB2MzogMyxcblxuICAgIC8qKlxuICAgICAqIFZlYzRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHY0OiA0LFxuXG4gICAgLyoqXG4gICAgICogQ29sb3JcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGM6IDMsXG5cbiAgICAvKipcbiAgICAgKiBNYXQzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBtMzogOSxcblxuICAgIC8qKlxuICAgICAqIE1hdDRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIG00OiAxNlxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdXBkYXRlIHJhbmdlIGZvciB0aGlzIGJ1ZmZlciBhdHRyaWJ1dGUgdXNpbmdcbiAqIGNvbXBvbmVudCBzaXplIGluZGVwZW5kYW50IG1pbiBhbmQgbWF4IHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gbWFyayBhcyBuZWVkaW5nIGFuIHVwZGF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVGhlIGVuZCBvZiB0aGUgcmFuZ2UgdG8gbWFyayBhcyBuZWVkaW5nIGFuIHVwZGF0ZS5cbiAqL1xuU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuc2V0VXBkYXRlUmFuZ2UgPSBmdW5jdGlvbiggbWluLCBtYXggKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdGhpcy51cGRhdGVNaW4gPSBNYXRoLm1pbiggbWluICogdGhpcy5jb21wb25lbnRTaXplLCB0aGlzLnVwZGF0ZU1pbiAqIHRoaXMuY29tcG9uZW50U2l6ZSApO1xuICAgIHRoaXMudXBkYXRlTWF4ID0gTWF0aC5tYXgoIG1heCAqIHRoaXMuY29tcG9uZW50U2l6ZSwgdGhpcy51cGRhdGVNYXggKiB0aGlzLmNvbXBvbmVudFNpemUgKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgaW5kaWNlcyB0aGF0IHRoaXMgYXR0cmlidXRlIHNob3VsZCBtYXJrIGFzIG5lZWRpbmdcbiAqIHVwZGF0aW5nLiBBbHNvIG1hcmtzIHRoZSBhdHRyaWJ1dGUgYXMgbmVlZGluZyBhbiB1cGRhdGUuXG4gKi9cblNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLmZsYWdVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgYXR0ciA9IHRoaXMuYnVmZmVyQXR0cmlidXRlLFxuICAgICAgICByYW5nZSA9IGF0dHIudXBkYXRlUmFuZ2U7XG5cbiAgICByYW5nZS5vZmZzZXQgPSB0aGlzLnVwZGF0ZU1pbjtcbiAgICByYW5nZS5jb3VudCA9IE1hdGgubWluKCAoIHRoaXMudXBkYXRlTWF4IC0gdGhpcy51cGRhdGVNaW4gKSArIHRoaXMuY29tcG9uZW50U2l6ZSwgdGhpcy50eXBlZEFycmF5LmFycmF5Lmxlbmd0aCApO1xuICAgIC8vIGNvbnNvbGUubG9nKCByYW5nZS5vZmZzZXQsIHJhbmdlLmNvdW50LCB0aGlzLnR5cGVkQXJyYXkuYXJyYXkubGVuZ3RoICk7XG4gICAgLy8gY29uc29sZS5sb2coICdmbGFnVXBkYXRlOicsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQgKTtcbiAgICBhdHRyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cblxuXG4vKipcbiAqIFJlc2V0IHRoZSBpbmRleCB1cGRhdGUgY291bnRzIGZvciB0aGlzIGF0dHJpYnV0ZVxuICovXG5TUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5yZXNldFVwZGF0ZVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdGhpcy51cGRhdGVNaW4gPSAwO1xuICAgIHRoaXMudXBkYXRlTWF4ID0gMDtcbn07XG5cblNQRS5TaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLnJlc2V0RHluYW1pYyA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5keW5hbWljID0gdGhpcy5keW5hbWljQnVmZmVyO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgc3BsaWNlIG9wZXJhdGlvbiBvbiB0aGlzIGF0dHJpYnV0ZSdzIGJ1ZmZlci5cbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBzcGxpY2UuIFdpbGwgYmUgbXVsdGlwbGllZCBieSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgZm9yIHRoaXMgYXR0cmlidXRlLlxuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleCBvZiB0aGUgc3BsaWNlLiBXaWxsIGJlIG11bHRpcGxpZWQgYnkgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciB0aGlzIGF0dHJpYnV0ZS5cbiAqL1xuU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24oIHN0YXJ0LCBlbmQgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdGhpcy50eXBlZEFycmF5LnNwbGljZSggc3RhcnQsIGVuZCApO1xuXG4gICAgLy8gUmVzZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXlcbiAgICAvLyBzaW5jZSBpdCBoYXMgcHJvYmFibHkgY2hhbmdlZC5cbiAgICB0aGlzLmZvcmNlVXBkYXRlQWxsKCk7XG59O1xuXG5TUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5mb3JjZVVwZGF0ZUFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuYnVmZmVyQXR0cmlidXRlLmFycmF5ID0gdGhpcy50eXBlZEFycmF5LmFycmF5O1xuICAgIHRoaXMuYnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlLm9mZnNldCA9IDA7XG4gICAgdGhpcy5idWZmZXJBdHRyaWJ1dGUudXBkYXRlUmFuZ2UuY291bnQgPSAtMTtcbiAgICB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5keW5hbWljID0gZmFsc2U7XG4gICAgdGhpcy5idWZmZXJBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhpcyBhdHRyaWJ1dGUgaGFzIGEgdHlwZWQgYXJyYXkgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICpcbiAqIElmIGl0IGRvZXMsIHRoZW4gaXQgd2lsbCBlbnN1cmUgdGhlIHR5cGVkIGFycmF5IGlzIG9mIHRoZSBjb3JyZWN0IHNpemUuXG4gKlxuICogSWYgbm90LCBhIG5ldyBTUEUuVHlwZWRBcnJheUhlbHBlciBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBzaXplIFRoZSBzaXplIG9mIHRoZSB0eXBlZCBhcnJheSB0byBjcmVhdGUgb3IgdXBkYXRlIHRvLlxuICovXG5TUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5fZW5zdXJlVHlwZWRBcnJheSA9IGZ1bmN0aW9uKCBzaXplICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIENvbmRpdGlvbiB0aGF0J3MgbW9zdCBsaWtlbHkgdG8gYmUgdHJ1ZSBhdCB0aGUgdG9wOiBubyBjaGFuZ2UuXG4gICAgaWYgKCB0aGlzLnR5cGVkQXJyYXkgIT09IG51bGwgJiYgdGhpcy50eXBlZEFycmF5LnNpemUgPT09IHNpemUgKiB0aGlzLmNvbXBvbmVudFNpemUgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXNpemUgdGhlIGFycmF5IGlmIHdlIG5lZWQgdG8sIHRlbGxpbmcgdGhlIFR5cGVkQXJyYXlIZWxwZXIgdG9cbiAgICAvLyBpZ25vcmUgaXQncyBjb21wb25lbnQgc2l6ZSB3aGVuIGV2YWx1YXRpbmcgc2l6ZS5cbiAgICBlbHNlIGlmICggdGhpcy50eXBlZEFycmF5ICE9PSBudWxsICYmIHRoaXMudHlwZWRBcnJheS5zaXplICE9PSBzaXplICkge1xuICAgICAgICB0aGlzLnR5cGVkQXJyYXkuc2V0U2l6ZSggc2l6ZSApO1xuICAgIH1cblxuICAgIC8vIFRoaXMgY29uZGl0aW9uIHNob3VsZCBvbmx5IG9jY3VyIG9uY2UgaW4gYW4gYXR0cmlidXRlJ3MgbGlmZWN5Y2xlLlxuICAgIGVsc2UgaWYgKCB0aGlzLnR5cGVkQXJyYXkgPT09IG51bGwgKSB7XG4gICAgICAgIHRoaXMudHlwZWRBcnJheSA9IG5ldyBTUEUuVHlwZWRBcnJheUhlbHBlciggdGhpcy5hcnJheVR5cGUsIHNpemUsIHRoaXMuY29tcG9uZW50U2l6ZSApO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgVEhSRUUuQnVmZmVyQXR0cmlidXRlIGluc3RhbmNlIGlmIG9uZSBkb2Vzbid0IGV4aXN0IGFscmVhZHkuXG4gKlxuICogRW5zdXJlcyBhIHR5cGVkIGFycmF5IGlzIHByZXNlbnQgYnkgY2FsbGluZyBfZW5zdXJlVHlwZWRBcnJheSgpIGZpcnN0LlxuICpcbiAqIElmIGEgYnVmZmVyIGF0dHJpYnV0ZSBleGlzdHMgYWxyZWFkeSwgdGhlbiBpdCB3aWxsIGJlIG1hcmtlZCBhcyBuZWVkaW5nIGFuIHVwZGF0ZS5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNpemUgVGhlIHNpemUgb2YgdGhlIHR5cGVkIGFycmF5IHRvIGNyZWF0ZSBpZiBvbmUgZG9lc24ndCBleGlzdCwgb3IgcmVzaXplIGV4aXN0aW5nIGFycmF5IHRvLlxuICovXG5TUEUuU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5fY3JlYXRlQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24oIHNpemUgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0eXBlZEFycmF5IGlzIHByZXNlbnQgYW5kIGNvcnJlY3QuXG4gICAgdGhpcy5fZW5zdXJlVHlwZWRBcnJheSggc2l6ZSApO1xuXG4gICAgLy8gRG9uJ3QgY3JlYXRlIGl0IGlmIGl0IGFscmVhZHkgZXhpc3RzLCBidXQgZG9cbiAgICAvLyBmbGFnIHRoYXQgaXQgbmVlZHMgdXBkYXRpbmcgb24gdGhlIG5leHQgcmVuZGVyXG4gICAgLy8gY3ljbGUuXG4gICAgaWYgKCB0aGlzLmJ1ZmZlckF0dHJpYnV0ZSAhPT0gbnVsbCApIHtcbiAgICAgICAgdGhpcy5idWZmZXJBdHRyaWJ1dGUuYXJyYXkgPSB0aGlzLnR5cGVkQXJyYXkuYXJyYXk7XG4gICAgICAgIHRoaXMuYnVmZmVyQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyQXR0cmlidXRlID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdGhpcy50eXBlZEFycmF5LmFycmF5LCB0aGlzLmNvbXBvbmVudFNpemUgKTtcbiAgICB0aGlzLmJ1ZmZlckF0dHJpYnV0ZS5keW5hbWljID0gdGhpcy5keW5hbWljQnVmZmVyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHR5cGVkIGFycmF5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGF0dHJpYnV0ZS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgdHlwZWQgYXJyYXkuIFdpbGwgYmUgMCBpZiBubyB0eXBlZCBhcnJheSBoYXMgYmVlbiBjcmVhdGVkIHlldC5cbiAqL1xuU1BFLlNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKCB0aGlzLnR5cGVkQXJyYXkgPT09IG51bGwgKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnR5cGVkQXJyYXkuYXJyYXkubGVuZ3RoO1xufTtcblxuU1BFLnNoYWRlckNodW5rcyA9IHtcbiAgICAvLyBSZWdpc3RlciBjb2xvci1wYWNraW5nIGRlZmluZSBzdGF0ZW1lbnRzLlxuICAgIGRlZmluZXM6IFtcbiAgICAgICAgJyNkZWZpbmUgUEFDS0VEX0NPTE9SX1NJWkUgMjU2LjAnLFxuICAgICAgICAnI2RlZmluZSBQQUNLRURfQ09MT1JfRElWSVNPUiAyNTUuMCdcbiAgICBdLmpvaW4oICdcXG4nICksXG5cbiAgICAvLyBBbGwgdW5pZm9ybXMgdXNlZCBieSB2ZXJ0ZXggLyBmcmFnbWVudCBzaGFkZXJzXG4gICAgdW5pZm9ybXM6IFtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZGVsdGFUaW1lOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHJ1blRpbWU7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB0ZXh0dXJlQW5pbWF0aW9uOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHNjYWxlOycsXG4gICAgXS5qb2luKCAnXFxuJyApLFxuXG4gICAgLy8gQWxsIGF0dHJpYnV0ZXMgdXNlZCBieSB0aGUgdmVydGV4IHNoYWRlci5cbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCBzb21lIGF0dHJpYnV0ZXMgYXJlIHNxdWFzaGVkIGludG8gb3RoZXIgb25lczpcbiAgICAvL1xuICAgIC8vICogRHJhZyBpcyBhY2NlbGVyYXRpb24ud1xuICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFjY2VsZXJhdGlvbjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzMgdmVsb2NpdHk7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IHJvdGF0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMyByb3RhdGlvbkNlbnRlcjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzQgcGFyYW1zOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjNCBzaXplOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhbmdsZTsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzQgY29sb3I7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IG9wYWNpdHk7J1xuICAgIF0uam9pbiggJ1xcbicgKSxcblxuICAgIC8vXG4gICAgdmFyeWluZ3M6IFtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJyNpZmRlZiBTSE9VTERfUk9UQVRFX1RFWFRVUkUnLFxuICAgICAgICAnICAgIHZhcnlpbmcgZmxvYXQgdkFuZ2xlOycsXG4gICAgICAgICcjZW5kaWYnLFxuXG4gICAgICAgICcjaWZkZWYgU0hPVUxEX0NBTENVTEFURV9TUFJJVEUnLFxuICAgICAgICAnICAgIHZhcnlpbmcgdmVjNCB2U3ByaXRlU2hlZXQ7JyxcbiAgICAgICAgJyNlbmRpZidcbiAgICBdLmpvaW4oICdcXG4nICksXG5cblxuICAgIC8vIEJyYW5jaC1hdm9pZGluZyBjb21wYXJpc29uIGZuc1xuICAgIC8vIC0gaHR0cDovL3RoZW9yYW5nZWR1Y2suY29tL3BhZ2UvYXZvaWRpbmctc2hhZGVyLWNvbmRpdGlvbmFsc1xuICAgIGJyYW5jaEF2b2lkYW5jZUZ1bmN0aW9uczogW1xuICAgICAgICAnZmxvYXQgd2hlbl9ndChmbG9hdCB4LCBmbG9hdCB5KSB7JyxcbiAgICAgICAgJyAgICByZXR1cm4gbWF4KHNpZ24oeCAtIHkpLCAwLjApOycsXG4gICAgICAgICd9JyxcblxuICAgICAgICAnZmxvYXQgd2hlbl9sdChmbG9hdCB4LCBmbG9hdCB5KSB7JyxcbiAgICAgICAgJyAgICByZXR1cm4gbWluKCBtYXgoMS4wIC0gc2lnbih4IC0geSksIDAuMCksIDEuMCApOycsXG4gICAgICAgICd9JyxcblxuICAgICAgICAnZmxvYXQgd2hlbl9lcSggZmxvYXQgeCwgZmxvYXQgeSApIHsnLFxuICAgICAgICAnICAgIHJldHVybiAxLjAgLSBhYnMoIHNpZ24oIHggLSB5ICkgKTsnLFxuICAgICAgICAnfScsXG5cbiAgICAgICAgJ2Zsb2F0IHdoZW5fZ2UoZmxvYXQgeCwgZmxvYXQgeSkgeycsXG4gICAgICAgICcgIHJldHVybiAxLjAgLSB3aGVuX2x0KHgsIHkpOycsXG4gICAgICAgICd9JyxcblxuICAgICAgICAnZmxvYXQgd2hlbl9sZShmbG9hdCB4LCBmbG9hdCB5KSB7JyxcbiAgICAgICAgJyAgcmV0dXJuIDEuMCAtIHdoZW5fZ3QoeCwgeSk7JyxcbiAgICAgICAgJ30nLFxuXG4gICAgICAgIC8vIEJyYW5jaC1hdm9pZGluZyBsb2dpY2FsIG9wZXJhdG9yc1xuICAgICAgICAvLyAodG8gYmUgdXNlZCB3aXRoIGFib3ZlIGNvbXBhcmlzb24gZm5zKVxuICAgICAgICAnZmxvYXQgYW5kKGZsb2F0IGEsIGZsb2F0IGIpIHsnLFxuICAgICAgICAnICAgIHJldHVybiBhICogYjsnLFxuICAgICAgICAnfScsXG5cbiAgICAgICAgJ2Zsb2F0IG9yKGZsb2F0IGEsIGZsb2F0IGIpIHsnLFxuICAgICAgICAnICAgIHJldHVybiBtaW4oYSArIGIsIDEuMCk7JyxcbiAgICAgICAgJ30nLFxuICAgIF0uam9pbiggJ1xcbicgKSxcblxuXG4gICAgLy8gRnJvbTpcbiAgICAvLyAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEyNTUzMTQ5XG4gICAgLy8gLSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMjg5NTIzNy9oZXhhZGVjaW1hbC10by1yZ2ItdmFsdWVzLWluLXdlYmdsLXNoYWRlclxuICAgIHVucGFja0NvbG9yOiBbXG4gICAgICAgICd2ZWMzIHVucGFja0NvbG9yKCBpbiBmbG9hdCBoZXggKSB7JyxcbiAgICAgICAgJyAgIHZlYzMgYyA9IHZlYzMoIDAuMCApOycsXG5cbiAgICAgICAgJyAgIGZsb2F0IHIgPSBtb2QoIChoZXggLyBQQUNLRURfQ09MT1JfU0laRSAvIFBBQ0tFRF9DT0xPUl9TSVpFKSwgUEFDS0VEX0NPTE9SX1NJWkUgKTsnLFxuICAgICAgICAnICAgZmxvYXQgZyA9IG1vZCggKGhleCAvIFBBQ0tFRF9DT0xPUl9TSVpFKSwgUEFDS0VEX0NPTE9SX1NJWkUgKTsnLFxuICAgICAgICAnICAgZmxvYXQgYiA9IG1vZCggaGV4LCBQQUNLRURfQ09MT1JfU0laRSApOycsXG5cbiAgICAgICAgJyAgIGMuciA9IHIgLyBQQUNLRURfQ09MT1JfRElWSVNPUjsnLFxuICAgICAgICAnICAgYy5nID0gZyAvIFBBQ0tFRF9DT0xPUl9ESVZJU09SOycsXG4gICAgICAgICcgICBjLmIgPSBiIC8gUEFDS0VEX0NPTE9SX0RJVklTT1I7JyxcblxuICAgICAgICAnICAgcmV0dXJuIGM7JyxcbiAgICAgICAgJ30nLFxuICAgIF0uam9pbiggJ1xcbicgKSxcblxuICAgIHVucGFja1JvdGF0aW9uQXhpczogW1xuICAgICAgICAndmVjMyB1bnBhY2tSb3RhdGlvbkF4aXMoIGluIGZsb2F0IGhleCApIHsnLFxuICAgICAgICAnICAgdmVjMyBjID0gdmVjMyggMC4wICk7JyxcblxuICAgICAgICAnICAgZmxvYXQgciA9IG1vZCggKGhleCAvIFBBQ0tFRF9DT0xPUl9TSVpFIC8gUEFDS0VEX0NPTE9SX1NJWkUpLCBQQUNLRURfQ09MT1JfU0laRSApOycsXG4gICAgICAgICcgICBmbG9hdCBnID0gbW9kKCAoaGV4IC8gUEFDS0VEX0NPTE9SX1NJWkUpLCBQQUNLRURfQ09MT1JfU0laRSApOycsXG4gICAgICAgICcgICBmbG9hdCBiID0gbW9kKCBoZXgsIFBBQ0tFRF9DT0xPUl9TSVpFICk7JyxcblxuICAgICAgICAnICAgYy5yID0gciAvIFBBQ0tFRF9DT0xPUl9ESVZJU09SOycsXG4gICAgICAgICcgICBjLmcgPSBnIC8gUEFDS0VEX0NPTE9SX0RJVklTT1I7JyxcbiAgICAgICAgJyAgIGMuYiA9IGIgLyBQQUNLRURfQ09MT1JfRElWSVNPUjsnLFxuXG4gICAgICAgICcgICBjICo9IHZlYzMoIDIuMCApOycsXG4gICAgICAgICcgICBjIC09IHZlYzMoIDEuMCApOycsXG5cbiAgICAgICAgJyAgIHJldHVybiBjOycsXG4gICAgICAgICd9JyxcbiAgICBdLmpvaW4oICdcXG4nICksXG5cbiAgICBmbG9hdE92ZXJMaWZldGltZTogW1xuICAgICAgICAnZmxvYXQgZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIGluIGZsb2F0IHBvc2l0aW9uSW5UaW1lLCBpbiB2ZWM0IGF0dHIgKSB7JyxcbiAgICAgICAgJyAgICBoaWdocCBmbG9hdCB2YWx1ZSA9IDAuMDsnLFxuICAgICAgICAnICAgIGZsb2F0IGRlbHRhQWdlID0gcG9zaXRpb25JblRpbWUgKiBmbG9hdCggVkFMVUVfT1ZFUl9MSUZFVElNRV9MRU5HVEggLSAxICk7JyxcbiAgICAgICAgJyAgICBmbG9hdCBmSW5kZXggPSAwLjA7JyxcbiAgICAgICAgJyAgICBmbG9hdCBzaG91bGRBcHBseVZhbHVlID0gMC4wOycsXG5cbiAgICAgICAgLy8gVGhpcyBtaWdodCBsb29rIGEgbGl0dGxlIG9kZCwgYnV0IGl0J3MgZmFzdGVyIGluIHRoZSB0ZXN0aW5nIEkndmUgZG9uZSB0aGFuIHVzaW5nIGJyYW5jaGVzLlxuICAgICAgICAvLyBVc2VzIGJhc2ljIG1hdGhzIHRvIGF2b2lkIGJyYW5jaGluZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGFrZSBhIGxvb2sgYXQgdGhlIGJyYW5jaC1hdm9pZGFuY2UgZnVuY3Rpb25zIGRlZmluZWQgYWJvdmUsXG4gICAgICAgIC8vIGFuZCBiZSBzdXJlIHRvIGNoZWNrIG91dCBUaGUgT3JhbmdlIER1Y2sgc2l0ZSB3aGVyZSBJIGdvdCB0aGlzXG4gICAgICAgIC8vIGZyb20gKGxpbmsgYWJvdmUpLlxuXG4gICAgICAgIC8vIEZpeCBmb3Igc3RhdGljIGVtaXR0ZXJzIChhZ2UgaXMgYWx3YXlzIHplcm8pLlxuICAgICAgICAnICAgIHZhbHVlICs9IGF0dHJbIDAgXSAqIHdoZW5fZXEoIGRlbHRhQWdlLCAwLjAgKTsnLFxuICAgICAgICAnJyxcbiAgICAgICAgJyAgICBmb3IoIGludCBpID0gMDsgaSA8IFZBTFVFX09WRVJfTElGRVRJTUVfTEVOR1RIIC0gMTsgKytpICkgeycsXG4gICAgICAgICcgICAgICAgZkluZGV4ID0gZmxvYXQoIGkgKTsnLFxuICAgICAgICAnICAgICAgIHNob3VsZEFwcGx5VmFsdWUgPSBhbmQoIHdoZW5fZ3QoIGRlbHRhQWdlLCBmSW5kZXggKSwgd2hlbl9sZSggZGVsdGFBZ2UsIGZJbmRleCArIDEuMCApICk7JyxcbiAgICAgICAgJyAgICAgICB2YWx1ZSArPSBzaG91bGRBcHBseVZhbHVlICogbWl4KCBhdHRyWyBpIF0sIGF0dHJbIGkgKyAxIF0sIGRlbHRhQWdlIC0gZkluZGV4ICk7JyxcbiAgICAgICAgJyAgICB9JyxcbiAgICAgICAgJycsXG4gICAgICAgICcgICAgcmV0dXJuIHZhbHVlOycsXG4gICAgICAgICd9JyxcbiAgICBdLmpvaW4oICdcXG4nICksXG5cbiAgICBjb2xvck92ZXJMaWZldGltZTogW1xuICAgICAgICAndmVjMyBnZXRDb2xvck92ZXJMaWZldGltZSggaW4gZmxvYXQgcG9zaXRpb25JblRpbWUsIGluIHZlYzMgY29sb3IxLCBpbiB2ZWMzIGNvbG9yMiwgaW4gdmVjMyBjb2xvcjMsIGluIHZlYzMgY29sb3I0ICkgeycsXG4gICAgICAgICcgICAgdmVjMyB2YWx1ZSA9IHZlYzMoIDAuMCApOycsXG4gICAgICAgICcgICAgdmFsdWUueCA9IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgdmVjNCggY29sb3IxLngsIGNvbG9yMi54LCBjb2xvcjMueCwgY29sb3I0LnggKSApOycsXG4gICAgICAgICcgICAgdmFsdWUueSA9IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgdmVjNCggY29sb3IxLnksIGNvbG9yMi55LCBjb2xvcjMueSwgY29sb3I0LnkgKSApOycsXG4gICAgICAgICcgICAgdmFsdWUueiA9IGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgdmVjNCggY29sb3IxLnosIGNvbG9yMi56LCBjb2xvcjMueiwgY29sb3I0LnogKSApOycsXG4gICAgICAgICcgICAgcmV0dXJuIHZhbHVlOycsXG4gICAgICAgICd9JyxcbiAgICBdLmpvaW4oICdcXG4nICksXG5cbiAgICBwYXJhbUZldGNoaW5nRnVuY3Rpb25zOiBbXG4gICAgICAgICdmbG9hdCBnZXRBbGl2ZSgpIHsnLFxuICAgICAgICAnICAgcmV0dXJuIHBhcmFtcy54OycsXG4gICAgICAgICd9JyxcblxuICAgICAgICAnZmxvYXQgZ2V0QWdlKCkgeycsXG4gICAgICAgICcgICByZXR1cm4gcGFyYW1zLnk7JyxcbiAgICAgICAgJ30nLFxuXG4gICAgICAgICdmbG9hdCBnZXRNYXhBZ2UoKSB7JyxcbiAgICAgICAgJyAgIHJldHVybiBwYXJhbXMuejsnLFxuICAgICAgICAnfScsXG5cbiAgICAgICAgJ2Zsb2F0IGdldFdpZ2dsZSgpIHsnLFxuICAgICAgICAnICAgcmV0dXJuIHBhcmFtcy53OycsXG4gICAgICAgICd9JyxcbiAgICBdLmpvaW4oICdcXG4nICksXG5cbiAgICBmb3JjZUZldGNoaW5nRnVuY3Rpb25zOiBbXG4gICAgICAgICd2ZWM0IGdldFBvc2l0aW9uKCBpbiBmbG9hdCBhZ2UgKSB7JyxcbiAgICAgICAgJyAgIHJldHVybiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7JyxcbiAgICAgICAgJ30nLFxuXG4gICAgICAgICd2ZWMzIGdldFZlbG9jaXR5KCBpbiBmbG9hdCBhZ2UgKSB7JyxcbiAgICAgICAgJyAgIHJldHVybiB2ZWxvY2l0eSAqIGFnZTsnLFxuICAgICAgICAnfScsXG5cbiAgICAgICAgJ3ZlYzMgZ2V0QWNjZWxlcmF0aW9uKCBpbiBmbG9hdCBhZ2UgKSB7JyxcbiAgICAgICAgJyAgIHJldHVybiBhY2NlbGVyYXRpb24ueHl6ICogYWdlOycsXG4gICAgICAgICd9JyxcbiAgICBdLmpvaW4oICdcXG4nICksXG5cblxuICAgIHJvdGF0aW9uRnVuY3Rpb25zOiBbXG4gICAgICAgIC8vIEh1Z2UgdGhhbmtzIHRvOlxuICAgICAgICAvLyAtIGh0dHA6Ly93d3cubmVpbG1lbmRvemEuY29tL2dsc2wtcm90YXRpb24tYWJvdXQtYW4tYXJiaXRyYXJ5LWF4aXMvXG4gICAgICAgICcjaWZkZWYgU0hPVUxEX1JPVEFURV9QQVJUSUNMRVMnLFxuICAgICAgICAnICAgbWF0NCBnZXRSb3RhdGlvbk1hdHJpeCggaW4gdmVjMyBheGlzLCBpbiBmbG9hdCBhbmdsZSkgeycsXG4gICAgICAgICcgICAgICAgYXhpcyA9IG5vcm1hbGl6ZShheGlzKTsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpOycsXG4gICAgICAgICcgICAgICAgZmxvYXQgYyA9IGNvcyhhbmdsZSk7JyxcbiAgICAgICAgJyAgICAgICBmbG9hdCBvYyA9IDEuMCAtIGM7JyxcbiAgICAgICAgJycsXG4gICAgICAgICcgICAgICAgcmV0dXJuIG1hdDQob2MgKiBheGlzLnggKiBheGlzLnggKyBjLCAgICAgICAgICAgb2MgKiBheGlzLnggKiBheGlzLnkgLSBheGlzLnogKiBzLCAgb2MgKiBheGlzLnogKiBheGlzLnggKyBheGlzLnkgKiBzLCAgMC4wLCcsXG4gICAgICAgICcgICAgICAgICAgICAgICAgICAgb2MgKiBheGlzLnggKiBheGlzLnkgKyBheGlzLnogKiBzLCAgb2MgKiBheGlzLnkgKiBheGlzLnkgKyBjLCAgICAgICAgICAgb2MgKiBheGlzLnkgKiBheGlzLnogLSBheGlzLnggKiBzLCAgMC4wLCcsXG4gICAgICAgICcgICAgICAgICAgICAgICAgICAgb2MgKiBheGlzLnogKiBheGlzLnggLSBheGlzLnkgKiBzLCAgb2MgKiBheGlzLnkgKiBheGlzLnogKyBheGlzLnggKiBzLCAgb2MgKiBheGlzLnogKiBheGlzLnogKyBjLCAgICAgICAgICAgMC4wLCcsXG4gICAgICAgICcgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wKTsnLFxuICAgICAgICAnICAgfScsXG4gICAgICAgICcnLFxuICAgICAgICAnICAgdmVjMyBnZXRSb3RhdGlvbiggaW4gdmVjMyBwb3MsIGluIGZsb2F0IHBvc2l0aW9uSW5UaW1lICkgeycsXG4gICAgICAgICcgICAgICBpZiggcm90YXRpb24ueSA9PSAwLjAgKSB7JyxcbiAgICAgICAgJyAgICAgICAgICAgcmV0dXJuIHBvczsnLFxuICAgICAgICAnICAgICAgfScsXG4gICAgICAgICcnLFxuICAgICAgICAnICAgICAgdmVjMyBheGlzID0gdW5wYWNrUm90YXRpb25BeGlzKCByb3RhdGlvbi54ICk7JyxcbiAgICAgICAgJyAgICAgIHZlYzMgY2VudGVyID0gcm90YXRpb25DZW50ZXI7JyxcbiAgICAgICAgJyAgICAgIHZlYzMgdHJhbnNsYXRlZDsnLFxuICAgICAgICAnICAgICAgbWF0NCByb3RhdGlvbk1hdHJpeDsnLFxuXG4gICAgICAgICcgICAgICBmbG9hdCBhbmdsZSA9IDAuMDsnLFxuICAgICAgICAnICAgICAgYW5nbGUgKz0gd2hlbl9lcSggcm90YXRpb24ueiwgMC4wICkgKiByb3RhdGlvbi55OycsXG4gICAgICAgICcgICAgICBhbmdsZSArPSB3aGVuX2d0KCByb3RhdGlvbi56LCAwLjAgKSAqIG1peCggMC4wLCByb3RhdGlvbi55LCBwb3NpdGlvbkluVGltZSApOycsXG4gICAgICAgICcgICAgICB0cmFuc2xhdGVkID0gcm90YXRpb25DZW50ZXIgLSBwb3M7JyxcbiAgICAgICAgJyAgICAgIHJvdGF0aW9uTWF0cml4ID0gZ2V0Um90YXRpb25NYXRyaXgoIGF4aXMsIGFuZ2xlICk7JyxcbiAgICAgICAgJyAgICAgIHJldHVybiBjZW50ZXIgLSB2ZWMzKCByb3RhdGlvbk1hdHJpeCAqIHZlYzQoIHRyYW5zbGF0ZWQsIDAuMCApICk7JyxcbiAgICAgICAgJyAgIH0nLFxuICAgICAgICAnI2VuZGlmJ1xuICAgIF0uam9pbiggJ1xcbicgKSxcblxuXG4gICAgLy8gRnJhZ21lbnQgY2h1bmtzXG4gICAgcm90YXRlVGV4dHVyZTogW1xuICAgICAgICAnICAgIHZlYzIgdlV2ID0gdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKTsnLFxuICAgICAgICAnJyxcbiAgICAgICAgJyAgICAjaWZkZWYgU0hPVUxEX1JPVEFURV9URVhUVVJFJyxcbiAgICAgICAgJyAgICAgICBmbG9hdCB4ID0gZ2xfUG9pbnRDb29yZC54IC0gMC41OycsXG4gICAgICAgICcgICAgICAgZmxvYXQgeSA9IDEuMCAtIGdsX1BvaW50Q29vcmQueSAtIDAuNTsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IGMgPSBjb3MoIC12QW5nbGUgKTsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IHMgPSBzaW4oIC12QW5nbGUgKTsnLFxuXG4gICAgICAgICcgICAgICAgdlV2ID0gdmVjMiggYyAqIHggKyBzICogeSArIDAuNSwgYyAqIHkgLSBzICogeCArIDAuNSApOycsXG4gICAgICAgICcgICAgI2VuZGlmJyxcbiAgICAgICAgJycsXG5cbiAgICAgICAgLy8gU3ByaXRlc2hlZXRzIG92ZXJ3cml0ZSBhbmdsZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgICcgICAgI2lmZGVmIFNIT1VMRF9DQUxDVUxBVEVfU1BSSVRFJyxcbiAgICAgICAgJyAgICAgICAgZmxvYXQgZnJhbWVzWCA9IHZTcHJpdGVTaGVldC54OycsXG4gICAgICAgICcgICAgICAgIGZsb2F0IGZyYW1lc1kgPSB2U3ByaXRlU2hlZXQueTsnLFxuICAgICAgICAnICAgICAgICBmbG9hdCBjb2x1bW5Ob3JtID0gdlNwcml0ZVNoZWV0Lno7JyxcbiAgICAgICAgJyAgICAgICAgZmxvYXQgcm93Tm9ybSA9IHZTcHJpdGVTaGVldC53OycsXG5cbiAgICAgICAgJyAgICAgICAgdlV2LnggPSBnbF9Qb2ludENvb3JkLnggKiBmcmFtZXNYICsgY29sdW1uTm9ybTsnLFxuICAgICAgICAnICAgICAgICB2VXYueSA9IDEuMCAtIChnbF9Qb2ludENvb3JkLnkgKiBmcmFtZXNZICsgcm93Tm9ybSk7JyxcbiAgICAgICAgJyAgICAjZW5kaWYnLFxuXG4gICAgICAgICcnLFxuICAgICAgICAnICAgIHZlYzQgcm90YXRlZFRleHR1cmUgPSB0ZXh0dXJlMkQoIHRleHR1cmUsIHZVdiApOycsXG4gICAgXS5qb2luKCAnXFxuJyApXG59O1xuXG5TUEUuc2hhZGVycyA9IHtcbiAgICB2ZXJ0ZXg6IFtcbiAgICAgICAgU1BFLnNoYWRlckNodW5rcy5kZWZpbmVzLFxuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLnVuaWZvcm1zLFxuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLmF0dHJpYnV0ZXMsXG4gICAgICAgIFNQRS5zaGFkZXJDaHVua3MudmFyeWluZ3MsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX3BhcnNfdmVydGV4LFxuICAgICAgICBcbiAgICAgICAgU1BFLnNoYWRlckNodW5rcy5icmFuY2hBdm9pZGFuY2VGdW5jdGlvbnMsXG4gICAgICAgIFNQRS5zaGFkZXJDaHVua3MudW5wYWNrQ29sb3IsXG4gICAgICAgIFNQRS5zaGFkZXJDaHVua3MudW5wYWNrUm90YXRpb25BeGlzLFxuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLmZsb2F0T3ZlckxpZmV0aW1lLFxuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLmNvbG9yT3ZlckxpZmV0aW1lLFxuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLnBhcmFtRmV0Y2hpbmdGdW5jdGlvbnMsXG4gICAgICAgIFNQRS5zaGFkZXJDaHVua3MuZm9yY2VGZXRjaGluZ0Z1bmN0aW9ucyxcbiAgICAgICAgU1BFLnNoYWRlckNodW5rcy5yb3RhdGlvbkZ1bmN0aW9ucyxcblxuXG4gICAgICAgICd2b2lkIG1haW4oKSB7JyxcblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNldHVwLi4uXG4gICAgICAgIC8vXG4gICAgICAgICcgICAgaGlnaHAgZmxvYXQgYWdlID0gZ2V0QWdlKCk7JyxcbiAgICAgICAgJyAgICBoaWdocCBmbG9hdCBhbGl2ZSA9IGdldEFsaXZlKCk7JyxcbiAgICAgICAgJyAgICBoaWdocCBmbG9hdCBtYXhBZ2UgPSBnZXRNYXhBZ2UoKTsnLFxuICAgICAgICAnICAgIGhpZ2hwIGZsb2F0IHBvc2l0aW9uSW5UaW1lID0gKGFnZSAvIG1heEFnZSk7JyxcbiAgICAgICAgJyAgICBoaWdocCBmbG9hdCBpc0FsaXZlID0gd2hlbl9ndCggYWxpdmUsIDAuMCApOycsXG5cbiAgICAgICAgJyAgICAjaWZkZWYgU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVMnLFxuICAgICAgICAnICAgICAgICBmbG9hdCB3aWdnbGVBbW91bnQgPSBwb3NpdGlvbkluVGltZSAqIGdldFdpZ2dsZSgpOycsXG4gICAgICAgICcgICAgICAgIGZsb2F0IHdpZ2dsZVNpbiA9IGlzQWxpdmUgKiBzaW4oIHdpZ2dsZUFtb3VudCApOycsXG4gICAgICAgICcgICAgICAgIGZsb2F0IHdpZ2dsZUNvcyA9IGlzQWxpdmUgKiBjb3MoIHdpZ2dsZUFtb3VudCApOycsXG4gICAgICAgICcgICAgI2VuZGlmJyxcblxuICAgICAgICAvL1xuICAgICAgICAvLyBGb3JjZXNcbiAgICAgICAgLy9cblxuICAgICAgICAvLyBHZXQgZm9yY2VzICYgcG9zaXRpb25cbiAgICAgICAgJyAgICB2ZWMzIHZlbCA9IGdldFZlbG9jaXR5KCBhZ2UgKTsnLFxuICAgICAgICAnICAgIHZlYzMgYWNjZWwgPSBnZXRBY2NlbGVyYXRpb24oIGFnZSApOycsXG4gICAgICAgICcgICAgdmVjMyBmb3JjZSA9IHZlYzMoIDAuMCApOycsXG4gICAgICAgICcgICAgdmVjMyBwb3MgPSB2ZWMzKCBwb3NpdGlvbiApOycsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZXF1aXJlZCBkcmFnIHRvIGFwcGx5IHRvIHRoZSBmb3JjZXMuXG4gICAgICAgICcgICAgZmxvYXQgZHJhZyA9IDEuMCAtIChwb3NpdGlvbkluVGltZSAqIDAuNSkgKiBhY2NlbGVyYXRpb24udzsnLFxuXG4gICAgICAgIC8vIEludGVncmF0ZSBmb3JjZXMuLi5cbiAgICAgICAgJyAgICBmb3JjZSArPSB2ZWw7JyxcbiAgICAgICAgJyAgICBmb3JjZSAqPSBkcmFnOycsXG4gICAgICAgICcgICAgZm9yY2UgKz0gYWNjZWwgKiBhZ2U7JyxcbiAgICAgICAgJyAgICBwb3MgKz0gZm9yY2U7JyxcblxuXG4gICAgICAgIC8vIFdpZ2dseSB3aWdnbHkgd2lnZ2xlIVxuICAgICAgICAnICAgICNpZmRlZiBTSE9VTERfV0lHR0xFX1BBUlRJQ0xFUycsXG4gICAgICAgICcgICAgICAgIHBvcy54ICs9IHdpZ2dsZVNpbjsnLFxuICAgICAgICAnICAgICAgICBwb3MueSArPSB3aWdnbGVDb3M7JyxcbiAgICAgICAgJyAgICAgICAgcG9zLnogKz0gd2lnZ2xlU2luOycsXG4gICAgICAgICcgICAgI2VuZGlmJyxcblxuXG4gICAgICAgIC8vIFJvdGF0ZSB0aGUgZW1pdHRlciBhcm91bmQgaXQncyBjZW50cmFsIHBvaW50XG4gICAgICAgICcgICAgI2lmZGVmIFNIT1VMRF9ST1RBVEVfUEFSVElDTEVTJyxcbiAgICAgICAgJyAgICAgICAgcG9zID0gZ2V0Um90YXRpb24oIHBvcywgcG9zaXRpb25JblRpbWUgKTsnLFxuICAgICAgICAnICAgICNlbmRpZicsXG5cbiAgICAgICAgLy8gQ29udmVydCBwb3MgdG8gYSB3b3JsZC1zcGFjZSB2YWx1ZVxuICAgICAgICAnICAgIHZlYzQgbXZQb3MgPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MsIDEuMCApOycsXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHBvaW50IHNpemUuXG4gICAgICAgICcgICAgaGlnaHAgZmxvYXQgcG9pbnRTaXplID0gZ2V0RmxvYXRPdmVyTGlmZXRpbWUoIHBvc2l0aW9uSW5UaW1lLCBzaXplICkgKiBpc0FsaXZlOycsXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHBlcnNwZWN0aXZlXG4gICAgICAgICcgICAgI2lmZGVmIEhBU19QRVJTUEVDVElWRScsXG4gICAgICAgICcgICAgICAgIGZsb2F0IHBlcnNwZWN0aXZlID0gc2NhbGUgLyBsZW5ndGgoIG12UG9zLnh5eiApOycsXG4gICAgICAgICcgICAgI2Vsc2UnLFxuICAgICAgICAnICAgICAgICBmbG9hdCBwZXJzcGVjdGl2ZSA9IDEuMDsnLFxuICAgICAgICAnICAgICNlbmRpZicsXG5cbiAgICAgICAgLy8gQXBwbHkgcGVycGVjdGl2ZSB0byBwb2ludFNpemUgdmFsdWVcbiAgICAgICAgJyAgICBmbG9hdCBwb2ludFNpemVQZXJzcGVjdGl2ZSA9IHBvaW50U2l6ZSAqIHBlcnNwZWN0aXZlOycsXG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBBcHBlYXJhbmNlXG4gICAgICAgIC8vXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGNvbG9yIGFuZCBvcGFjaXR5IGZvciB0aGlzIHBhcnRpY2xlXG4gICAgICAgICcgICAgI2lmZGVmIENPTE9SSVpFJyxcbiAgICAgICAgJyAgICAgICB2ZWMzIGMgPSBpc0FsaXZlICogZ2V0Q29sb3JPdmVyTGlmZXRpbWUoJyxcbiAgICAgICAgJyAgICAgICAgICAgcG9zaXRpb25JblRpbWUsJyxcbiAgICAgICAgJyAgICAgICAgICAgdW5wYWNrQ29sb3IoIGNvbG9yLnggKSwnLFxuICAgICAgICAnICAgICAgICAgICB1bnBhY2tDb2xvciggY29sb3IueSApLCcsXG4gICAgICAgICcgICAgICAgICAgIHVucGFja0NvbG9yKCBjb2xvci56ICksJyxcbiAgICAgICAgJyAgICAgICAgICAgdW5wYWNrQ29sb3IoIGNvbG9yLncgKScsXG4gICAgICAgICcgICAgICAgKTsnLFxuICAgICAgICAnICAgICNlbHNlJyxcbiAgICAgICAgJyAgICAgICB2ZWMzIGMgPSB2ZWMzKDEuMCk7JyxcbiAgICAgICAgJyAgICAjZW5kaWYnLFxuXG4gICAgICAgICcgICAgZmxvYXQgbyA9IGlzQWxpdmUgKiBnZXRGbG9hdE92ZXJMaWZldGltZSggcG9zaXRpb25JblRpbWUsIG9wYWNpdHkgKTsnLFxuXG4gICAgICAgIC8vIEFzc2lnbiBjb2xvciB0byB2Q29sb3IgdmFyeWluZy5cbiAgICAgICAgJyAgICB2Q29sb3IgPSB2ZWM0KCBjLCBvICk7JyxcblxuICAgICAgICAvLyBEZXRlcm1pbmUgYW5nbGVcbiAgICAgICAgJyAgICAjaWZkZWYgU0hPVUxEX1JPVEFURV9URVhUVVJFJyxcbiAgICAgICAgJyAgICAgICAgdkFuZ2xlID0gaXNBbGl2ZSAqIGdldEZsb2F0T3ZlckxpZmV0aW1lKCBwb3NpdGlvbkluVGltZSwgYW5nbGUgKTsnLFxuICAgICAgICAnICAgICNlbmRpZicsXG5cbiAgICAgICAgLy8gSWYgdGhpcyBwYXJ0aWNsZSBpcyB1c2luZyBhIHNwcml0ZS1zaGVldCBhcyBhIHRleHR1cmUsIHdlJ2xsIGhhdmUgdG8gZmlndXJlIG91dFxuICAgICAgICAvLyB3aGF0IGZyYW1lIG9mIHRoZSB0ZXh0dXJlIHRoZSBwYXJ0aWNsZSBpcyB1c2luZyBhdCBpdCdzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGltZS5cbiAgICAgICAgJyAgICAjaWZkZWYgU0hPVUxEX0NBTENVTEFURV9TUFJJVEUnLFxuICAgICAgICAnICAgICAgICBmbG9hdCBmcmFtZXNYID0gdGV4dHVyZUFuaW1hdGlvbi54OycsXG4gICAgICAgICcgICAgICAgIGZsb2F0IGZyYW1lc1kgPSB0ZXh0dXJlQW5pbWF0aW9uLnk7JyxcbiAgICAgICAgJyAgICAgICAgZmxvYXQgbG9vcENvdW50ID0gdGV4dHVyZUFuaW1hdGlvbi53OycsXG4gICAgICAgICcgICAgICAgIGZsb2F0IHRvdGFsRnJhbWVzID0gdGV4dHVyZUFuaW1hdGlvbi56OycsXG4gICAgICAgICcgICAgICAgIGZsb2F0IGZyYW1lTnVtYmVyID0gbW9kKCAocG9zaXRpb25JblRpbWUgKiBsb29wQ291bnQpICogdG90YWxGcmFtZXMsIHRvdGFsRnJhbWVzICk7JyxcblxuICAgICAgICAnICAgICAgICBmbG9hdCBjb2x1bW4gPSBmbG9vcihtb2QoIGZyYW1lTnVtYmVyLCBmcmFtZXNYICkpOycsXG4gICAgICAgICcgICAgICAgIGZsb2F0IHJvdyA9IGZsb29yKCAoZnJhbWVOdW1iZXIgLSBjb2x1bW4pIC8gZnJhbWVzWCApOycsXG5cbiAgICAgICAgJyAgICAgICAgZmxvYXQgY29sdW1uTm9ybSA9IGNvbHVtbiAvIGZyYW1lc1g7JyxcbiAgICAgICAgJyAgICAgICAgZmxvYXQgcm93Tm9ybSA9IHJvdyAvIGZyYW1lc1k7JyxcblxuICAgICAgICAnICAgICAgICB2U3ByaXRlU2hlZXQueCA9IDEuMCAvIGZyYW1lc1g7JyxcbiAgICAgICAgJyAgICAgICAgdlNwcml0ZVNoZWV0LnkgPSAxLjAgLyBmcmFtZXNZOycsXG4gICAgICAgICcgICAgICAgIHZTcHJpdGVTaGVldC56ID0gY29sdW1uTm9ybTsnLFxuICAgICAgICAnICAgICAgICB2U3ByaXRlU2hlZXQudyA9IHJvd05vcm07JyxcbiAgICAgICAgJyAgICAjZW5kaWYnLFxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdyaXRlIHZhbHVlc1xuICAgICAgICAvL1xuXG4gICAgICAgIC8vIFNldCBQb2ludFNpemUgYWNjb3JkaW5nIHRvIHNpemUgYXQgY3VycmVudCBwb2ludCBpbiB0aW1lLlxuICAgICAgICAnICAgIGdsX1BvaW50U2l6ZSA9IHBvaW50U2l6ZVBlcnNwZWN0aXZlOycsXG4gICAgICAgICcgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3M7JyxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rLmZvZ192ZXJ0ZXgsXG4gICAgICAgIFxuICAgICAgICAnfSdcbiAgICBdLmpvaW4oICdcXG4nICksXG5cbiAgICBmcmFnbWVudDogW1xuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLnVuaWZvcm1zLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rLmNvbW1vbixcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX3BhcnNfZnJhZ21lbnQsXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG5cbiAgICAgICAgU1BFLnNoYWRlckNodW5rcy52YXJ5aW5ncyxcblxuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLmJyYW5jaEF2b2lkYW5jZUZ1bmN0aW9ucyxcblxuICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICcgICAgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdkNvbG9yLnh5ejsnLFxuICAgICAgICAnICAgICcsXG4gICAgICAgICcgICAgI2lmZGVmIEFMUEhBVEVTVCcsXG4gICAgICAgICcgICAgICAgaWYgKCB2Q29sb3IudyA8IGZsb2F0KEFMUEhBVEVTVCkgKSBkaXNjYXJkOycsXG4gICAgICAgICcgICAgI2VuZGlmJyxcblxuICAgICAgICBTUEUuc2hhZGVyQ2h1bmtzLnJvdGF0ZVRleHR1cmUsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfZnJhZ21lbnQsXG5cbiAgICAgICAgJyAgICBvdXRnb2luZ0xpZ2h0ID0gdkNvbG9yLnh5eiAqIHJvdGF0ZWRUZXh0dXJlLnh5ejsnLFxuXHRcdCcgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodC54eXosIHJvdGF0ZWRUZXh0dXJlLncgKiB2Q29sb3IudyApOycsXG4gICAgICAgIFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsXG5cbiAgICAgICAgJ30nXG4gICAgXS5qb2luKCAnXFxuJyApXG59O1xuXG4vKipcbiAqIEEgYnVuY2ggb2YgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5LlxuICogQG5hbWVzcGFjZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuU1BFLnV0aWxzID0ge1xuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHR5cGVzIHVzZWQgYnkgYFNQRS51dGlscy5lbnN1cmVUeXBlZEFyZ2AgYW5kXG4gICAgICogYFNQRS51dGlscy5lbnN1cmVBcnJheVR5cGVkQXJnYCB0byBjb21wYXJlIHR5cGVzIGFnYWluc3QuXG4gICAgICpcbiAgICAgKiBAZW51bSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHR5cGVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb29sZWFuIHR5cGUuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBCT09MRUFOOiAnYm9vbGVhbicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmluZyB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgU1RSSU5HOiAnc3RyaW5nJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIHR5cGUuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBOVU1CRVI6ICdudW1iZXInLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYmplY3QgdHlwZS5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIE9CSkVDVDogJ29iamVjdCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB2YWx1ZSwgYSB0eXBlLCBhbmQgYSBkZWZhdWx0IHZhbHVlIHRvIGZhbGxiYWNrIHRvLFxuICAgICAqIGVuc3VyZSB0aGUgZ2l2ZW4gYXJndW1lbnQgYWRoZXJlcyB0byB0aGUgdHlwZSByZXF1ZXN0aW5nLFxuICAgICAqIHJldHVybmluZyB0aGUgZGVmYXVsdCB2YWx1ZSBpZiB0eXBlIGNoZWNrIGlzIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7KGJvb2xlYW58c3RyaW5nfG51bWJlcnxvYmplY3QpfSBhcmcgICAgICAgICAgVGhlIHZhbHVlIHRvIHBlcmZvcm0gYSB0eXBlLWNoZWNrIG9uLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgICAgICAgIFRoZSB0eXBlIHRoZSBgYXJnYCBhcmd1bWVudCBzaG91bGQgYWRoZXJlIHRvLlxuICAgICAqIEBwYXJhbSAgeyhib29sZWFufHN0cmluZ3xudW1iZXJ8b2JqZWN0KX0gZGVmYXVsdFZhbHVlIEEgZGVmYXVsdCB2YWx1ZSB0byBmYWxsYmFjayBvbiBpZiB0aGUgdHlwZSBjaGVjayBmYWlscy5cbiAgICAgKiBAcmV0dXJuIHsoYm9vbGVhbnxzdHJpbmd8bnVtYmVyfG9iamVjdCl9ICAgICAgICAgICAgICBUaGUgZ2l2ZW4gdmFsdWUgaWYgdHlwZSBjaGVjayBwYXNzZXMsIG9yIHRoZSBkZWZhdWx0IHZhbHVlIGlmIGl0IGZhaWxzLlxuICAgICAqL1xuICAgIGVuc3VyZVR5cGVkQXJnOiBmdW5jdGlvbiggYXJnLCB0eXBlLCBkZWZhdWx0VmFsdWUgKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBpZiAoIHR5cGVvZiBhcmcgPT09IHR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiB2YWx1ZXMsIGEgdHlwZSwgYW5kIGEgZGVmYXVsdCB2YWx1ZSxcbiAgICAgKiBlbnN1cmUgdGhlIGdpdmVuIGFycmF5J3MgY29udGVudHMgQUxMIGFkaGVyZSB0byB0aGUgcHJvdmlkZWQgdHlwZSxcbiAgICAgKiByZXR1cm5pbmcgdGhlIGRlZmF1bHQgdmFsdWUgaWYgdHlwZSBjaGVjayBmYWlscy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBnaXZlbiB2YWx1ZSB0byBjaGVjayBpc24ndCBhbiBBcnJheSwgZGVsZWdhdGVzIHRvIFNQRS51dGlscy5lbnN1cmVUeXBlZEFyZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fGJvb2xlYW58c3RyaW5nfG51bWJlcnxvYmplY3R9IGFyZyAgICAgICAgICBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGNoZWNrIHR5cGUgb2YuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgICAgICAgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgYWRoZXJlZCB0by5cbiAgICAgKiBAcGFyYW0gIHsoYm9vbGVhbnxzdHJpbmd8bnVtYmVyfG9iamVjdCl9IGRlZmF1bHRWYWx1ZSBBIGRlZmF1bHQgZmFsbGJhY2sgdmFsdWUuXG4gICAgICogQHJldHVybiB7KGJvb2xlYW58c3RyaW5nfG51bWJlcnxvYmplY3QpfSAgICAgICAgICAgICAgVGhlIGdpdmVuIHZhbHVlIGlmIHR5cGUgY2hlY2sgcGFzc2VzLCBvciB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBpdCBmYWlscy5cbiAgICAgKi9cbiAgICBlbnN1cmVBcnJheVR5cGVkQXJnOiBmdW5jdGlvbiggYXJnLCB0eXBlLCBkZWZhdWx0VmFsdWUgKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAvLyBJZiB0aGUgYXJndW1lbnQgYmVpbmcgY2hlY2tlZCBpcyBhbiBhcnJheSwgbG9vcCB0aHJvdWdoXG4gICAgICAgIC8vIGl0IGFuZCBlbnN1cmUgYWxsIHRoZSB2YWx1ZXMgYXJlIG9mIHRoZSBjb3JyZWN0IHR5cGUsXG4gICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdFZhbHVlIGlmIGFueSBhcmVuJ3QuXG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggYXJnICkgKSB7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IGFyZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBhcmdbIGkgXSAhPT0gdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgYXJnIGlzbid0IGFuIGFycmF5IHRoZW4ganVzdCBmYWxsYmFjayB0b1xuICAgICAgICAvLyBjaGVja2luZyB0aGUgdHlwZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlVHlwZWRBcmcoIGFyZywgdHlwZSwgZGVmYXVsdFZhbHVlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGFyZyAgICAgICAgICBUaGUgdmFsdWUgdG8gY2hlY2sgaW5zdGFuY2Ugb2YuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGluc3RhbmNlICAgICBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGluc3RhbmNlIHRvIGNoZWNrIGFnYWluc3QuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkZWZhdWx0VmFsdWUgQSBkZWZhdWx0IGZhbGxiYWNrIHZhbHVlIGlmIGluc3RhbmNlIGNoZWNrIGZhaWxzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgVGhlIGdpdmVuIHZhbHVlIGlmIHR5cGUgY2hlY2sgcGFzc2VzLCBvciB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBpdCBmYWlscy5cbiAgICAgKi9cbiAgICBlbnN1cmVJbnN0YW5jZU9mOiBmdW5jdGlvbiggYXJnLCBpbnN0YW5jZSwgZGVmYXVsdFZhbHVlICkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKCBpbnN0YW5jZSAhPT0gdW5kZWZpbmVkICYmIGFyZyBpbnN0YW5jZW9mIGluc3RhbmNlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgdmFsdWVzLCBlbnN1cmUgdGhlIGluc3RhbmNlcyBvZiBhbGwgaXRlbXMgaW4gdGhlIGFycmF5XG4gICAgICogbWF0Y2hlcyB0aGUgZ2l2ZW4gaW5zdGFuY2UgY29uc3RydWN0b3IgZmFsbGluZyBiYWNrIHRvIGEgZGVmYXVsdCB2YWx1ZSBpZlxuICAgICAqIHRoZSBjaGVjayBmYWlscy5cbiAgICAgKlxuICAgICAqIElmIGdpdmVuIHZhbHVlIGlzbid0IGFuIEFycmF5LCBkZWxlZ2F0ZXMgdG8gYFNQRS51dGlscy5lbnN1cmVJbnN0YW5jZU9mYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gYXJnICAgICAgICAgIFRoZSB2YWx1ZSB0byBwZXJmb3JtIHRoZSBpbnN0YW5jZW9mIGNoZWNrIG9uLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpbnN0YW5jZSAgICAgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBpbnN0YW5jZSB0byBjaGVjayBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGVmYXVsdFZhbHVlIEEgZGVmYXVsdCBmYWxsYmFjayB2YWx1ZSBpZiBpbnN0YW5jZSBjaGVjayBmYWlsc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgIFRoZSBnaXZlbiB2YWx1ZSBpZiB0eXBlIGNoZWNrIHBhc3Nlcywgb3IgdGhlIGRlZmF1bHQgdmFsdWUgaWYgaXQgZmFpbHMuXG4gICAgICovXG4gICAgZW5zdXJlQXJyYXlJbnN0YW5jZU9mOiBmdW5jdGlvbiggYXJnLCBpbnN0YW5jZSwgZGVmYXVsdFZhbHVlICkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgLy8gSWYgdGhlIGFyZ3VtZW50IGJlaW5nIGNoZWNrZWQgaXMgYW4gYXJyYXksIGxvb3AgdGhyb3VnaFxuICAgICAgICAvLyBpdCBhbmQgZW5zdXJlIGFsbCB0aGUgdmFsdWVzIGFyZSBvZiB0aGUgY29ycmVjdCB0eXBlLFxuICAgICAgICAvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHRWYWx1ZSBpZiBhbnkgYXJlbid0LlxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGFyZyApICkge1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSBhcmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBpbnN0YW5jZSAhPT0gdW5kZWZpbmVkICYmIGFyZ1sgaSBdIGluc3RhbmNlb2YgaW5zdGFuY2UgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBhcmcgaXNuJ3QgYW4gYXJyYXkgdGhlbiBqdXN0IGZhbGxiYWNrIHRvXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSB0eXBlLlxuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbnN0YW5jZU9mKCBhcmcsIGluc3RhbmNlLCBkZWZhdWx0VmFsdWUgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IGFueSBcInZhbHVlLW92ZXItbGlmZXRpbWVcIiBwcm9wZXJ0aWVzIG9mIGFuIGVtaXR0ZXIgYXJlXG4gICAgICogb2YgdGhlIGNvcnJlY3QgbGVuZ3RoIChhcyBkaWN0YXRlZCBieSBgU1BFLnZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoYCkuXG4gICAgICpcbiAgICAgKiBEZWxlZ2F0ZXMgdG8gYFNQRS51dGlscy5pbnRlcnBvbGF0ZUFycmF5YCBmb3IgYXJyYXkgcmVzaXppbmcuXG4gICAgICpcbiAgICAgKiBJZiBwcm9wZXJ0aWVzIGFyZW4ndCBhcnJheXMsIHRoZW4gcHJvcGVydHkgdmFsdWVzIGFyZSBwdXQgaW50byBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BlcnR5ICBUaGUgcHJvcGVydHkgb2YgYW4gU1BFLkVtaXR0ZXIgaW5zdGFuY2UgdG8gY2hlY2sgY29tcGxpYW5jZSBvZi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1pbkxlbmd0aCBUaGUgbWluaW11bSBsZW5ndGggb2YgdGhlIGFycmF5IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1heExlbmd0aCBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIGFycmF5IHRvIGNyZWF0ZS5cbiAgICAgKi9cbiAgICBlbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2U6IGZ1bmN0aW9uKCBwcm9wZXJ0eSwgbWluTGVuZ3RoLCBtYXhMZW5ndGggKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBtaW5MZW5ndGggPSBtaW5MZW5ndGggfHwgMztcbiAgICAgICAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDM7XG5cbiAgICAgICAgLy8gRmlyc3QsIGVuc3VyZSBib3RoIHByb3BlcnRpZXMgYXJlIGFycmF5cy5cbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBwcm9wZXJ0eS5fdmFsdWUgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eS5fdmFsdWUgPSBbIHByb3BlcnR5Ll92YWx1ZSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBwcm9wZXJ0eS5fc3ByZWFkICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgcHJvcGVydHkuX3NwcmVhZCA9IFsgcHJvcGVydHkuX3NwcmVhZCBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlTGVuZ3RoID0gdGhpcy5jbGFtcCggcHJvcGVydHkuX3ZhbHVlLmxlbmd0aCwgbWluTGVuZ3RoLCBtYXhMZW5ndGggKSxcbiAgICAgICAgICAgIHNwcmVhZExlbmd0aCA9IHRoaXMuY2xhbXAoIHByb3BlcnR5Ll9zcHJlYWQubGVuZ3RoLCBtaW5MZW5ndGgsIG1heExlbmd0aCApLFxuICAgICAgICAgICAgZGVzaXJlZExlbmd0aCA9IE1hdGgubWF4KCB2YWx1ZUxlbmd0aCwgc3ByZWFkTGVuZ3RoICk7XG5cbiAgICAgICAgaWYgKCBwcm9wZXJ0eS5fdmFsdWUubGVuZ3RoICE9PSBkZXNpcmVkTGVuZ3RoICkge1xuICAgICAgICAgICAgcHJvcGVydHkuX3ZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZUFycmF5KCBwcm9wZXJ0eS5fdmFsdWUsIGRlc2lyZWRMZW5ndGggKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJvcGVydHkuX3NwcmVhZC5sZW5ndGggIT09IGRlc2lyZWRMZW5ndGggKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eS5fc3ByZWFkID0gdGhpcy5pbnRlcnBvbGF0ZUFycmF5KCBwcm9wZXJ0eS5fc3ByZWFkLCBkZXNpcmVkTGVuZ3RoICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gKGxlcnApIG9uIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGxlcnBpbmcgWzEsIDEwXSwgd2l0aCBhIGBuZXdMZW5ndGhgIG9mIDEwIHdpbGwgcHJvZHVjZSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdLlxuICAgICAqXG4gICAgICogRGVsZWdhdGVzIHRvIGBTUEUudXRpbHMubGVycFR5cGVBZ25vc3RpY2AgdG8gcGVyZm9ybSB0aGUgYWN0dWFsXG4gICAgICogaW50ZXJwb2xhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBzcmNBcnJheSAgVGhlIGFycmF5IHRvIGxlcnAuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBuZXdMZW5ndGggVGhlIGxlbmd0aCB0aGUgYXJyYXkgc2hvdWxkIGJlIGludGVycG9sYXRlZCB0by5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgIFRoZSBpbnRlcnBvbGF0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgaW50ZXJwb2xhdGVBcnJheTogZnVuY3Rpb24oIHNyY0FycmF5LCBuZXdMZW5ndGggKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgc291cmNlTGVuZ3RoID0gc3JjQXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgbmV3QXJyYXkgPSBbIHR5cGVvZiBzcmNBcnJheVsgMCBdLmNsb25lID09PSAnZnVuY3Rpb24nID8gc3JjQXJyYXlbIDAgXS5jbG9uZSgpIDogc3JjQXJyYXlbIDAgXSBdLFxuICAgICAgICAgICAgZmFjdG9yID0gKCBzb3VyY2VMZW5ndGggLSAxICkgLyAoIG5ld0xlbmd0aCAtIDEgKTtcblxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8IG5ld0xlbmd0aCAtIDE7ICsraSApIHtcbiAgICAgICAgICAgIHZhciBmID0gaSAqIGZhY3RvcixcbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBNYXRoLmZsb29yKCBmICksXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBNYXRoLmNlaWwoIGYgKSxcbiAgICAgICAgICAgICAgICBkZWx0YSA9IGYgLSBiZWZvcmU7XG5cbiAgICAgICAgICAgIG5ld0FycmF5WyBpIF0gPSB0aGlzLmxlcnBUeXBlQWdub3N0aWMoIHNyY0FycmF5WyBiZWZvcmUgXSwgc3JjQXJyYXlbIGFmdGVyIF0sIGRlbHRhICk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdBcnJheS5wdXNoKFxuICAgICAgICAgICAgdHlwZW9mIHNyY0FycmF5WyBzb3VyY2VMZW5ndGggLSAxIF0uY2xvbmUgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgc3JjQXJyYXlbIHNvdXJjZUxlbmd0aCAtIDEgXS5jbG9uZSgpIDpcbiAgICAgICAgICAgIHNyY0FycmF5WyBzb3VyY2VMZW5ndGggLSAxIF1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsYW1wIGEgbnVtYmVyIHRvIGJldHdlZW4gdGhlIGdpdmVuIG1pbiBhbmQgbWF4IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBtaW4gICBUaGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1heCAgIFRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgVGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGNsYW1wOiBmdW5jdGlvbiggdmFsdWUsIG1pbiwgbWF4ICkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCB2YWx1ZSwgbWF4ICkgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgZXBzaWxvbiB2YWx1ZSwgdGhlbiByZXR1cm5cbiAgICAgKiBhIHJhbmRvbWlzZWQgZXBzaWxvbiB2YWx1ZSBpZiBzcGVjaWZpZWQsIG9yIGp1c3QgdGhlIGVwc2lsb24gdmFsdWUgaWYgbm90LlxuICAgICAqIFdvcmtzIGZvciBuZWdhdGl2ZSBudW1iZXJzIGFzIHdlbGwgYXMgcG9zaXRpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlICAgICBUaGUgdmFsdWUgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uIG9uLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHJhbmRvbWlzZSBXaGV0aGVyIHRoZSB2YWx1ZSBzaG91bGQgYmUgcmFuZG9taXNlZC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgemVyb1RvRXBzaWxvbjogZnVuY3Rpb24oIHZhbHVlLCByYW5kb21pc2UgKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMDEsXG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcblxuICAgICAgICByZXN1bHQgPSByYW5kb21pc2UgPyBNYXRoLnJhbmRvbSgpICogZXBzaWxvbiAqIDEwIDogZXBzaWxvbjtcblxuICAgICAgICBpZiAoIHZhbHVlIDwgMCAmJiB2YWx1ZSA+IC1lcHNpbG9uICkge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmICggdmFsdWUgPT09IDAgKSB7XG4gICAgICAgIC8vICAgICByZXN1bHQgPSByYW5kb21pc2UgPyBNYXRoLnJhbmRvbSgpICogZXBzaWxvbiAqIDEwIDogZXBzaWxvbjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBlbHNlIGlmICggdmFsdWUgPiAwICYmIHZhbHVlIDwgZXBzaWxvbiApIHtcbiAgICAgICAgLy8gICAgIHJlc3VsdCA9IHJhbmRvbWlzZSA/IE1hdGgucmFuZG9tKCkgKiBlcHNpbG9uICogMTAgOiBlcHNpbG9uO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGVsc2UgaWYgKCB2YWx1ZSA8IDAgJiYgdmFsdWUgPiAtZXBzaWxvbiApIHtcbiAgICAgICAgLy8gICAgIHJlc3VsdCA9IC0oIHJhbmRvbWlzZSA/IE1hdGgucmFuZG9tKCkgKiBlcHNpbG9uICogMTAgOiBlcHNpbG9uICk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdHdvIHZhbHVlcyBvZiB2YXJpb3VzIHR5cGVzLiBUaGUgZ2l2ZW4gdmFsdWVzXG4gICAgICogbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiB0byB3b3JrLlxuICAgICAqIEBwYXJhbSAgeyhudW1iZXJ8T2JqZWN0KX0gc3RhcnQgVGhlIHN0YXJ0IHZhbHVlIG9mIHRoZSBsZXJwLlxuICAgICAqIEBwYXJhbSAgeyhudW1iZXJ8b2JqZWN0KX0gZW5kICAgVGhlIGVuZCB2YWx1ZSBvZiB0aGUgbGVycC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlbHRhIFRoZSBkZWx0YSBwb3NpaXRvbiBvZiB0aGUgbGVycCBvcGVyYXRpb24uIElkZWFsbHkgYmV0d2VlbiAwIGFuZCAxIChpbmNsdXNpdmUpLlxuICAgICAqIEByZXR1cm4geyhudW1iZXJ8b2JqZWN0fHVuZGVmaW5lZCl9ICAgICAgIFRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvbi4gUmVzdWx0IHdpbGwgYmUgdW5kZWZpbmVkIGlmXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdGFydCBhbmQgZW5kIGFyZ3VtZW50cyBhcmVuJ3QgYSBzdXBwb3J0ZWQgdHlwZSwgb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGhlaXIgdHlwZXMgZG8gbm90IG1hdGNoLlxuICAgICAqL1xuICAgIGxlcnBUeXBlQWdub3N0aWM6IGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBkZWx0YSApIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXMsXG4gICAgICAgICAgICBvdXQ7XG5cbiAgICAgICAgaWYgKCB0eXBlb2Ygc3RhcnQgPT09IHR5cGVzLk5VTUJFUiAmJiB0eXBlb2YgZW5kID09PSB0eXBlcy5OVU1CRVIgKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgKyAoICggZW5kIC0gc3RhcnQgKSAqIGRlbHRhICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHN0YXJ0IGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiAmJiBlbmQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyICkge1xuICAgICAgICAgICAgb3V0ID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgIG91dC54ID0gdGhpcy5sZXJwKCBzdGFydC54LCBlbmQueCwgZGVsdGEgKTtcbiAgICAgICAgICAgIG91dC55ID0gdGhpcy5sZXJwKCBzdGFydC55LCBlbmQueSwgZGVsdGEgKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHN0YXJ0IGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBlbmQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkge1xuICAgICAgICAgICAgb3V0ID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgIG91dC54ID0gdGhpcy5sZXJwKCBzdGFydC54LCBlbmQueCwgZGVsdGEgKTtcbiAgICAgICAgICAgIG91dC55ID0gdGhpcy5sZXJwKCBzdGFydC55LCBlbmQueSwgZGVsdGEgKTtcbiAgICAgICAgICAgIG91dC56ID0gdGhpcy5sZXJwKCBzdGFydC56LCBlbmQueiwgZGVsdGEgKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHN0YXJ0IGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCAmJiBlbmQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0ICkge1xuICAgICAgICAgICAgb3V0ID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgIG91dC54ID0gdGhpcy5sZXJwKCBzdGFydC54LCBlbmQueCwgZGVsdGEgKTtcbiAgICAgICAgICAgIG91dC55ID0gdGhpcy5sZXJwKCBzdGFydC55LCBlbmQueSwgZGVsdGEgKTtcbiAgICAgICAgICAgIG91dC56ID0gdGhpcy5sZXJwKCBzdGFydC56LCBlbmQueiwgZGVsdGEgKTtcbiAgICAgICAgICAgIG91dC53ID0gdGhpcy5sZXJwKCBzdGFydC53LCBlbmQudywgZGVsdGEgKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIHN0YXJ0IGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgJiYgZW5kIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG4gICAgICAgICAgICBvdXQgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgICAgICAgb3V0LnIgPSB0aGlzLmxlcnAoIHN0YXJ0LnIsIGVuZC5yLCBkZWx0YSApO1xuICAgICAgICAgICAgb3V0LmcgPSB0aGlzLmxlcnAoIHN0YXJ0LmcsIGVuZC5nLCBkZWx0YSApO1xuICAgICAgICAgICAgb3V0LmIgPSB0aGlzLmxlcnAoIHN0YXJ0LmIsIGVuZC5iLCBkZWx0YSApO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ0ludmFsaWQgYXJndW1lbnQgdHlwZXMsIG9yIGFyZ3VtZW50IHR5cGVzIGRvIG5vdCBtYXRjaDonLCBzdGFydCwgZW5kICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9wZXJhdGlvbiBvbiB0d28gbnVtYmVycy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAgIFRoZSBlbmQgdmFsdWUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBkZWx0YSBUaGUgcG9zaXRpb24gdG8gaW50ZXJwb2xhdGUgdG8uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICBUaGUgcmVzdWx0IG9mIHRoZSBsZXJwIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBsZXJwOiBmdW5jdGlvbiggc3RhcnQsIGVuZCwgZGVsdGEgKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKCAoIGVuZCAtIHN0YXJ0ICkgKiBkZWx0YSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgYSBudW1iZXIgdG8gYSBuZWFyZXN0IG11bHRpcGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBuICAgICAgICBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbXVsdGlwbGUgVGhlIG11bHRpcGxlIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgVGhlIHJlc3VsdCBvZiB0aGUgcm91bmQgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHJvdW5kVG9OZWFyZXN0TXVsdGlwbGU6IGZ1bmN0aW9uKCBuLCBtdWx0aXBsZSApIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciByZW1haW5kZXIgPSAwO1xuXG4gICAgICAgIGlmICggbXVsdGlwbGUgPT09IDAgKSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbWFpbmRlciA9IE1hdGguYWJzKCBuICkgJSBtdWx0aXBsZTtcblxuICAgICAgICBpZiAoIHJlbWFpbmRlciA9PT0gMCApIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBuIDwgMCApIHtcbiAgICAgICAgICAgIHJldHVybiAtKCBNYXRoLmFicyggbiApIC0gcmVtYWluZGVyICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiArIG11bHRpcGxlIC0gcmVtYWluZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbGwgaXRlbXMgaW4gYW4gYXJyYXkgYXJlIGVxdWFsLiBVc2VzIHN0cmljdCBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGNoZWNrIGVxdWFsaXR5IG9mLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIFdoZXRoZXIgdGhlIGFycmF5J3MgdmFsdWVzIGFyZSBhbGwgZXF1YWwgb3Igbm90LlxuICAgICAqL1xuICAgIGFycmF5VmFsdWVzQXJlRXF1YWw6IGZ1bmN0aW9uKCBhcnJheSApIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aCAtIDE7ICsraSApIHtcbiAgICAgICAgICAgIGlmICggYXJyYXlbIGkgXSAhPT0gYXJyYXlbIGkgKyAxIF0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8vIGNvbG9yc0FyZUVxdWFsOiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgdmFyIGNvbG9ycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcbiAgICAvLyAgICAgICAgIG51bUNvbG9ycyA9IGNvbG9ycy5sZW5ndGg7XG5cbiAgICAvLyAgICAgZm9yICggdmFyIGkgPSAwLCBjb2xvcjEsIGNvbG9yMjsgaSA8IG51bUNvbG9ycyAtIDE7ICsraSApIHtcbiAgICAvLyAgICAgICAgIGNvbG9yMSA9IGNvbG9yc1sgaSBdO1xuICAgIC8vICAgICAgICAgY29sb3IyID0gY29sb3JzWyBpICsgMSBdO1xuXG4gICAgLy8gICAgICAgICBpZiAoXG4gICAgLy8gICAgICAgICAgICAgY29sb3IxLnIgIT09IGNvbG9yMi5yIHx8XG4gICAgLy8gICAgICAgICAgICAgY29sb3IxLmcgIT09IGNvbG9yMi5nIHx8XG4gICAgLy8gICAgICAgICAgICAgY29sb3IxLmIgIT09IGNvbG9yMi5iXG4gICAgLy8gICAgICAgICApIHtcbiAgICAvLyAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgIC8vIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3RhcnQgdmFsdWUgYW5kIGEgc3ByZWFkIHZhbHVlLCBjcmVhdGUgYW5kIHJldHVybiBhIHJhbmRvbVxuICAgICAqIG51bWJlci5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGJhc2UgICBUaGUgc3RhcnQgdmFsdWUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzcHJlYWQgVGhlIHNpemUgb2YgdGhlIHJhbmRvbSB2YXJpYW5jZSB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICBBIHJhbmRvbWlzZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIHJhbmRvbUZsb2F0OiBmdW5jdGlvbiggYmFzZSwgc3ByZWFkICkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIHJldHVybiBiYXNlICsgc3ByZWFkICogKCBNYXRoLnJhbmRvbSgpIC0gMC41ICk7XG4gICAgfSxcblxuXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBTUEUuU2hhZGVyQXR0cmlidXRlIGluc3RhbmNlLCBhbmQgdmFyaW91cyBvdGhlciBzZXR0aW5ncyxcbiAgICAgKiBhc3NpZ24gdmFsdWVzIHRvIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBpbiBhIGB2ZWMzYCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJpYnV0ZSAgIFRoZSBpbnN0YW5jZSBvZiBTUEUuU2hhZGVyQXR0cmlidXRlIHRvIHNhdmUgdGhlIHJlc3VsdCB0by5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4ICAgICAgIFRoZSBvZmZzZXQgaW4gdGhlIGF0dHJpYnV0ZSdzIFR5cGVkQXJyYXkgdG8gc2F2ZSB0aGUgcmVzdWx0IGZyb20uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBiYXNlICAgICAgICBUSFJFRS5WZWN0b3IzIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIHN0YXJ0IHZhbHVlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3ByZWFkICAgICAgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSByYW5kb20gdmFyaWFuY2UgdG8gYXBwbHkgdG8gdGhlIHN0YXJ0IHZhbHVlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3ByZWFkQ2xhbXAgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBtdWx0aXBsZXMgdG8gY2xhbXAgdGhlIHJhbmRvbW5lc3MgdG8uXG4gICAgICovXG4gICAgcmFuZG9tVmVjdG9yMzogZnVuY3Rpb24oIGF0dHJpYnV0ZSwgaW5kZXgsIGJhc2UsIHNwcmVhZCwgc3ByZWFkQ2xhbXAgKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgeCA9IGJhc2UueCArICggTWF0aC5yYW5kb20oKSAqIHNwcmVhZC54IC0gKCBzcHJlYWQueCAqIDAuNSApICksXG4gICAgICAgICAgICB5ID0gYmFzZS55ICsgKCBNYXRoLnJhbmRvbSgpICogc3ByZWFkLnkgLSAoIHNwcmVhZC55ICogMC41ICkgKSxcbiAgICAgICAgICAgIHogPSBiYXNlLnogKyAoIE1hdGgucmFuZG9tKCkgKiBzcHJlYWQueiAtICggc3ByZWFkLnogKiAwLjUgKSApO1xuXG4gICAgICAgIC8vIHZhciB4ID0gdGhpcy5yYW5kb21GbG9hdCggYmFzZS54LCBzcHJlYWQueCApLFxuICAgICAgICAvLyB5ID0gdGhpcy5yYW5kb21GbG9hdCggYmFzZS55LCBzcHJlYWQueSApLFxuICAgICAgICAvLyB6ID0gdGhpcy5yYW5kb21GbG9hdCggYmFzZS56LCBzcHJlYWQueiApO1xuXG4gICAgICAgIGlmICggc3ByZWFkQ2xhbXAgKSB7XG4gICAgICAgICAgICB4ID0gLXNwcmVhZENsYW1wLnggKiAwLjUgKyB0aGlzLnJvdW5kVG9OZWFyZXN0TXVsdGlwbGUoIHgsIHNwcmVhZENsYW1wLnggKTtcbiAgICAgICAgICAgIHkgPSAtc3ByZWFkQ2xhbXAueSAqIDAuNSArIHRoaXMucm91bmRUb05lYXJlc3RNdWx0aXBsZSggeSwgc3ByZWFkQ2xhbXAueSApO1xuICAgICAgICAgICAgeiA9IC1zcHJlYWRDbGFtcC56ICogMC41ICsgdGhpcy5yb3VuZFRvTmVhcmVzdE11bHRpcGxlKCB6LCBzcHJlYWRDbGFtcC56ICk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGUudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyggaW5kZXgsIHgsIHksIHogKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gU1BFLlNoYWRlciBhdHRyaWJ1dGUgaW5zdGFuY2UsIGFuZCB2YXJpb3VzIG90aGVyIHNldHRpbmdzLFxuICAgICAqIGFzc2lnbiBDb2xvciB2YWx1ZXMgdG8gdGhlIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJpYnV0ZSBUaGUgaW5zdGFuY2Ugb2YgU1BFLlNoYWRlckF0dHJpYnV0ZSB0byBzYXZlIHRoZSByZXN1bHQgdG8uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAgICAgVGhlIG9mZnNldCBpbiB0aGUgYXR0cmlidXRlJ3MgVHlwZWRBcnJheSB0byBzYXZlIHRoZSByZXN1bHQgZnJvbS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGJhc2UgICAgICBUSFJFRS5Db2xvciBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBzdGFydCBjb2xvci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNwcmVhZCAgICBUSFJFRS5WZWN0b3IzIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIHJhbmRvbSB2YXJpYW5jZSB0byBhcHBseSB0byB0aGUgc3RhcnQgY29sb3IuXG4gICAgICovXG4gICAgcmFuZG9tQ29sb3I6IGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIGluZGV4LCBiYXNlLCBzcHJlYWQgKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgciA9IGJhc2UuciArICggTWF0aC5yYW5kb20oKSAqIHNwcmVhZC54ICksXG4gICAgICAgICAgICBnID0gYmFzZS5nICsgKCBNYXRoLnJhbmRvbSgpICogc3ByZWFkLnkgKSxcbiAgICAgICAgICAgIGIgPSBiYXNlLmIgKyAoIE1hdGgucmFuZG9tKCkgKiBzcHJlYWQueiApO1xuXG4gICAgICAgIHIgPSB0aGlzLmNsYW1wKCByLCAwLCAxICk7XG4gICAgICAgIGcgPSB0aGlzLmNsYW1wKCBnLCAwLCAxICk7XG4gICAgICAgIGIgPSB0aGlzLmNsYW1wKCBiLCAwLCAxICk7XG5cblxuICAgICAgICBhdHRyaWJ1dGUudHlwZWRBcnJheS5zZXRWZWMzQ29tcG9uZW50cyggaW5kZXgsIHIsIGcsIGIgKTtcbiAgICB9LFxuXG5cbiAgICByYW5kb21Db2xvckFzSGV4OiAoIGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIHdvcmtpbmdDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ25zIGEgcmFuZG9tIGNvbG9yIHZhbHVlLCBlbmNvZGVkIGFzIGEgaGV4IHZhbHVlIGluIGRlY2ltYWxcbiAgICAgICAgICogZm9ybWF0LCB0byBhIFNQRS5TaGFkZXJBdHRyaWJ1dGUgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gYXR0cmlidXRlIFRoZSBpbnN0YW5jZSBvZiBTUEUuU2hhZGVyQXR0cmlidXRlIHRvIHNhdmUgdGhlIHJlc3VsdCB0by5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAgICAgVGhlIG9mZnNldCBpbiB0aGUgYXR0cmlidXRlJ3MgVHlwZWRBcnJheSB0byBzYXZlIHRoZSByZXN1bHQgZnJvbS5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBiYXNlICAgICAgVEhSRUUuQ29sb3IgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgc3RhcnQgY29sb3IuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gc3ByZWFkICAgIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgcmFuZG9tIHZhcmlhbmNlIHRvIGFwcGx5IHRvIHRoZSBzdGFydCBjb2xvci5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggYXR0cmlidXRlLCBpbmRleCwgYmFzZSwgc3ByZWFkICkge1xuICAgICAgICAgICAgdmFyIG51bUl0ZW1zID0gYmFzZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY29sb3JzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG51bUl0ZW1zOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwcmVhZFZlY3RvciA9IHNwcmVhZFsgaSBdO1xuXG4gICAgICAgICAgICAgICAgd29ya2luZ0NvbG9yLmNvcHkoIGJhc2VbIGkgXSApO1xuXG4gICAgICAgICAgICAgICAgd29ya2luZ0NvbG9yLnIgKz0gKCBNYXRoLnJhbmRvbSgpICogc3ByZWFkVmVjdG9yLnggKSAtICggc3ByZWFkVmVjdG9yLnggKiAwLjUgKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nQ29sb3IuZyArPSAoIE1hdGgucmFuZG9tKCkgKiBzcHJlYWRWZWN0b3IueSApIC0gKCBzcHJlYWRWZWN0b3IueSAqIDAuNSApO1xuICAgICAgICAgICAgICAgIHdvcmtpbmdDb2xvci5iICs9ICggTWF0aC5yYW5kb20oKSAqIHNwcmVhZFZlY3Rvci56ICkgLSAoIHNwcmVhZFZlY3Rvci56ICogMC41ICk7XG5cbiAgICAgICAgICAgICAgICB3b3JraW5nQ29sb3IuciA9IHRoaXMuY2xhbXAoIHdvcmtpbmdDb2xvci5yLCAwLCAxICk7XG4gICAgICAgICAgICAgICAgd29ya2luZ0NvbG9yLmcgPSB0aGlzLmNsYW1wKCB3b3JraW5nQ29sb3IuZywgMCwgMSApO1xuICAgICAgICAgICAgICAgIHdvcmtpbmdDb2xvci5iID0gdGhpcy5jbGFtcCggd29ya2luZ0NvbG9yLmIsIDAsIDEgKTtcblxuICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKCB3b3JraW5nQ29sb3IuZ2V0SGV4KCkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0cmlidXRlLnR5cGVkQXJyYXkuc2V0VmVjNENvbXBvbmVudHMoIGluZGV4LCBjb2xvcnNbIDAgXSwgY29sb3JzWyAxIF0sIGNvbG9yc1sgMiBdLCBjb2xvcnNbIDMgXSApO1xuICAgICAgICB9O1xuICAgIH0oKSApLFxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBhIHJhbmRvbSB2ZWN0b3IgMyB2YWx1ZSB0byBhbiBTUEUuU2hhZGVyQXR0cmlidXRlIGluc3RhbmNlLCBwcm9qZWN0aW5nIHRoZVxuICAgICAqIGdpdmVuIHZhbHVlcyBvbnRvIGEgc3BoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBhdHRyaWJ1dGUgVGhlIGluc3RhbmNlIG9mIFNQRS5TaGFkZXJBdHRyaWJ1dGUgdG8gc2F2ZSB0aGUgcmVzdWx0IHRvLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXggICAgIFRoZSBvZmZzZXQgaW4gdGhlIGF0dHJpYnV0ZSdzIFR5cGVkQXJyYXkgdG8gc2F2ZSB0aGUgcmVzdWx0IGZyb20uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBiYXNlICAgICAgICAgICAgICBUSFJFRS5WZWN0b3IzIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gcmFkaXVzICAgICAgICAgICAgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250by5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHJhZGl1c1NwcmVhZCAgICAgIFRoZSBhbW91bnQgb2YgcmFuZG9tbmVzcyB0byBhcHBseSB0byB0aGUgcHJvamVjdGlvbiByZXN1bHRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHJhZGl1c1NjYWxlICAgICAgIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgc2NhbGUgb2YgZWFjaCBheGlzIG9mIHRoZSBzcGhlcmUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSByYWRpdXNTcHJlYWRDbGFtcCBXaGF0IG51bWVyaWMgbXVsdGlwbGUgdGhlIHByb2plY3RlZCB2YWx1ZSBzaG91bGQgYmUgY2xhbXBlZCB0by5cbiAgICAgKi9cbiAgICByYW5kb21WZWN0b3IzT25TcGhlcmU6IGZ1bmN0aW9uKFxuICAgICAgICBhdHRyaWJ1dGUsIGluZGV4LCBiYXNlLCByYWRpdXMsIHJhZGl1c1NwcmVhZCwgcmFkaXVzU2NhbGUsIHJhZGl1c1NwcmVhZENsYW1wLCBkaXN0cmlidXRpb25DbGFtcFxuICAgICkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIGRlcHRoID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxLFxuICAgICAgICAgICAgdCA9IDYuMjgzMiAqIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICByID0gTWF0aC5zcXJ0KCAxIC0gZGVwdGggKiBkZXB0aCApLFxuICAgICAgICAgICAgcmFuZCA9IHRoaXMucmFuZG9tRmxvYXQoIHJhZGl1cywgcmFkaXVzU3ByZWFkICksXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgeiA9IDA7XG5cblxuICAgICAgICBpZiAoIHJhZGl1c1NwcmVhZENsYW1wICkge1xuICAgICAgICAgICAgcmFuZCA9IE1hdGgucm91bmQoIHJhbmQgLyByYWRpdXNTcHJlYWRDbGFtcCApICogcmFkaXVzU3ByZWFkQ2xhbXA7XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLy8gU2V0IHBvc2l0aW9uIG9uIHNwaGVyZVxuICAgICAgICB4ID0gciAqIE1hdGguY29zKCB0ICkgKiByYW5kO1xuICAgICAgICB5ID0gciAqIE1hdGguc2luKCB0ICkgKiByYW5kO1xuICAgICAgICB6ID0gZGVwdGggKiByYW5kO1xuXG4gICAgICAgIC8vIEFwcGx5IHJhZGl1cyBzY2FsZSB0byB0aGlzIHBvc2l0aW9uXG4gICAgICAgIHggKj0gcmFkaXVzU2NhbGUueDtcbiAgICAgICAgeSAqPSByYWRpdXNTY2FsZS55O1xuICAgICAgICB6ICo9IHJhZGl1c1NjYWxlLno7XG5cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRvIHRoZSBiYXNlIHBvc2l0aW9uLlxuICAgICAgICB4ICs9IGJhc2UueDtcbiAgICAgICAgeSArPSBiYXNlLnk7XG4gICAgICAgIHogKz0gYmFzZS56O1xuXG4gICAgICAgIC8vIFNldCB0aGUgdmFsdWVzIGluIHRoZSB0eXBlZCBhcnJheS5cbiAgICAgICAgYXR0cmlidXRlLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoIGluZGV4LCB4LCB5LCB6ICk7XG4gICAgfSxcblxuICAgIHNlZWRlZFJhbmRvbTogZnVuY3Rpb24oIHNlZWQgKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5zaW4oIHNlZWQgKSAqIDEwMDAwO1xuICAgICAgICByZXR1cm4geCAtICggeCB8IDAgKTtcbiAgICB9LFxuXG5cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYSByYW5kb20gdmVjdG9yIDMgdmFsdWUgdG8gYW4gU1BFLlNoYWRlckF0dHJpYnV0ZSBpbnN0YW5jZSwgcHJvamVjdGluZyB0aGVcbiAgICAgKiBnaXZlbiB2YWx1ZXMgb250byBhIDJkLWRpc2MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJpYnV0ZSBUaGUgaW5zdGFuY2Ugb2YgU1BFLlNoYWRlckF0dHJpYnV0ZSB0byBzYXZlIHRoZSByZXN1bHQgdG8uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAgICAgVGhlIG9mZnNldCBpbiB0aGUgYXR0cmlidXRlJ3MgVHlwZWRBcnJheSB0byBzYXZlIHRoZSByZXN1bHQgZnJvbS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGJhc2UgICAgICAgICAgICAgIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSByYWRpdXMgICAgICAgICAgICBUaGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gcmFkaXVzU3ByZWFkICAgICAgVGhlIGFtb3VudCBvZiByYW5kb21uZXNzIHRvIGFwcGx5IHRvIHRoZSBwcm9qZWN0aW9uIHJlc3VsdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcmFkaXVzU2NhbGUgICAgICAgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBzY2FsZSBvZiBlYWNoIGF4aXMgb2YgdGhlIGRpc2MuIFRoZSB6LWNvbXBvbmVudCBpcyBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gcmFkaXVzU3ByZWFkQ2xhbXAgV2hhdCBudW1lcmljIG11bHRpcGxlIHRoZSBwcm9qZWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGNsYW1wZWQgdG8uXG4gICAgICovXG4gICAgcmFuZG9tVmVjdG9yM09uRGlzYzogZnVuY3Rpb24oIGF0dHJpYnV0ZSwgaW5kZXgsIGJhc2UsIHJhZGl1cywgcmFkaXVzU3ByZWFkLCByYWRpdXNTY2FsZSwgcmFkaXVzU3ByZWFkQ2xhbXAgKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgdCA9IDYuMjgzMiAqIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICByYW5kID0gTWF0aC5hYnMoIHRoaXMucmFuZG9tRmxvYXQoIHJhZGl1cywgcmFkaXVzU3ByZWFkICkgKSxcbiAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICB6ID0gMDtcblxuICAgICAgICBpZiAoIHJhZGl1c1NwcmVhZENsYW1wICkge1xuICAgICAgICAgICAgcmFuZCA9IE1hdGgucm91bmQoIHJhbmQgLyByYWRpdXNTcHJlYWRDbGFtcCApICogcmFkaXVzU3ByZWFkQ2xhbXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgcG9zaXRpb24gb24gc3BoZXJlXG4gICAgICAgIHggPSBNYXRoLmNvcyggdCApICogcmFuZDtcbiAgICAgICAgeSA9IE1hdGguc2luKCB0ICkgKiByYW5kO1xuXG4gICAgICAgIC8vIEFwcGx5IHJhZGl1cyBzY2FsZSB0byB0aGlzIHBvc2l0aW9uXG4gICAgICAgIHggKj0gcmFkaXVzU2NhbGUueDtcbiAgICAgICAgeSAqPSByYWRpdXNTY2FsZS55O1xuXG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0byB0aGUgYmFzZSBwb3NpdGlvbi5cbiAgICAgICAgeCArPSBiYXNlLng7XG4gICAgICAgIHkgKz0gYmFzZS55O1xuICAgICAgICB6ICs9IGJhc2UuejtcblxuICAgICAgICAvLyBTZXQgdGhlIHZhbHVlcyBpbiB0aGUgdHlwZWQgYXJyYXkuXG4gICAgICAgIGF0dHJpYnV0ZS50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKCBpbmRleCwgeCwgeSwgeiApO1xuICAgIH0sXG5cbiAgICByYW5kb21EaXJlY3Rpb25WZWN0b3IzT25TcGhlcmU6ICggZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIFNQRS5TaGFkZXJBdHRyaWJ1dGUgaW5zdGFuY2UsIGNyZWF0ZSBhIGRpcmVjdGlvbiB2ZWN0b3IgZnJvbSB0aGUgZ2l2ZW5cbiAgICAgICAgICogcG9zaXRpb24sIHVzaW5nIGBzcGVlZGAgYXMgdGhlIG1hZ25pdHVkZS4gVmFsdWVzIGFyZSBzYXZlZCB0byB0aGUgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJpYnV0ZSAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU1BFLlNoYWRlckF0dHJpYnV0ZSB0byBzYXZlIHRoZSByZXN1bHQgdG8uXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXggICAgICAgICAgIFRoZSBvZmZzZXQgaW4gdGhlIGF0dHJpYnV0ZSdzIFR5cGVkQXJyYXkgdG8gc2F2ZSB0aGUgcmVzdWx0IGZyb20uXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gcG9zWCAgICAgICAgICAgIFRoZSBwYXJ0aWNsZSdzIHggY29vcmRpbmF0ZS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBwb3NZICAgICAgICAgICAgVGhlIHBhcnRpY2xlJ3MgeSBjb29yZGluYXRlLlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc1ogICAgICAgICAgICBUaGUgcGFydGljbGUncyB6IGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZW1pdHRlclBvc2l0aW9uIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgZW1pdHRlcidzIGJhc2UgcG9zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gc3BlZWQgICAgICAgICAgIFRoZSBtYWduaXR1ZGUgdG8gYXBwbHkgdG8gdGhlIHZlY3Rvci5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBzcGVlZFNwcmVhZCAgICAgVGhlIGFtb3VudCBvZiByYW5kb21uZXNzIHRvIGFwcGx5IHRvIHRoZSBtYWduaXR1ZGUuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgaW5kZXgsIHBvc1gsIHBvc1ksIHBvc1osIGVtaXR0ZXJQb3NpdGlvbiwgc3BlZWQsIHNwZWVkU3ByZWFkICkge1xuICAgICAgICAgICAgdi5jb3B5KCBlbWl0dGVyUG9zaXRpb24gKTtcblxuICAgICAgICAgICAgdi54IC09IHBvc1g7XG4gICAgICAgICAgICB2LnkgLT0gcG9zWTtcbiAgICAgICAgICAgIHYueiAtPSBwb3NaO1xuXG4gICAgICAgICAgICB2Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCAtdGhpcy5yYW5kb21GbG9hdCggc3BlZWQsIHNwZWVkU3ByZWFkICkgKTtcblxuICAgICAgICAgICAgYXR0cmlidXRlLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoIGluZGV4LCB2LngsIHYueSwgdi56ICk7XG4gICAgICAgIH07XG4gICAgfSgpICksXG5cblxuICAgIHJhbmRvbURpcmVjdGlvblZlY3RvcjNPbkRpc2M6ICggZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIFNQRS5TaGFkZXJBdHRyaWJ1dGUgaW5zdGFuY2UsIGNyZWF0ZSBhIGRpcmVjdGlvbiB2ZWN0b3IgZnJvbSB0aGUgZ2l2ZW5cbiAgICAgICAgICogcG9zaXRpb24sIHVzaW5nIGBzcGVlZGAgYXMgdGhlIG1hZ25pdHVkZS4gVmFsdWVzIGFyZSBzYXZlZCB0byB0aGUgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJpYnV0ZSAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU1BFLlNoYWRlckF0dHJpYnV0ZSB0byBzYXZlIHRoZSByZXN1bHQgdG8uXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXggICAgICAgICAgIFRoZSBvZmZzZXQgaW4gdGhlIGF0dHJpYnV0ZSdzIFR5cGVkQXJyYXkgdG8gc2F2ZSB0aGUgcmVzdWx0IGZyb20uXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gcG9zWCAgICAgICAgICAgIFRoZSBwYXJ0aWNsZSdzIHggY29vcmRpbmF0ZS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBwb3NZICAgICAgICAgICAgVGhlIHBhcnRpY2xlJ3MgeSBjb29yZGluYXRlLlxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc1ogICAgICAgICAgICBUaGUgcGFydGljbGUncyB6IGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZW1pdHRlclBvc2l0aW9uIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgZW1pdHRlcidzIGJhc2UgcG9zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gc3BlZWQgICAgICAgICAgIFRoZSBtYWduaXR1ZGUgdG8gYXBwbHkgdG8gdGhlIHZlY3Rvci5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBzcGVlZFNwcmVhZCAgICAgVGhlIGFtb3VudCBvZiByYW5kb21uZXNzIHRvIGFwcGx5IHRvIHRoZSBtYWduaXR1ZGUuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgaW5kZXgsIHBvc1gsIHBvc1ksIHBvc1osIGVtaXR0ZXJQb3NpdGlvbiwgc3BlZWQsIHNwZWVkU3ByZWFkICkge1xuICAgICAgICAgICAgdi5jb3B5KCBlbWl0dGVyUG9zaXRpb24gKTtcblxuICAgICAgICAgICAgdi54IC09IHBvc1g7XG4gICAgICAgICAgICB2LnkgLT0gcG9zWTtcbiAgICAgICAgICAgIHYueiAtPSBwb3NaO1xuXG4gICAgICAgICAgICB2Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCAtdGhpcy5yYW5kb21GbG9hdCggc3BlZWQsIHNwZWVkU3ByZWFkICkgKTtcblxuICAgICAgICAgICAgYXR0cmlidXRlLnR5cGVkQXJyYXkuc2V0VmVjM0NvbXBvbmVudHMoIGluZGV4LCB2LngsIHYueSwgMCApO1xuICAgICAgICB9O1xuICAgIH0oKSApLFxuXG4gICAgZ2V0UGFja2VkUm90YXRpb25BeGlzOiAoIGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgdlNwcmVhZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgICBjID0gbmV3IFRIUkVFLkNvbG9yKCksXG4gICAgICAgICAgICBhZGRPbmUgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHJvdGF0aW9uIGF4aXMsIGFuZCBhIHJvdGF0aW9uIGF4aXMgc3ByZWFkIHZlY3RvcixcbiAgICAgICAgICogY2FsY3VsYXRlIGEgcmFuZG9taXNlZCByb3RhdGlvbiBheGlzLCBhbmQgcGFjayBpdCBpbnRvXG4gICAgICAgICAqIGEgaGV4YWRlY2ltYWwgdmFsdWUgcmVwcmVzZW50ZWQgaW4gZGVjaW1hbCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF4aXMgICAgICAgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSByb3RhdGlvbiBheGlzLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGF4aXNTcHJlYWQgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBhbW91bnQgb2YgcmFuZG9tbmVzcyB0byBhcHBseSB0byB0aGUgcm90YXRpb24gYXhpcy5cbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgIFRoZSBwYWNrZWQgcm90YXRpb24gYXhpcywgd2l0aCByYW5kb21uZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBheGlzLCBheGlzU3ByZWFkICkge1xuICAgICAgICAgICAgdi5jb3B5KCBheGlzICkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB2U3ByZWFkLmNvcHkoIGF4aXNTcHJlYWQgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgdi54ICs9ICggLWF4aXNTcHJlYWQueCAqIDAuNSApICsgKCBNYXRoLnJhbmRvbSgpICogYXhpc1NwcmVhZC54ICk7XG4gICAgICAgICAgICB2LnkgKz0gKCAtYXhpc1NwcmVhZC55ICogMC41ICkgKyAoIE1hdGgucmFuZG9tKCkgKiBheGlzU3ByZWFkLnkgKTtcbiAgICAgICAgICAgIHYueiArPSAoIC1heGlzU3ByZWFkLnogKiAwLjUgKSArICggTWF0aC5yYW5kb20oKSAqIGF4aXNTcHJlYWQueiApO1xuXG4gICAgICAgICAgICAvLyB2LnggPSBNYXRoLmFicyggdi54ICk7XG4gICAgICAgICAgICAvLyB2LnkgPSBNYXRoLmFicyggdi55ICk7XG4gICAgICAgICAgICAvLyB2LnogPSBNYXRoLmFicyggdi56ICk7XG5cbiAgICAgICAgICAgIHYubm9ybWFsaXplKCkuYWRkKCBhZGRPbmUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICAgICAgICAgIGMuc2V0UkdCKCB2LngsIHYueSwgdi56ICk7XG5cbiAgICAgICAgICAgIHJldHVybiBjLmdldEhleCgpO1xuICAgICAgICB9O1xuICAgIH0oKSApXG59O1xuXG4vKipcbiAqIEFuIFNQRS5Hcm91cCBpbnN0YW5jZS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdyb3VwXG4gKiBAc2VlIFNQRS5Hcm91cFxuICovXG5cbi8qKlxuICogQSBtYXAgb2Ygb3B0aW9ucyB0byBjb25maWd1cmUgYW4gU1BFLkdyb3VwIGluc3RhbmNlLlxuICogQHR5cGVkZWYge09iamVjdH0gR3JvdXBPcHRpb25zXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IHRleHR1cmUgQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHRleHR1cmUgdXNlZCBieSB0aGUgZ3JvdXAuXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IHRleHR1cmUudmFsdWUgQW4gaW5zdGFuY2Ugb2YgVEhSRUUuVGV4dHVyZS5cbiAqXG4gKiBAcHJvcGVydHkge09iamVjdD19IHRleHR1cmUuZnJhbWVzIEEgVEhSRUUuVmVjdG9yMiBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZnJhbWVzIG9uIHRoZSB4LSBhbmQgeS1heGlzIG9mIHRoZSBnaXZlbiB0ZXh0dXJlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZXh0dXJlIHdpbGwgTk9UIGJlIHRyZWF0ZWQgYXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBzcHJpdGUtc2hlZXQgYW5kIGFzIHN1Y2ggd2lsbCBOT1QgYmUgYW5pbWF0ZWQuXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0ZXh0dXJlLmZyYW1lQ291bnQ9dGV4dHVyZS5mcmFtZXMueCAqIHRleHR1cmUuZnJhbWVzLnldIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcHJpdGUtc2hlZXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvd3MgZm9yIHNwcml0ZS1zaGVldHMgdGhhdCBkb24ndCBmaWxsIHRoZSBlbnRpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHRleHR1cmUubG9vcCBUaGUgbnVtYmVyIG9mIGxvb3BzIHRocm91Z2ggdGhlIHNwcml0ZS1zaGVldCB0aGF0IHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBwZXJmb3JtZWQgb3ZlciB0aGUgY291cnNlIG9mIGEgc2luZ2xlIHBhcnRpY2xlJ3MgbGlmZXRpbWUuXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGZpeGVkVGltZVN0ZXAgSWYgbm8gYGR0YCAob3IgYGRlbHRhVGltZWApIHZhbHVlIGlzIHBhc3NlZCB0byB0aGlzIGdyb3VwJ3NcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB0aWNrKClgIGZ1bmN0aW9uLCB0aGlzIG51bWJlciB3aWxsIGJlIHVzZWQgdG8gbW92ZSB0aGUgcGFydGljbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRpb24gZm9yd2FyZC4gVmFsdWUgaW4gU0VDT05EUy5cbiAqXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGhhc1BlcnNwZWN0aXZlIFdoZXRoZXIgdGhlIGRpc3RhbmNlIGEgcGFydGljbGUgaXMgZnJvbSB0aGUgY2FtZXJhIHNob3VsZCBhZmZlY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHBhcnRpY2xlJ3Mgc2l6ZS5cbiAqXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbG9yaXplIFdoZXRoZXIgdGhlIHBhcnRpY2xlcyBpbiB0aGlzIGdyb3VwIHNob3VsZCBiZSByZW5kZXJlZCB3aXRoIGNvbG9yLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGV0aGVyIHRoZSBvbmx5IGNvbG9yIG9mIHBhcnRpY2xlcyB3aWxsIGNvbWUgZnJvbSB0aGUgcHJvdmlkZWQgdGV4dHVyZS5cbiAqXG4gKiBAcHJvcGVydHkge051bWJlcn0gYmxlbmRpbmcgT25lIG9mIFRocmVlLmpzJ3MgYmxlbmRpbmcgbW9kZXMgdG8gYXBwbHkgdG8gdGhpcyBncm91cCdzIGBTaGFkZXJNYXRlcmlhbGAuXG4gKlxuICogQHByb3BlcnR5IHtCb29sZWFufSB0cmFuc3BhcmVudCBXaGV0aGVyIHRoZXNlIHBhcnRpY2xlJ3Mgc2hvdWxkIGJlIHJlbmRlcmVkIHdpdGggdHJhbnNwYXJlbmN5LlxuICpcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhbHBoYVRlc3QgU2V0cyB0aGUgYWxwaGEgdmFsdWUgdG8gYmUgdXNlZCB3aGVuIHJ1bm5pbmcgYW4gYWxwaGEgdGVzdCBvbiB0aGUgYHRleHR1cmUudmFsdWVgIHByb3BlcnR5LiBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBkZXB0aFdyaXRlIFdoZXRoZXIgcmVuZGVyaW5nIHRoZSBncm91cCBoYXMgYW55IGVmZmVjdCBvbiB0aGUgZGVwdGggYnVmZmVyLlxuICpcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVwdGhUZXN0IFdoZXRoZXIgdG8gaGF2ZSBkZXB0aCB0ZXN0IGVuYWJsZWQgd2hlbiByZW5kZXJpbmcgdGhpcyBncm91cC5cbiAqXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGZvZyBXaGV0aGVyIHRoaXMgZ3JvdXAncyBwYXJ0aWNsZXMgc2hvdWxkIGJlIGFmZmVjdGVkIGJ5IHRoZWlyIHNjZW5lJ3MgZm9nLlxuICpcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY2FsZSBUaGUgc2NhbGUgZmFjdG9yIHRvIGFwcGx5IHRvIHRoaXMgZ3JvdXAncyBwYXJ0aWNsZSBzaXplcy4gVXNlZnVsIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcgcGFydGljbGUgc2l6ZXMgdG8gYmUgcmVsYXRpdmUgdG8gcmVuZGVyZXIgc2l6ZS5cbiAqL1xuXG5cbi8qKlxuICogVGhlIFNQRS5Hcm91cCBjbGFzcy4gQ3JlYXRlcyBhIG5ldyBncm91cCwgY29udGFpbmluZyBhIG1hdGVyaWFsLCBnZW9tZXRyeSwgYW5kIG1lc2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0dyb3VwT3B0aW9uc30gb3B0aW9ucyBBIG1hcCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgZ3JvdXAgaW5zdGFuY2UuXG4gKi9cblNQRS5Hcm91cCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB1dGlscyA9IFNQRS51dGlscyxcbiAgICAgICAgdHlwZXMgPSB1dGlscy50eXBlcztcblxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgbWFwIG9mIG9wdGlvbnMgdG8gcGxheSB3aXRoXG4gICAgb3B0aW9ucyA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLCB0eXBlcy5PQkpFQ1QsIHt9ICk7XG4gICAgb3B0aW9ucy50ZXh0dXJlID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMudGV4dHVyZSwgdHlwZXMuT0JKRUNULCB7fSApO1xuXG4gICAgLy8gQXNzaWduIGEgVVVJRCB0byB0aGlzIGluc3RhbmNlXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIC8vIElmIG5vIGBkZWx0YVRpbWVgIHZhbHVlIGlzIHBhc3NlZCB0byB0aGUgYFNQRS5Hcm91cC50aWNrYCBmdW5jdGlvbixcbiAgICAvLyB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQgdG8gYWR2YW5jZSB0aGUgc2ltdWxhdGlvbi5cbiAgICB0aGlzLmZpeGVkVGltZVN0ZXAgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5maXhlZFRpbWVTdGVwLCB0eXBlcy5OVU1CRVIsIDAuMDE2ICk7XG5cbiAgICAvLyBTZXQgcHJvcGVydGllcyB1c2VkIGluIHRoZSB1bmlmb3JtcyBtYXAsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgLy8gdGV4dHVyZSBzdHVmZi5cbiAgICB0aGlzLnRleHR1cmUgPSB1dGlscy5lbnN1cmVJbnN0YW5jZU9mKCBvcHRpb25zLnRleHR1cmUudmFsdWUsIFRIUkVFLlRleHR1cmUsIG51bGwgKTtcbiAgICB0aGlzLnRleHR1cmVGcmFtZXMgPSB1dGlscy5lbnN1cmVJbnN0YW5jZU9mKCBvcHRpb25zLnRleHR1cmUuZnJhbWVzLCBUSFJFRS5WZWN0b3IyLCBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApICk7XG4gICAgdGhpcy50ZXh0dXJlRnJhbWVDb3VudCA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnRleHR1cmUuZnJhbWVDb3VudCwgdHlwZXMuTlVNQkVSLCB0aGlzLnRleHR1cmVGcmFtZXMueCAqIHRoaXMudGV4dHVyZUZyYW1lcy55ICk7XG4gICAgdGhpcy50ZXh0dXJlTG9vcCA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnRleHR1cmUubG9vcCwgdHlwZXMuTlVNQkVSLCAxICk7XG4gICAgdGhpcy50ZXh0dXJlRnJhbWVzLm1heCggbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSApO1xuXG4gICAgdGhpcy5oYXNQZXJzcGVjdGl2ZSA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLmhhc1BlcnNwZWN0aXZlLCB0eXBlcy5CT09MRUFOLCB0cnVlICk7XG4gICAgdGhpcy5jb2xvcml6ZSA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLmNvbG9yaXplLCB0eXBlcy5CT09MRUFOLCB0cnVlICk7XG5cbiAgICB0aGlzLm1heFBhcnRpY2xlQ291bnQgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5tYXhQYXJ0aWNsZUNvdW50LCB0eXBlcy5OVU1CRVIsIG51bGwgKTtcblxuXG4gICAgLy8gU2V0IHByb3BlcnRpZXMgdXNlZCB0byBkZWZpbmUgdGhlIFNoYWRlck1hdGVyaWFsJ3MgYXBwZWFyYW5jZS5cbiAgICB0aGlzLmJsZW5kaW5nID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuYmxlbmRpbmcsIHR5cGVzLk5VTUJFUiwgVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApO1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy50cmFuc3BhcmVudCwgdHlwZXMuQk9PTEVBTiwgdHJ1ZSApO1xuICAgIHRoaXMuYWxwaGFUZXN0ID0gcGFyc2VGbG9hdCggdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuYWxwaGFUZXN0LCB0eXBlcy5OVU1CRVIsIDAuMCApICk7XG4gICAgdGhpcy5kZXB0aFdyaXRlID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuZGVwdGhXcml0ZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKTtcbiAgICB0aGlzLmRlcHRoVGVzdCA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLmRlcHRoVGVzdCwgdHlwZXMuQk9PTEVBTiwgdHJ1ZSApO1xuICAgIHRoaXMuZm9nID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuZm9nLCB0eXBlcy5CT09MRUFOLCB0cnVlICk7XG4gICAgdGhpcy5zY2FsZSA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnNjYWxlLCB0eXBlcy5OVU1CRVIsIDMwMCApO1xuXG4gICAgLy8gV2hlcmUgZW1pdHRlcidzIGdvIHRvIGN1cmwgdXAgaW4gYSB3YXJtIGJsYW5rZXQgYW5kIGxpdmVcbiAgICAvLyBvdXQgdGhlaXIgZGF5cy5cbiAgICB0aGlzLmVtaXR0ZXJzID0gW107XG4gICAgdGhpcy5lbWl0dGVySURzID0gW107XG5cbiAgICAvLyBDcmVhdGUgcHJvcGVydGllcyBmb3IgdXNlIGJ5IHRoZSBlbWl0dGVyIHBvb2xpbmcgZnVuY3Rpb25zLlxuICAgIHRoaXMuX3Bvb2wgPSBbXTtcbiAgICB0aGlzLl9wb29sQ3JlYXRpb25TZXR0aW5ncyA9IG51bGw7XG4gICAgdGhpcy5fY3JlYXRlTmV3V2hlblBvb2xFbXB0eSA9IDA7XG5cbiAgICAvLyBXaGV0aGVyIGFsbCBhdHRyaWJ1dGVzIHNob3VsZCBiZSBmb3JjZWQgdG8gdXBkYXRlZFxuICAgIC8vIHRoZWlyIGVudGlyZSBidWZmZXIgY29udGVudHMgb24gdGhlIG5leHQgdGljay5cbiAgICAvL1xuICAgIC8vIFVzZWQgd2hlbiBhbiBlbWl0dGVyIGlzIHJlbW92ZWQuXG4gICAgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID0gZmFsc2U7XG4gICAgdGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgPSBmYWxzZTtcblxuICAgIHRoaXMucGFydGljbGVDb3VudCA9IDA7XG5cblxuICAgIC8vIE1hcCBvZiB1bmlmb3JtcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBTaGFkZXJNYXRlcmlhbCBpbnN0YW5jZS5cbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICB0ZXh0dXJlOiB7XG4gICAgICAgICAgICB0eXBlOiAndCcsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50ZXh0dXJlXG4gICAgICAgIH0sXG4gICAgICAgIHRleHR1cmVBbmltYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6ICd2NCcsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlRnJhbWVzLngsXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlRnJhbWVzLnksXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlRnJhbWVDb3VudCxcbiAgICAgICAgICAgICAgICBNYXRoLm1heCggTWF0aC5hYnMoIHRoaXMudGV4dHVyZUxvb3AgKSwgMS4wIClcbiAgICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgZm9nQ29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjJyxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGZvZ05lYXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgICAgIHZhbHVlOiAxMFxuICAgICAgICB9LFxuICAgICAgICBmb2dGYXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgICAgIHZhbHVlOiAyMDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9nRGVuc2l0eToge1xuICAgICAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICAgICAgdmFsdWU6IDAuNVxuICAgICAgICB9LFxuICAgICAgICBkZWx0YVRpbWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJ1blRpbWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FsZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBzb21lIGRlZmluZXMgaW50byB0aGUgbWl4Li4uXG4gICAgdGhpcy5kZWZpbmVzID0ge1xuICAgICAgICBIQVNfUEVSU1BFQ1RJVkU6IHRoaXMuaGFzUGVyc3BlY3RpdmUsXG4gICAgICAgIENPTE9SSVpFOiB0aGlzLmNvbG9yaXplLFxuICAgICAgICBWQUxVRV9PVkVSX0xJRkVUSU1FX0xFTkdUSDogU1BFLnZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoLFxuXG4gICAgICAgIFNIT1VMRF9ST1RBVEVfVEVYVFVSRTogZmFsc2UsXG4gICAgICAgIFNIT1VMRF9ST1RBVEVfUEFSVElDTEVTOiBmYWxzZSxcbiAgICAgICAgU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVM6IGZhbHNlLFxuXG4gICAgICAgIFNIT1VMRF9DQUxDVUxBVEVfU1BSSVRFOiB0aGlzLnRleHR1cmVGcmFtZXMueCA+IDEgfHwgdGhpcy50ZXh0dXJlRnJhbWVzLnkgPiAxXG4gICAgfTtcblxuICAgIC8vIE1hcCBvZiBhbGwgYXR0cmlidXRlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBwYXJ0aWNsZXMuXG4gICAgLy9cbiAgICAvLyBTZWUgU1BFLlNoYWRlckF0dHJpYnV0ZSBmb3IgYSBiaXQgbW9yZSBpbmZvIG9uIHRoaXMgYml0LlxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgcG9zaXRpb246IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKCAndjMnLCB0cnVlICksXG4gICAgICAgIGFjY2VsZXJhdGlvbjogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoICd2NCcsIHRydWUgKSwgLy8gdyBjb21wb25lbnQgaXMgZHJhZ1xuICAgICAgICB2ZWxvY2l0eTogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoICd2MycsIHRydWUgKSxcbiAgICAgICAgcm90YXRpb246IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKCAndjQnLCB0cnVlICksXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZSggJ3YzJywgdHJ1ZSApLFxuICAgICAgICBwYXJhbXM6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKCAndjQnLCB0cnVlICksIC8vIEhvbGRzIChhbGl2ZSwgYWdlLCBkZWxheSwgd2lnZ2xlKVxuICAgICAgICBzaXplOiBuZXcgU1BFLlNoYWRlckF0dHJpYnV0ZSggJ3Y0JywgdHJ1ZSApLFxuICAgICAgICBhbmdsZTogbmV3IFNQRS5TaGFkZXJBdHRyaWJ1dGUoICd2NCcsIHRydWUgKSxcbiAgICAgICAgY29sb3I6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKCAndjQnLCB0cnVlICksXG4gICAgICAgIG9wYWNpdHk6IG5ldyBTUEUuU2hhZGVyQXR0cmlidXRlKCAndjQnLCB0cnVlIClcbiAgICB9O1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVLZXlzID0gT2JqZWN0LmtleXMoIHRoaXMuYXR0cmlidXRlcyApO1xuICAgIHRoaXMuYXR0cmlidXRlQ291bnQgPSB0aGlzLmF0dHJpYnV0ZUtleXMubGVuZ3RoO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBTaGFkZXJNYXRlcmlhbCBpbnN0YW5jZSB0aGF0J2xsIGhlbHAgcmVuZGVyIHRoZVxuICAgIC8vIHBhcnRpY2xlcy5cbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFNQRS5zaGFkZXJzLnZlcnRleCxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFNQRS5zaGFkZXJzLmZyYWdtZW50LFxuICAgICAgICBibGVuZGluZzogdGhpcy5ibGVuZGluZyxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgIGFscGhhVGVzdDogdGhpcy5hbHBoYVRlc3QsXG4gICAgICAgIGRlcHRoV3JpdGU6IHRoaXMuZGVwdGhXcml0ZSxcbiAgICAgICAgZGVwdGhUZXN0OiB0aGlzLmRlcHRoVGVzdCxcbiAgICAgICAgZGVmaW5lczogdGhpcy5kZWZpbmVzLFxuICAgICAgICBmb2c6IHRoaXMuZm9nXG4gICAgfSApO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBCdWZmZXJHZW9tZXRyeSBhbmQgUG9pbnRzIGluc3RhbmNlcywgZW5zdXJpbmdcbiAgICAvLyB0aGUgZ2VvbWV0cnkgYW5kIG1hdGVyaWFsIGFyZSBnaXZlbiB0byB0aGUgbGF0dGVyLlxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICB0aGlzLm1lc2ggPSBuZXcgVEhSRUUuUG9pbnRzKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cbiAgICBpZiAoIHRoaXMubWF4UGFydGljbGVDb3VudCA9PT0gbnVsbCApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCAnU1BFLkdyb3VwOiBObyBtYXhQYXJ0aWNsZUNvdW50IHNwZWNpZmllZC4gQWRkaW5nIGVtaXR0ZXJzIGFmdGVyIHJlbmRlcmluZyB3aWxsIHByb2JhYmx5IGNhdXNlIGVycm9ycy4nICk7XG4gICAgfVxufTtcblxuU1BFLkdyb3VwLmNvbnN0cnVjdG9yID0gU1BFLkdyb3VwO1xuXG5cblNQRS5Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZURlZmluZXMgPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZW1pdHRlcnMgPSB0aGlzLmVtaXR0ZXJzLFxuICAgICAgICBpID0gZW1pdHRlcnMubGVuZ3RoIC0gMSxcbiAgICAgICAgZW1pdHRlcixcbiAgICAgICAgZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcblxuICAgIGZvciAoIGk7IGkgPj0gMDsgLS1pICkge1xuICAgICAgICBlbWl0dGVyID0gZW1pdHRlcnNbIGkgXTtcblxuICAgICAgICAvLyBPbmx5IGRvIGFuZ2xlIGNhbGN1bGF0aW9uIGlmIHRoZXJlJ3Mgbm8gc3ByaXRlc2hlZXQgZGVmaW5lZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2F2ZXMgY2FsY3VsYXRpb25zIGJlaW5nIGRvbmUgYW5kIHRoZW4gb3ZlcndyaXR0ZW4gaW4gdGhlIHNoYWRlcnMuXG4gICAgICAgIGlmICggIWRlZmluZXMuU0hPVUxEX0NBTENVTEFURV9TUFJJVEUgKSB7XG4gICAgICAgICAgICBkZWZpbmVzLlNIT1VMRF9ST1RBVEVfVEVYVFVSRSA9IGRlZmluZXMuU0hPVUxEX1JPVEFURV9URVhUVVJFIHx8ICEhTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgTWF0aC5tYXguYXBwbHkoIG51bGwsIGVtaXR0ZXIuYW5nbGUudmFsdWUgKSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heC5hcHBseSggbnVsbCwgZW1pdHRlci5hbmdsZS5zcHJlYWQgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmluZXMuU0hPVUxEX1JPVEFURV9QQVJUSUNMRVMgPSBkZWZpbmVzLlNIT1VMRF9ST1RBVEVfUEFSVElDTEVTIHx8ICEhTWF0aC5tYXgoXG4gICAgICAgICAgICBlbWl0dGVyLnJvdGF0aW9uLmFuZ2xlLFxuICAgICAgICAgICAgZW1pdHRlci5yb3RhdGlvbi5hbmdsZVNwcmVhZFxuICAgICAgICApO1xuXG4gICAgICAgIGRlZmluZXMuU0hPVUxEX1dJR0dMRV9QQVJUSUNMRVMgPSBkZWZpbmVzLlNIT1VMRF9XSUdHTEVfUEFSVElDTEVTIHx8ICEhTWF0aC5tYXgoXG4gICAgICAgICAgICBlbWl0dGVyLndpZ2dsZS52YWx1ZSxcbiAgICAgICAgICAgIGVtaXR0ZXIud2lnZ2xlLnNwcmVhZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxuU1BFLkdyb3VwLnByb3RvdHlwZS5fYXBwbHlBdHRyaWJ1dGVzVG9HZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnksXG4gICAgICAgIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMsXG4gICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgZ2VvbWV0cnlBdHRyaWJ1dGU7XG5cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzaGFkZXIgYXR0cmlidXRlcyBhbmQgYXNzaWduIChvciByZS1hc3NpZ24pXG4gICAgLy8gdHlwZWQgYXJyYXkgYnVmZmVycyB0byBlYWNoIG9uZS5cbiAgICBmb3IgKCB2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzICkge1xuICAgICAgICBpZiAoIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoIGF0dHIgKSApIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGF0dHIgXTtcbiAgICAgICAgICAgIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBhdHRyIF07XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgYXJyYXkgaWYgdGhpcyBhdHRyaWJ1dGUgZXhpc3RzIG9uIHRoZSBnZW9tZXRyeS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgYmVjYXVzZSB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXkgbWlnaHQgaGF2ZVxuICAgICAgICAgICAgLy8gYmVlbiByZXNpemVkIGFuZCByZWluc3RhbnRpYXRlZCwgYW5kIG1pZ2h0IG5vdyBiZSBsb29raW5nIGF0IGFcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBBcnJheUJ1ZmZlciwgc28gcmVmZXJlbmNlIG5lZWRzIHVwZGF0aW5nLlxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSApIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeUF0dHJpYnV0ZS5hcnJheSA9IGF0dHJpYnV0ZS50eXBlZEFycmF5LmFycmF5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAvLyBBZGQgdGhlIGF0dHJpYnV0ZSB0byB0aGUgZ2VvbWV0cnkgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCBhdHRyLCBhdHRyaWJ1dGUuYnVmZmVyQXR0cmlidXRlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIGF0dHJpYnV0ZSBhcyBuZWVkaW5nIGFuIHVwZGF0ZSB0aGUgbmV4dCB0aW1lIGEgZnJhbWUgaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hcmsgdGhlIGRyYXcgcmFuZ2Ugb24gdGhlIGdlb21ldHJ5LiBUaGlzIHdpbGwgZW5zdXJlXG4gICAgLy8gb25seSB0aGUgdmFsdWVzIGluIHRoZSBhdHRyaWJ1dGUgYnVmZmVycyB0aGF0IGFyZVxuICAgIC8vIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY2xlIHdpbGwgYmUgdXNlZCBpbiBUSFJFRSdzXG4gICAgLy8gcmVuZGVyIGN5Y2xlLlxuICAgIHRoaXMuZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKCAwLCB0aGlzLnBhcnRpY2xlQ291bnQgKTtcbn07XG5cbi8qKlxuICogQWRkcyBhbiBTUEUuRW1pdHRlciBpbnN0YW5jZSB0byB0aGlzIGdyb3VwLCBjcmVhdGluZyBwYXJ0aWNsZSB2YWx1ZXMgYW5kXG4gKiBhc3NpZ25pbmcgdGhlbSB0byB0aGlzIGdyb3VwJ3Mgc2hhZGVyIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHtFbWl0dGVyfSBlbWl0dGVyIFRoZSBlbWl0dGVyIHRvIGFkZCB0byB0aGlzIGdyb3VwLlxuICovXG5TUEUuR3JvdXAucHJvdG90eXBlLmFkZEVtaXR0ZXIgPSBmdW5jdGlvbiggZW1pdHRlciApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBFbnN1cmUgYW4gYWN0dWFsIGVtaXR0ZXIgaW5zdGFuY2UgaXMgcGFzc2VkIGhlcmUuXG4gICAgLy9cbiAgICAvLyBEZWNpZGVkIG5vdCB0byB0aHJvdyBoZXJlLCBqdXN0IGluIGNhc2UgYSBzY2VuZSdzXG4gICAgLy8gcmVuZGVyaW5nIHdvdWxkIGJlIHBhdXNlZC4gTG9nZ2luZyBhbiBlcnJvciBpbnN0ZWFkXG4gICAgLy8gb2Ygc3RvcHBpbmcgZXhlY3V0aW9uIGlmIGV4Y2VwdGlvbnMgYXJlbid0IGNhdWdodC5cbiAgICBpZiAoIGVtaXR0ZXIgaW5zdGFuY2VvZiBTUEUuRW1pdHRlciA9PT0gZmFsc2UgKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdgZW1pdHRlcmAgYXJndW1lbnQgbXVzdCBiZSBpbnN0YW5jZSBvZiBTUEUuRW1pdHRlci4gV2FzIHByb3ZpZGVkIHdpdGg6JywgZW1pdHRlciApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGVtaXR0ZXIgYWxyZWFkeSBleGlzdHMgYXMgYSBtZW1iZXIgb2YgdGhpcyBncm91cCwgdGhlblxuICAgIC8vIHN0b3AgaGVyZSwgd2UgZG9uJ3Qgd2FudCB0byBhZGQgaXQgYWdhaW4uXG4gICAgZWxzZSBpZiAoIHRoaXMuZW1pdHRlcklEcy5pbmRleE9mKCBlbWl0dGVyLnV1aWQgKSA+IC0xICkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCAnRW1pdHRlciBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIGdyb3VwLiBXaWxsIG5vdCBhZGQgYWdhaW4uJyApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQW5kIGZpbmFsbHksIGlmIHRoZSBlbWl0dGVyIGlzIGEgbWVtYmVyIG9mIGFub3RoZXIgZ3JvdXAsXG4gICAgLy8gZG9uJ3QgYWRkIGl0IHRvIHRoaXMgZ3JvdXAuXG4gICAgZWxzZSBpZiAoIGVtaXR0ZXIuZ3JvdXAgIT09IG51bGwgKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdFbWl0dGVyIGFscmVhZHkgYmVsb25ncyB0byBhbm90aGVyIGdyb3VwLiBXaWxsIG5vdCBhZGQgdG8gcmVxdWVzdGVkIGdyb3VwLicgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICBzdGFydCA9IHRoaXMucGFydGljbGVDb3VudCxcbiAgICAgICAgZW5kID0gc3RhcnQgKyBlbWl0dGVyLnBhcnRpY2xlQ291bnQ7XG5cbiAgICAvLyBVcGRhdGUgdGhpcyBncm91cCdzIHBhcnRpY2xlIGNvdW50LlxuICAgIHRoaXMucGFydGljbGVDb3VudCA9IGVuZDtcblxuICAgIC8vIEVtaXQgYSB3YXJuaW5nIGlmIHRoZSBlbWl0dGVyIGJlaW5nIGFkZGVkIHdpbGwgZXhjZWVkIHRoZSBidWZmZXIgc2l6ZXMgc3BlY2lmaWVkLlxuICAgIGlmICggdGhpcy5tYXhQYXJ0aWNsZUNvdW50ICE9PSBudWxsICYmIHRoaXMucGFydGljbGVDb3VudCA+IHRoaXMubWF4UGFydGljbGVDb3VudCApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCAnU1BFLkdyb3VwOiBtYXhQYXJ0aWNsZUNvdW50IGV4Y2VlZGVkLiBSZXF1ZXN0aW5nJywgdGhpcy5wYXJ0aWNsZUNvdW50LCAncGFydGljbGVzLCBjYW4gc3VwcG9ydCBvbmx5JywgdGhpcy5tYXhQYXJ0aWNsZUNvdW50ICk7XG4gICAgfVxuXG5cbiAgICAvLyBTZXQgdGhlIGBwYXJ0aWNsZXNQZXJTZWNvbmRgIHZhbHVlIChQUFMpIG9uIHRoZSBlbWl0dGVyLlxuICAgIC8vIEl0J3MgdXNlZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgcGFydGljbGVzIHRvIHJlbGVhc2VcbiAgICAvLyBvbiBhIHBlci1mcmFtZSBiYXNpcy5cbiAgICBlbWl0dGVyLl9jYWxjdWxhdGVQUFNWYWx1ZSggZW1pdHRlci5tYXhBZ2UuX3ZhbHVlICsgZW1pdHRlci5tYXhBZ2UuX3NwcmVhZCApO1xuICAgIGVtaXR0ZXIuX3NldEJ1ZmZlclVwZGF0ZVJhbmdlcyggdGhpcy5hdHRyaWJ1dGVLZXlzICk7XG5cbiAgICAvLyBTdG9yZSB0aGUgb2Zmc2V0IHZhbHVlIGluIHRoZSBUeXBlZEFycmF5IGF0dHJpYnV0ZXMgZm9yIHRoaXMgZW1pdHRlci5cbiAgICBlbWl0dGVyLl9zZXRBdHRyaWJ1dGVPZmZzZXQoIHN0YXJ0ICk7XG5cbiAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoaXMgZ3JvdXAgb24gdGhlIGVtaXR0ZXIgc28gaXQga25vd3NcbiAgICAvLyB3aGVyZSBpdCBiZWxvbmdzLlxuICAgIGVtaXR0ZXIuZ3JvdXAgPSB0aGlzO1xuXG4gICAgLy8gU3RvcmUgcmVmZXJlbmNlIHRvIHRoZSBhdHRyaWJ1dGVzIG9uIHRoZSBlbWl0dGVyIGZvclxuICAgIC8vIGVhc2llciBhY2Nlc3MgZHVyaW5nIHRoZSBlbWl0dGVyJ3MgdGljayBmdW5jdGlvbi5cbiAgICBlbWl0dGVyLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblxuXG4gICAgLy8gRW5zdXJlIHRoZSBhdHRyaWJ1dGVzIGFuZCB0aGVpciBCdWZmZXJBdHRyaWJ1dGVzIGV4aXN0LCBhbmQgdGhlaXJcbiAgICAvLyBUeXBlZEFycmF5cyBhcmUgb2YgdGhlIGNvcnJlY3Qgc2l6ZS5cbiAgICBmb3IgKCB2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzICkge1xuICAgICAgICBpZiAoIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoIGF0dHIgKSApIHtcbiAgICAgICAgICAgIC8vIFdoZW4gY3JlYXRpbmcgYSBidWZmZXIsIHBhc3MgdGhyb3VnaCB0aGUgbWF4UGFydGljbGUgY291bnRcbiAgICAgICAgICAgIC8vIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWyBhdHRyIF0uX2NyZWF0ZUJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICB0aGlzLm1heFBhcnRpY2xlQ291bnQgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgIHRoaXMubWF4UGFydGljbGVDb3VudCA6XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZUNvdW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggcGFydGljbGUgdGhpcyBlbWl0dGVyIHdhbnRzIHRvIGhhdmUsIGFuZCBjcmVhdGUgdGhlIGF0dHJpYnV0ZXMgdmFsdWVzLFxuICAgIC8vIHN0b3JpbmcgdGhlbSBpbiB0aGUgVHlwZWRBcnJheXMgdGhhdCBlYWNoIGF0dHJpYnV0ZSBob2xkcy5cbiAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kgKSB7XG4gICAgICAgIGVtaXR0ZXIuX2Fzc2lnblBvc2l0aW9uVmFsdWUoIGkgKTtcbiAgICAgICAgZW1pdHRlci5fYXNzaWduRm9yY2VWYWx1ZSggaSwgJ3ZlbG9jaXR5JyApO1xuICAgICAgICBlbWl0dGVyLl9hc3NpZ25Gb3JjZVZhbHVlKCBpLCAnYWNjZWxlcmF0aW9uJyApO1xuICAgICAgICBlbWl0dGVyLl9hc3NpZ25BYnNMaWZldGltZVZhbHVlKCBpLCAnb3BhY2l0eScgKTtcbiAgICAgICAgZW1pdHRlci5fYXNzaWduQWJzTGlmZXRpbWVWYWx1ZSggaSwgJ3NpemUnICk7XG4gICAgICAgIGVtaXR0ZXIuX2Fzc2lnbkFuZ2xlVmFsdWUoIGkgKTtcbiAgICAgICAgZW1pdHRlci5fYXNzaWduUm90YXRpb25WYWx1ZSggaSApO1xuICAgICAgICBlbWl0dGVyLl9hc3NpZ25QYXJhbXNWYWx1ZSggaSApO1xuICAgICAgICBlbWl0dGVyLl9hc3NpZ25Db2xvclZhbHVlKCBpICk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBhbmQgbWFrZSBzdXJlIHRoZSBhdHRyaWJ1dGVzIGFyZSByZWZlcmVuY2luZ1xuICAgIC8vIHRoZSB0eXBlZCBhcnJheXMgcHJvcGVybHkuXG4gICAgdGhpcy5fYXBwbHlBdHRyaWJ1dGVzVG9HZW9tZXRyeSgpO1xuXG4gICAgLy8gU3RvcmUgdGhpcyBlbWl0dGVyIGluIHRoaXMgZ3JvdXAncyBlbWl0dGVyJ3Mgc3RvcmUuXG4gICAgdGhpcy5lbWl0dGVycy5wdXNoKCBlbWl0dGVyICk7XG4gICAgdGhpcy5lbWl0dGVySURzLnB1c2goIGVtaXR0ZXIudXVpZCApO1xuXG4gICAgLy8gVXBkYXRlIGNlcnRhaW4gZmxhZ3MgdG8gZW5hYmxlIHNoYWRlciBjYWxjdWxhdGlvbnMgb25seSBpZiB0aGV5J3JlIG5lY2Vzc2FyeS5cbiAgICB0aGlzLl91cGRhdGVEZWZpbmVzKCBlbWl0dGVyICk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIG1hdGVyaWFsIHNpbmNlIGRlZmluZXMgbWlnaHQgaGF2ZSBjaGFuZ2VkXG4gICAgdGhpcy5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5nZW9tZXRyeS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID0gdHJ1ZTtcblxuICAgIC8vIFJldHVybiB0aGUgZ3JvdXAgdG8gZW5hYmxlIGNoYWluaW5nLlxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIFNQRS5FbWl0dGVyIGluc3RhbmNlIGZyb20gdGhpcyBncm91cC4gV2hlbiBjYWxsZWQsXG4gKiBhbGwgcGFydGljbGUncyBiZWxvbmdpbmcgdG8gdGhlIGdpdmVuIGVtaXR0ZXIgd2lsbCBiZSBpbnN0YW50bHlcbiAqIHJlbW92ZWQgZnJvbSB0aGUgc2NlbmUuXG4gKlxuICogQHBhcmFtIHtFbWl0dGVyfSBlbWl0dGVyIFRoZSBlbWl0dGVyIHRvIGFkZCB0byB0aGlzIGdyb3VwLlxuICovXG5TUEUuR3JvdXAucHJvdG90eXBlLnJlbW92ZUVtaXR0ZXIgPSBmdW5jdGlvbiggZW1pdHRlciApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZW1pdHRlckluZGV4ID0gdGhpcy5lbWl0dGVySURzLmluZGV4T2YoIGVtaXR0ZXIudXVpZCApO1xuXG4gICAgLy8gRW5zdXJlIGFuIGFjdHVhbCBlbWl0dGVyIGluc3RhbmNlIGlzIHBhc3NlZCBoZXJlLlxuICAgIC8vXG4gICAgLy8gRGVjaWRlZCBub3QgdG8gdGhyb3cgaGVyZSwganVzdCBpbiBjYXNlIGEgc2NlbmUnc1xuICAgIC8vIHJlbmRlcmluZyB3b3VsZCBiZSBwYXVzZWQuIExvZ2dpbmcgYW4gZXJyb3IgaW5zdGVhZFxuICAgIC8vIG9mIHN0b3BwaW5nIGV4ZWN1dGlvbiBpZiBleGNlcHRpb25zIGFyZW4ndCBjYXVnaHQuXG4gICAgaWYgKCBlbWl0dGVyIGluc3RhbmNlb2YgU1BFLkVtaXR0ZXIgPT09IGZhbHNlICkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCAnYGVtaXR0ZXJgIGFyZ3VtZW50IG11c3QgYmUgaW5zdGFuY2Ugb2YgU1BFLkVtaXR0ZXIuIFdhcyBwcm92aWRlZCB3aXRoOicsIGVtaXR0ZXIgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElzc3VlIGFuIGVycm9yIGlmIHRoZSBlbWl0dGVyIGlzbid0IGEgbWVtYmVyIG9mIHRoaXMgZ3JvdXAuXG4gICAgZWxzZSBpZiAoIGVtaXR0ZXJJbmRleCA9PT0gLTEgKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdFbWl0dGVyIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgZ3JvdXAuIFdpbGwgbm90IHJlbW92ZS4nICk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBLaWxsIGFsbCBwYXJ0aWNsZXMgYnkgbWFya2luZyB0aGVtIGFzIGRlYWRcbiAgICAvLyBhbmQgdGhlaXIgYWdlIGFzIDAuXG4gICAgdmFyIHN0YXJ0ID0gZW1pdHRlci5hdHRyaWJ1dGVPZmZzZXQsXG4gICAgICAgIGVuZCA9IHN0YXJ0ICsgZW1pdHRlci5wYXJ0aWNsZUNvdW50LFxuICAgICAgICBwYXJhbXMgPSB0aGlzLmF0dHJpYnV0ZXMucGFyYW1zLnR5cGVkQXJyYXk7XG5cbiAgICAvLyBTZXQgYWxpdmUgYW5kIGFnZSB0byB6ZXJvLlxuICAgIGZvciAoIHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSApIHtcbiAgICAgICAgcGFyYW1zLmFycmF5WyBpICogNCBdID0gMC4wO1xuICAgICAgICBwYXJhbXMuYXJyYXlbIGkgKiA0ICsgMSBdID0gMC4wO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgZW1pdHRlciBmcm9tIHRoaXMgZ3JvdXAncyBcInN0b3JlXCIuXG4gICAgdGhpcy5lbWl0dGVycy5zcGxpY2UoIGVtaXR0ZXJJbmRleCwgMSApO1xuICAgIHRoaXMuZW1pdHRlcklEcy5zcGxpY2UoIGVtaXR0ZXJJbmRleCwgMSApO1xuXG4gICAgLy8gUmVtb3ZlIHRoaXMgZW1pdHRlcidzIGF0dHJpYnV0ZSB2YWx1ZXMgZnJvbSBhbGwgc2hhZGVyIGF0dHJpYnV0ZXMuXG4gICAgLy8gVGhlIGAuc3BsaWNlKClgIGNhbGwgaGVyZSBhbHNvIG1hcmtzIGVhY2ggYXR0cmlidXRlJ3MgYnVmZmVyXG4gICAgLy8gYXMgbmVlZGluZyB0byB1cGRhdGUgaXQncyBlbnRpcmUgY29udGVudHMuXG4gICAgZm9yICggdmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuICAgICAgICBpZiAoIHRoaXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSggYXR0ciApICkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0uc3BsaWNlKCBzdGFydCwgZW5kICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhpcyBncm91cCdzIHBhcnRpY2xlIGNvdW50IGlzIGNvcnJlY3QuXG4gICAgdGhpcy5wYXJ0aWNsZUNvdW50IC09IGVtaXR0ZXIucGFydGljbGVDb3VudDtcblxuICAgIC8vIENhbGwgdGhlIGVtaXR0ZXIncyByZW1vdmUgbWV0aG9kLlxuICAgIGVtaXR0ZXIuX29uUmVtb3ZlKCk7XG5cbiAgICAvLyBTZXQgYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIGF0dHJpYnV0ZSBidWZmZXJzIHNob3VsZFxuICAgIC8vIGJlIHVwZGF0ZWQgaW4gdGhlaXIgZW50aXJldHkgb24gdGhlIG5leHQgZnJhbWUuXG4gICAgdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBGZXRjaCBhIHNpbmdsZSBlbWl0dGVyIGluc3RhbmNlIGZyb20gdGhlIHBvb2wuXG4gKiBJZiB0aGVyZSBhcmUgbm8gb2JqZWN0cyBpbiB0aGUgcG9vbCwgYSBuZXcgZW1pdHRlciB3aWxsIGJlXG4gKiBjcmVhdGVkIGlmIHNwZWNpZmllZC5cbiAqXG4gKiBAcmV0dXJuIHtFbWl0dGVyfG51bGx9XG4gKi9cblNQRS5Hcm91cC5wcm90b3R5cGUuZ2V0RnJvbVBvb2wgPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgcG9vbCA9IHRoaXMuX3Bvb2wsXG4gICAgICAgIGNyZWF0ZU5ldyA9IHRoaXMuX2NyZWF0ZU5ld1doZW5Qb29sRW1wdHk7XG5cbiAgICBpZiAoIHBvb2wubGVuZ3RoICkge1xuICAgICAgICByZXR1cm4gcG9vbC5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIGNyZWF0ZU5ldyApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTUEUuRW1pdHRlciggdGhpcy5fcG9vbENyZWF0aW9uU2V0dGluZ3MgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSZWxlYXNlIGFuIGVtaXR0ZXIgaW50byB0aGUgcG9vbC5cbiAqXG4gKiBAcGFyYW0gIHtTaGFkZXJQYXJ0aWNsZUVtaXR0ZXJ9IGVtaXR0ZXJcbiAqIEByZXR1cm4ge0dyb3VwfSBUaGlzIGdyb3VwIGluc3RhbmNlLlxuICovXG5TUEUuR3JvdXAucHJvdG90eXBlLnJlbGVhc2VJbnRvUG9vbCA9IGZ1bmN0aW9uKCBlbWl0dGVyICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICggZW1pdHRlciBpbnN0YW5jZW9mIFNQRS5FbWl0dGVyID09PSBmYWxzZSApIHtcbiAgICAgICAgY29uc29sZS5lcnJvciggJ0FyZ3VtZW50IGlzIG5vdCBpbnN0YW5jZW9mIFNQRS5FbWl0dGVyOicsIGVtaXR0ZXIgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVtaXR0ZXIucmVzZXQoKTtcbiAgICB0aGlzLl9wb29sLnVuc2hpZnQoIGVtaXR0ZXIgKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgcG9vbCBhcnJheVxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TUEUuR3JvdXAucHJvdG90eXBlLmdldFBvb2wgPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIHRoaXMuX3Bvb2w7XG59O1xuXG5cbi8qKlxuICogQWRkIGEgcG9vbCBvZiBlbWl0dGVycyB0byB0aGlzIHBhcnRpY2xlIGdyb3VwXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bUVtaXR0ZXJzICAgICAgVGhlIG51bWJlciBvZiBlbWl0dGVycyB0byBhZGQgdG8gdGhlIHBvb2wuXG4gKiBAcGFyYW0ge0VtaXR0ZXJPcHRpb25zfEFycmF5fSBlbWl0dGVyT3B0aW9ucyAgQW4gb2JqZWN0LCBvciBhcnJheSBvZiBvYmplY3RzLCBkZXNjcmliaW5nIHRoZSBvcHRpb25zIHRvIHBhc3MgdG8gZWFjaCBlbWl0dGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVOZXcgICAgICAgU2hvdWxkIGEgbmV3IGVtaXR0ZXIgYmUgY3JlYXRlZCBpZiB0aGUgcG9vbCBydW5zIG91dD9cbiAqIEByZXR1cm4ge0dyb3VwfSBUaGlzIGdyb3VwIGluc3RhbmNlLlxuICovXG5TUEUuR3JvdXAucHJvdG90eXBlLmFkZFBvb2wgPSBmdW5jdGlvbiggbnVtRW1pdHRlcnMsIGVtaXR0ZXJPcHRpb25zLCBjcmVhdGVOZXcgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGVtaXR0ZXI7XG5cbiAgICAvLyBTYXZlIHJlbGV2YW50IHNldHRpbmdzIGFuZCBmbGFncy5cbiAgICB0aGlzLl9wb29sQ3JlYXRpb25TZXR0aW5ncyA9IGVtaXR0ZXJPcHRpb25zO1xuICAgIHRoaXMuX2NyZWF0ZU5ld1doZW5Qb29sRW1wdHkgPSAhIWNyZWF0ZU5ldztcblxuICAgIC8vIENyZWF0ZSB0aGUgZW1pdHRlcnMsIGFkZCB0aGVtIHRvIHRoaXMgZ3JvdXAgYW5kIHRoZSBwb29sLlxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG51bUVtaXR0ZXJzOyArK2kgKSB7XG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggZW1pdHRlck9wdGlvbnMgKSApIHtcbiAgICAgICAgICAgIGVtaXR0ZXIgPSBuZXcgU1BFLkVtaXR0ZXIoIGVtaXR0ZXJPcHRpb25zWyBpIF0gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVtaXR0ZXIgPSBuZXcgU1BFLkVtaXR0ZXIoIGVtaXR0ZXJPcHRpb25zICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFbWl0dGVyKCBlbWl0dGVyICk7XG4gICAgICAgIHRoaXMucmVsZWFzZUludG9Qb29sKCBlbWl0dGVyICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuU1BFLkdyb3VwLnByb3RvdHlwZS5fdHJpZ2dlclNpbmdsZUVtaXR0ZXIgPSBmdW5jdGlvbiggcG9zICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBlbWl0dGVyID0gdGhpcy5nZXRGcm9tUG9vbCgpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGlmICggZW1pdHRlciA9PT0gbnVsbCApIHtcbiAgICAgICAgY29uc29sZS5sb2coICdTUEUuR3JvdXAgcG9vbCByYW4gb3V0LicgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBNYWtlIHN1cmUgYnVmZmVycyBhcmUgdXBkYXRlIHdpdGggdGh1cyBuZXcgcG9zaXRpb24uXG4gICAgaWYgKCBwb3MgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkge1xuICAgICAgICBlbWl0dGVyLnBvc2l0aW9uLnZhbHVlLmNvcHkoIHBvcyApO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIHNldHRlciBmb3IgdGhpcyBwcm9wZXJ0eSB0byBmb3JjZSBhblxuICAgICAgICAvLyB1cGRhdGUgdG8gdGhlIGVtaXR0ZXIncyBwb3NpdGlvbiBhdHRyaWJ1dGUuXG4gICAgICAgIGVtaXR0ZXIucG9zaXRpb24udmFsdWUgPSBlbWl0dGVyLnBvc2l0aW9uLnZhbHVlO1xuICAgIH1cblxuICAgIGVtaXR0ZXIuZW5hYmxlKCk7XG5cbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgZW1pdHRlci5kaXNhYmxlKCk7XG4gICAgICAgIHNlbGYucmVsZWFzZUludG9Qb29sKCBlbWl0dGVyICk7XG4gICAgfSwgKCBNYXRoLm1heCggZW1pdHRlci5kdXJhdGlvbiwgKCBlbWl0dGVyLm1heEFnZS52YWx1ZSArIGVtaXR0ZXIubWF4QWdlLnNwcmVhZCApICkgKSAqIDEwMDAgKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFNldCBhIGdpdmVuIG51bWJlciBvZiBlbWl0dGVycyBhcyBhbGl2ZSwgd2l0aCBhbiBvcHRpb25hbCBwb3NpdGlvblxuICogdmVjdG9yMyB0byBtb3ZlIHRoZW0gdG8uXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBudW1FbWl0dGVycyBUaGUgbnVtYmVyIG9mIGVtaXR0ZXJzIHRvIGFjdGl2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtwb3NpdGlvbj11bmRlZmluZWRdIEEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBwb3NpdGlvbiB0byBhY3RpdmF0ZSB0aGUgZW1pdHRlcihzKSBhdC5cbiAqIEByZXR1cm4ge0dyb3VwfSBUaGlzIGdyb3VwIGluc3RhbmNlLlxuICovXG5TUEUuR3JvdXAucHJvdG90eXBlLnRyaWdnZXJQb29sRW1pdHRlciA9IGZ1bmN0aW9uKCBudW1FbWl0dGVycywgcG9zaXRpb24gKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKCB0eXBlb2YgbnVtRW1pdHRlcnMgPT09ICdudW1iZXInICYmIG51bUVtaXR0ZXJzID4gMSApIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbnVtRW1pdHRlcnM7ICsraSApIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJTaW5nbGVFbWl0dGVyKCBwb3NpdGlvbiApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl90cmlnZ2VyU2luZ2xlRW1pdHRlciggcG9zaXRpb24gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuXG5TUEUuR3JvdXAucHJvdG90eXBlLl91cGRhdGVVbmlmb3JtcyA9IGZ1bmN0aW9uKCBkdCApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLnVuaWZvcm1zLnJ1blRpbWUudmFsdWUgKz0gZHQ7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YVRpbWUudmFsdWUgPSBkdDtcbn07XG5cblNQRS5Hcm91cC5wcm90b3R5cGUuX3Jlc2V0QnVmZmVyUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGtleXMgPSB0aGlzLmF0dHJpYnV0ZUtleXMsXG4gICAgICAgIGkgPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMSxcbiAgICAgICAgYXR0cnMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKCBpOyBpID49IDA7IC0taSApIHtcbiAgICAgICAgYXR0cnNbIGtleXNbIGkgXSBdLnJlc2V0VXBkYXRlUmFuZ2UoKTtcbiAgICB9XG59O1xuXG5cblNQRS5Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZUJ1ZmZlcnMgPSBmdW5jdGlvbiggZW1pdHRlciApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuYXR0cmlidXRlS2V5cyxcbiAgICAgICAgaSA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxLFxuICAgICAgICBhdHRycyA9IHRoaXMuYXR0cmlidXRlcyxcbiAgICAgICAgZW1pdHRlclJhbmdlcyA9IGVtaXR0ZXIuYnVmZmVyVXBkYXRlUmFuZ2VzLFxuICAgICAgICBrZXksXG4gICAgICAgIGVtaXR0ZXJBdHRyLFxuICAgICAgICBhdHRyO1xuXG4gICAgZm9yICggaTsgaSA+PSAwOyAtLWkgKSB7XG4gICAgICAgIGtleSA9IGtleXNbIGkgXTtcbiAgICAgICAgZW1pdHRlckF0dHIgPSBlbWl0dGVyUmFuZ2VzWyBrZXkgXTtcbiAgICAgICAgYXR0ciA9IGF0dHJzWyBrZXkgXTtcbiAgICAgICAgYXR0ci5zZXRVcGRhdGVSYW5nZSggZW1pdHRlckF0dHIubWluLCBlbWl0dGVyQXR0ci5tYXggKTtcbiAgICAgICAgYXR0ci5mbGFnVXBkYXRlKCk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFNpbXVsYXRlIGFsbCB0aGUgZW1pdHRlcidzIGJlbG9uZ2luZyB0byB0aGlzIGdyb3VwLCB1cGRhdGluZ1xuICogYXR0cmlidXRlIHZhbHVlcyBhbG9uZyB0aGUgd2F5LlxuICogQHBhcmFtICB7TnVtYmVyfSBbZHQ9R3JvdXAncyBgZml4ZWRUaW1lU3RlcGAgdmFsdWVdIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBzaW11bGF0ZSB0aGUgZ3JvdXAncyBlbWl0dGVycyBmb3IgKGRlbHRhVGltZSlcbiAqL1xuU1BFLkdyb3VwLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oIGR0ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBlbWl0dGVycyA9IHRoaXMuZW1pdHRlcnMsXG4gICAgICAgIG51bUVtaXR0ZXJzID0gZW1pdHRlcnMubGVuZ3RoLFxuICAgICAgICBkZWx0YVRpbWUgPSBkdCB8fCB0aGlzLmZpeGVkVGltZVN0ZXAsXG4gICAgICAgIGtleXMgPSB0aGlzLmF0dHJpYnV0ZUtleXMsXG4gICAgICAgIGksXG4gICAgICAgIGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgLy8gVXBkYXRlIHVuaWZvcm0gdmFsdWVzLlxuICAgIHRoaXMuX3VwZGF0ZVVuaWZvcm1zKCBkZWx0YVRpbWUgKTtcblxuICAgIC8vIFJlc2V0IGJ1ZmZlciB1cGRhdGUgcmFuZ2VzIG9uIHRoZSBzaGFkZXIgYXR0cmlidXRlcy5cbiAgICB0aGlzLl9yZXNldEJ1ZmZlclJhbmdlcygpO1xuXG5cbiAgICAvLyBJZiBub3RoaW5nIG5lZWRzIHVwZGF0aW5nLCB0aGVuIHN0b3AgaGVyZS5cbiAgICBpZiAoXG4gICAgICAgIG51bUVtaXR0ZXJzID09PSAwICYmXG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCA9PT0gZmFsc2UgJiZcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBlbWl0dGVyIGluIHRoaXMgZ3JvdXAgYW5kXG4gICAgLy8gc2ltdWxhdGUgaXQsIHRoZW4gdXBkYXRlIHRoZSBzaGFkZXIgYXR0cmlidXRlXG4gICAgLy8gYnVmZmVycy5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGVtaXR0ZXI7IGkgPCBudW1FbWl0dGVyczsgKytpICkge1xuICAgICAgICBlbWl0dGVyID0gZW1pdHRlcnNbIGkgXTtcbiAgICAgICAgZW1pdHRlci50aWNrKCBkZWx0YVRpbWUgKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQnVmZmVycyggZW1pdHRlciApO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzaGFkZXIgYXR0cmlidXRlcyBoYXZlIGJlZW4gcmVmcmVzaGVkLFxuICAgIC8vIHRoZW4gdGhlIGR5bmFtaWMgcHJvcGVydGllcyBvZiBlYWNoIGJ1ZmZlclxuICAgIC8vIGF0dHJpYnV0ZSB3aWxsIG5lZWQgdG8gYmUgcmVzZXQgYmFjayB0b1xuICAgIC8vIHdoYXQgdGhleSBzaG91bGQgYmUuXG4gICAgaWYgKCB0aGlzLl9hdHRyaWJ1dGVzTmVlZER5bmFtaWNSZXNldCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgaSA9IHRoaXMuYXR0cmlidXRlQ291bnQgLSAxO1xuXG4gICAgICAgIGZvciAoIGk7IGkgPj0gMDsgLS1pICkge1xuICAgICAgICAgICAgYXR0cnNbIGtleXNbIGkgXSBdLnJlc2V0RHluYW1pYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXR0cmlidXRlc05lZWREeW5hbWljUmVzZXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGdyb3VwJ3Mgc2hhZGVyIGF0dHJpYnV0ZXMgbmVlZCBhIGZ1bGwgcmVmcmVzaFxuICAgIC8vIHRoZW4gbWFyayBlYWNoIGF0dHJpYnV0ZSdzIGJ1ZmZlciBhdHRyaWJ1dGUgYXNcbiAgICAvLyBuZWVkaW5nIHNvLlxuICAgIGlmICggdGhpcy5fYXR0cmlidXRlc05lZWRSZWZyZXNoID09PSB0cnVlICkge1xuICAgICAgICBpID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDE7XG5cbiAgICAgICAgZm9yICggaTsgaSA+PSAwOyAtLWkgKSB7XG4gICAgICAgICAgICBhdHRyc1sga2V5c1sgaSBdIF0uZm9yY2VVcGRhdGVBbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNOZWVkUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzTmVlZER5bmFtaWNSZXNldCA9IHRydWU7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIERpcG9zZSB0aGUgZ2VvbWV0cnkgYW5kIG1hdGVyaWFsIGZvciB0aGUgZ3JvdXAuXG4gKlxuICogQHJldHVybiB7R3JvdXB9IEdyb3VwIGluc3RhbmNlLlxuICovXG5TUEUuR3JvdXAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFuIFNQRS5FbWl0dGVyIGluc3RhbmNlLlxuICogQHR5cGVkZWYge09iamVjdH0gRW1pdHRlclxuICogQHNlZSBTUEUuRW1pdHRlclxuICovXG5cbi8qKlxuICogQSBtYXAgb2Ygb3B0aW9ucyB0byBjb25maWd1cmUgYW4gU1BFLkVtaXR0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRW1pdHRlck9wdGlvbnNcbiAqXG4gKiBAcHJvcGVydHkge2Rpc3RyaWJ1dGlvbn0gW3R5cGU9Qk9YXSBUaGUgZGVmYXVsdCBkaXN0cmlidXRpb24gdGhpcyBlbWl0dGVyIHNob3VsZCB1c2UgdG8gY29udHJvbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaXRzIHBhcnRpY2xlJ3Mgc3Bhd24gcG9zaXRpb24gYW5kIGZvcmNlIGJlaGF2aW91ci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIE11c3QgYmUgYW4gU1BFLmRpc3RyaWJ1dGlvbnMuKiB2YWx1ZS5cbiAqXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYXJ0aWNsZUNvdW50PTEwMF0gVGhlIHRvdGFsIG51bWJlciBvZiBwYXJ0aWNsZXMgdGhpcyBlbWl0dGVyIHdpbGwgaG9sZC4gTk9URTogdGhpcyBpcyBub3QgdGhlIG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgcGFydGljbGVzIGVtaXR0ZWQgaW4gYSBzZWNvbmQsIG9yIGFueXRoaW5nIGxpa2UgdGhhdC4gVGhlIG51bWJlciBvZiBwYXJ0aWNsZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZWQgcGVyLXNlY29uZCBpcyBjYWxjdWxhdGVkIGJ5IHBhcnRpY2xlQ291bnQgLyBtYXhBZ2UgKGFwcHJveGltYXRlbHkhKVxuICpcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IFtkdXJhdGlvbj1udWxsXSBUaGUgZHVyYXRpb24gaW4gc2Vjb25kcyB0aGF0IHRoaXMgZW1pdHRlciBzaG91bGQgbGl2ZSBmb3IuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlbWl0dGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBlbWl0IHBhcnRpY2xlcyBpbmRlZmluaXRlbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9URTogV2hlbiBhbiBlbWl0dGVyIGlzIG9sZGVyIHRoYW4gYSBzcGVjaWZpZWQgZHVyYXRpb24sIHRoZSBlbWl0dGVyIGlzIE5PVCByZW1vdmVkIGZyb21cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCdzIGdyb3VwLCBidXQgcmF0aGVyIGlzIGp1c3QgbWFya2VkIGFzIGRlYWQsIGFsbG93aW5nIGl0IHRvIGJlIHJlYW5pbWF0ZWQgYXQgYSBsYXRlciB0aW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmcgYFNQRS5FbWl0dGVyLnByb3RvdHlwZS5lbmFibGUoKWAuXG4gKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbaXNTdGF0aWM9ZmFsc2VdIFdoZXRoZXIgdGhpcyBlbWl0dGVyIHNob3VsZCBiZSBub3QgYmUgc2ltdWxhdGVkICh0cnVlKS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FjdGl2ZU11bHRpcGxpZXI9MV0gQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZGVzY3JpYmluZyB3aGF0IHBlcmNlbnRhZ2Ugb2YgdGhpcyBlbWl0dGVyJ3MgcGFydGljbGVzUGVyU2Vjb25kIHNob3VsZCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVkLCB3aGVyZSAwIGlzIDAlLCBhbmQgMSBpcyAxMDAlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgaGF2aW5nIGFuIGVtaXR0ZXIgd2l0aCAxMDAgcGFydGljbGVzLCBhIG1heEFnZSBvZiAyLCB5aWVsZHMgYSBwYXJ0aWNsZXNQZXJTZWNvbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgb2YgNTAuIFNldHRpbmcgYGFjdGl2ZU11bHRpcGxpZXJgIHRvIDAuNSwgdGhlbiwgd2lsbCBvbmx5IGVtaXQgMjUgcGFydGljbGVzIHBlciBzZWNvbmQgKDAuNSA9IDUwJSkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlcyBncmVhdGVyIHRoYW4gMSB3aWxsIGVtdWxhdGUgYSBidXJzdCBvZiBwYXJ0aWNsZXMsIGNhdXNpbmcgdGhlIGVtaXR0ZXIgdG8gcnVuIG91dCBvZiBwYXJ0aWNsZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlIGl0J3MgbmV4dCBhY3RpdmF0aW9uIGN5Y2xlLlxuICpcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RpcmVjdGlvbj0xXSBUaGUgZGlyZWN0aW9uIG9mIHRoZSBlbWl0dGVyLiBJZiB2YWx1ZSBpcyBgMWAsIGVtaXR0ZXIgd2lsbCBzdGFydCBhdCBiZWdpbm5pbmcgb2YgcGFydGljbGUncyBsaWZlY3ljbGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdmFsdWUgaXMgYC0xYCwgZW1pdHRlciB3aWxsIHN0YXJ0IGF0IGVuZCBvZiBwYXJ0aWNsZSdzIGxpZmVjeWNsZSBhbmQgd29yayBpdCdzIHdheSBiYWNrd2FyZHMuXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFttYXhBZ2U9e31dIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBwYXJ0aWNsZSdzIG1heGltdW0gYWdlIGluIHNlY29uZHMuXG4gKiBAcHJvcGVydHkge051bWJlcn0gW21heEFnZS52YWx1ZT0yXSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgZGVzY3JpYmluZyB0aGUgYW1vdW50IG9mIG1heEFnZSB0byBhcHBseSB0byBhbGwgcGFydGljbGVzLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYXhBZ2Uuc3ByZWFkPTBdIEEgbnVtYmVyIGRlc2NyaWJpbmcgdGhlIG1heEFnZSB2YXJpYW5jZSBvbiBhIHBlci1wYXJ0aWNsZSBiYXNpcy5cbiAqXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtwb3NpdGlvbj17fV0gQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhpcyBlbWl0dGVyJ3MgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3Bvc2l0aW9uLnZhbHVlPW5ldyBUSFJFRS5WZWN0b3IzKCldIEEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoaXMgZW1pdHRlcidzIGJhc2UgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3Bvc2l0aW9uLnNwcmVhZD1uZXcgVEhSRUUuVmVjdG9yMygpXSBBIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGlzIGVtaXR0ZXIncyBwb3NpdGlvbiB2YXJpYW5jZSBvbiBhIHBlci1wYXJ0aWNsZSBiYXNpcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCB3aGVuIHVzaW5nIGEgU1BIRVJFIG9yIERJU0MgZGlzdHJpYnV0aW9uLCBvbmx5IHRoZSB4LWNvbXBvbmVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyB2ZWN0b3IgaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcG9zaXRpb24uc3ByZWFkQ2xhbXA9bmV3IFRIUkVFLlZlY3RvcjMoKV0gQSBUSFJFRS5WZWN0b3IzIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIG51bWVyaWMgbXVsdGlwbGVzIHRoZSBwYXJ0aWNsZSdzIHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBzcHJlYWQgb3V0IG92ZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCB3aGVuIHVzaW5nIGEgU1BIRVJFIG9yIERJU0MgZGlzdHJpYnV0aW9uLCBvbmx5IHRoZSB4LWNvbXBvbmVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGlzIHZlY3RvciBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwb3NpdGlvbi5yYWRpdXM9MTBdIFRoaXMgZW1pdHRlcidzIGJhc2UgcmFkaXVzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtwb3NpdGlvbi5yYWRpdXNTY2FsZT1uZXcgVEhSRUUuVmVjdG9yMygpXSBBIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgcmFkaXVzJ3Mgc2NhbGUgaW4gYWxsIHRocmVlIGF4ZXMuIEFsbG93cyBhIFNQSEVSRSBvciBESVNDIHRvIGJlIHNxdWFzaGVkIG9yIHN0cmV0Y2hlZC5cbiAqIEBwcm9wZXJ0eSB7ZGlzdHJpYnV0aW9ufSBbcG9zaXRpb24uZGlzdHJpYnV0aW9uPXZhbHVlIG9mIHRoZSBgdHlwZWAgb3B0aW9uLl0gQSBzcGVjaWZpYyBkaXN0cmlidXRpb24gdG8gdXNlIHdoZW4gcmFkaXVzaW5nIHBhcnRpY2xlcy4gT3ZlcnJpZGVzIHRoZSBgdHlwZWAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbcG9zaXRpb24ucmFuZG9taXNlPWZhbHNlXSBXaGVuIGEgcGFydGljbGUgaXMgcmUtc3Bhd25lZCwgd2hldGhlciBpdCdzIHBvc2l0aW9uIHNob3VsZCBiZSByZS1yYW5kb21pc2VkIG9yIG5vdC4gQ2FuIGluY3VyIGEgcGVyZm9ybWFuY2UgaGl0LlxuICpcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3ZlbG9jaXR5PXt9XSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGlzIHBhcnRpY2xlIHZlbG9jaXR5LlxuICogQHByb3BlcnR5IHtPYmplY3R9IFt2ZWxvY2l0eS52YWx1ZT1uZXcgVEhSRUUuVmVjdG9yMygpXSBBIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGlzIGVtaXR0ZXIncyBiYXNlIHZlbG9jaXR5LlxuICogQHByb3BlcnR5IHtPYmplY3R9IFt2ZWxvY2l0eS5zcHJlYWQ9bmV3IFRIUkVFLlZlY3RvcjMoKV0gQSBUSFJFRS5WZWN0b3IzIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhpcyBlbWl0dGVyJ3MgdmVsb2NpdHkgdmFyaWFuY2Ugb24gYSBwZXItcGFydGljbGUgYmFzaXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgd2hlbiB1c2luZyBhIFNQSEVSRSBvciBESVNDIGRpc3RyaWJ1dGlvbiwgb25seSB0aGUgeC1jb21wb25lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgdmVjdG9yIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge2Rpc3RyaWJ1dGlvbn0gW3ZlbG9jaXR5LmRpc3RyaWJ1dGlvbj12YWx1ZSBvZiB0aGUgYHR5cGVgIG9wdGlvbi5dIEEgc3BlY2lmaWMgZGlzdHJpYnV0aW9uIHRvIHVzZSB3aGVuIGNhbGN1bGF0aW5nIGEgcGFydGljbGUncyB2ZWxvY2l0eS4gT3ZlcnJpZGVzIHRoZSBgdHlwZWAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbdmVsb2NpdHkucmFuZG9taXNlPWZhbHNlXSBXaGVuIGEgcGFydGljbGUgaXMgcmUtc3Bhd25lZCwgd2hldGhlciBpdCdzIHZlbG9jaXR5IHNob3VsZCBiZSByZS1yYW5kb21pc2VkIG9yIG5vdC4gQ2FuIGluY3VyIGEgcGVyZm9ybWFuY2UgaGl0LlxuICpcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2FjY2VsZXJhdGlvbj17fV0gQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhpcyBwYXJ0aWNsZSdzIGFjY2VsZXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYWNjZWxlcmF0aW9uLnZhbHVlPW5ldyBUSFJFRS5WZWN0b3IzKCldIEEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoaXMgZW1pdHRlcidzIGJhc2UgYWNjZWxlcmF0aW9uLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFthY2NlbGVyYXRpb24uc3ByZWFkPW5ldyBUSFJFRS5WZWN0b3IzKCldIEEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoaXMgZW1pdHRlcidzIGFjY2VsZXJhdGlvbiB2YXJpYW5jZSBvbiBhIHBlci1wYXJ0aWNsZSBiYXNpcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHdoZW4gdXNpbmcgYSBTUEhFUkUgb3IgRElTQyBkaXN0cmlidXRpb24sIG9ubHkgdGhlIHgtY29tcG9uZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgdmVjdG9yIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge2Rpc3RyaWJ1dGlvbn0gW2FjY2VsZXJhdGlvbi5kaXN0cmlidXRpb249dmFsdWUgb2YgdGhlIGB0eXBlYCBvcHRpb24uXSBBIHNwZWNpZmljIGRpc3RyaWJ1dGlvbiB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyBhIHBhcnRpY2xlJ3MgYWNjZWxlcmF0aW9uLiBPdmVycmlkZXMgdGhlIGB0eXBlYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFthY2NlbGVyYXRpb24ucmFuZG9taXNlPWZhbHNlXSBXaGVuIGEgcGFydGljbGUgaXMgcmUtc3Bhd25lZCwgd2hldGhlciBpdCdzIGFjY2VsZXJhdGlvbiBzaG91bGQgYmUgcmUtcmFuZG9taXNlZCBvciBub3QuIENhbiBpbmN1ciBhIHBlcmZvcm1hbmNlIGhpdC5cbiAqXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtkcmFnPXt9XSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGlzIHBhcnRpY2xlIGRyYWcuIERyYWcgaXMgYXBwbGllZCB0byBib3RoIHZlbG9jaXR5IGFuZCBhY2NlbGVyYXRpb24gdmFsdWVzLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkcmFnLnZhbHVlPTBdIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBkZXNjcmliaW5nIHRoZSBhbW91bnQgb2YgZHJhZyB0byBhcHBseSB0byBhbGwgcGFydGljbGVzLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkcmFnLnNwcmVhZD0wXSBBIG51bWJlciBkZXNjcmliaW5nIHRoZSBkcmFnIHZhcmlhbmNlIG9uIGEgcGVyLXBhcnRpY2xlIGJhc2lzLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbZHJhZy5yYW5kb21pc2U9ZmFsc2VdIFdoZW4gYSBwYXJ0aWNsZSBpcyByZS1zcGF3bmVkLCB3aGV0aGVyIGl0J3MgZHJhZyBzaG91bGQgYmUgcmUtcmFuZG9taXNlZCBvciBub3QuIENhbiBpbmN1ciBhIHBlcmZvcm1hbmNlIGhpdC5cbiAqXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFt3aWdnbGU9e31dIFRoaXMgaXMgcXVpdGUgYSBmdW4gb25lISBUaGUgdmFsdWVzIG9mIHRoaXMgb2JqZWN0IHdpbGwgZGV0ZXJtaW5lIHdoZXRoZXIgYSBwYXJ0aWNsZSB3aWxsIHdpZ2dsZSwgb3IgamlnZ2xlLCBvciB3YXZlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHNoaW1teSwgb3Igd2FnZ2xlLCBvci4uLiBXZWxsIHlvdSBnZXQgdGhlIGlkZWEuIFRoZSB3aWdnbGUgaXMgY2FsY3VsYXRlZCBvdmVyLXRpbWUsIG1lYW5pbmcgdGhhdCBhIHBhcnRpY2xlIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCBvZmYgd2l0aCBubyB3aWdnbGUsIGFuZCBlbmQgdXAgd2lnZ2xpbmcgYWJvdXQgd2l0aCB0aGUgZGlzdGFuY2Ugb2YgdGhlIGB2YWx1ZWAgc3BlY2lmaWVkIGJ5IHRoZSB0aW1lIGl0IGRpZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQncyBxdWl0ZSBoYW5keSB0byBzaW11bGF0ZSBmaXJlIGVtYmVycywgb3Igc2ltaWxhciBlZmZlY3RzIHdoZXJlIHRoZSBwYXJ0aWNsZSdzIHBvc2l0aW9uIHNob3VsZCBzbGlnaHRseSBjaGFuZ2Ugb3ZlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUsIGFuZCBzdWNoIGNoYW5nZSBpc24ndCBlYXNpbHkgY29udHJvbGxlZCBieSByb3RhdGlvbiwgdmVsb2NpdHksIG9yIGFjY2VsZXJhdGlvbi4gVGhlIHdpZ2dsZSBpcyBhIGNvbWJpbmF0aW9uIG9mIHNpbiBhbmQgY29zIGNhbGN1bGF0aW9ucywgc28gaXMgY2lyY3VsYXIgaW4gbmF0dXJlLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFt3aWdnbGUudmFsdWU9MF0gQSBudW1iZXIgZGVzY3JpYmluZyB0aGUgYW1vdW50IG9mIHdpZ2dsZSB0byBhcHBseSB0byBhbGwgcGFydGljbGVzLiBJdCdzIG1lYXN1cmVkIGluIGRpc3RhbmNlLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFt3aWdnbGUuc3ByZWFkPTBdIEEgbnVtYmVyIGRlc2NyaWJpbmcgdGhlIHdpZ2dsZSB2YXJpYW5jZSBvbiBhIHBlci1wYXJ0aWNsZSBiYXNpcy5cbiAqXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtyb3RhdGlvbj17fV0gQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhpcyBlbWl0dGVyJ3Mgcm90YXRpb24uIEl0IGNhbiBlaXRoZXIgYmUgc3RhdGljLCBvciBzZXQgdG8gcm90YXRlIGZyb20gMHJhZGlhbnMgdG8gdGhlIHZhbHVlIG9mIGByb3RhdGlvbi52YWx1ZWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXIgYSBwYXJ0aWNsZSdzIGxpZmV0aW1lLiBSb3RhdGlvbiB2YWx1ZXMgYWZmZWN0IGJvdGggYSBwYXJ0aWNsZSdzIHBvc2l0aW9uIGFuZCB0aGUgZm9yY2VzIGFwcGxpZWQgdG8gaXQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3JvdGF0aW9uLmF4aXM9bmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCldIEEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoaXMgZW1pdHRlcidzIGF4aXMgb2Ygcm90YXRpb24uXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3JvdGF0aW9uLmF4aXNTcHJlYWQ9bmV3IFRIUkVFLlZlY3RvcjMoKV0gQSBUSFJFRS5WZWN0b3IzIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIGFtb3VudCBvZiB2YXJpYW5jZSB0byBhcHBseSB0byB0aGUgYXhpcyBvZiByb3RhdGlvbiBvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgcGVyLXBhcnRpY2xlIGJhc2lzLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyb3RhdGlvbi5hbmdsZT0wXSBUaGUgYW5nbGUgb2Ygcm90YXRpb24sIGdpdmVuIGluIHJhZGlhbnMuIElmIGByb3RhdGlvbi5zdGF0aWNgIGlzIHRydWUsIHRoZSBlbWl0dGVyIHdpbGwgc3RhcnQgb2ZmIHJvdGF0ZWQgYXQgdGhpcyBhbmdsZSwgYW5kIHN0YXkgYXMgc3VjaC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXJ3aXNlLCB0aGUgcGFydGljbGVzIHdpbGwgcm90YXRlIGZyb20gMHJhZGlhbnMgdG8gdGhpcyB2YWx1ZSBvdmVyIHRoZWlyIGxpZmV0aW1lcy5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcm90YXRpb24uYW5nbGVTcHJlYWQ9MF0gVGhlIGFtb3VudCBvZiB2YXJpYW5jZSBpbiBlYWNoIHBhcnRpY2xlJ3Mgcm90YXRpb24gYW5nbGUuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyb3RhdGlvbi5zdGF0aWM9ZmFsc2VdIFdoZXRoZXIgdGhlIHJvdGF0aW9uIHNob3VsZCBiZSBzdGF0aWMgb3Igbm90LlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtyb3RhdGlvbi5jZW50ZXI9VGhlIHZhbHVlIG9mIGBwb3NpdGlvbi52YWx1ZWBdIEEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBjZW50ZXIgcG9pbnQgb2Ygcm90YXRpb24uXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyb3RhdGlvbi5yYW5kb21pc2U9ZmFsc2VdIFdoZW4gYSBwYXJ0aWNsZSBpcyByZS1zcGF3bmVkLCB3aGV0aGVyIGl0J3Mgcm90YXRpb24gc2hvdWxkIGJlIHJlLXJhbmRvbWlzZWQgb3Igbm90LiBDYW4gaW5jdXIgYSBwZXJmb3JtYW5jZSBoaXQuXG4gKlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbY29sb3I9e31dIEFuIG9iamVjdCBkZXNjcmliaW5nIGEgcGFydGljbGUncyBjb2xvci4gVGhpcyBwcm9wZXJ0eSBpcyBhIFwidmFsdWUtb3Zlci1saWZldGltZVwiIHByb3BlcnR5LCBtZWFuaW5nIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgc3ByZWFkcyBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdpdmVuIHRvIGRlc2NyaWJlIHNwZWNpZmljIHZhbHVlIGNoYW5nZXMgb3ZlciBhIHBhcnRpY2xlJ3MgbGlmZXRpbWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIFNQRS52YWx1ZU92ZXJMaWZldGltZUxlbmd0aCwgaWYgYXJyYXlzIG9mIFRIUkVFLkNvbG9yIGluc3RhbmNlcyBhcmUgZ2l2ZW4sIHRoZW4gdGhlIGFycmF5IHdpbGwgYmUgaW50ZXJwb2xhdGVkIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGEgbGVuZ3RoIG1hdGNoaW5nIHRoZSB2YWx1ZSBvZiBTUEUudmFsdWVPdmVyTGlmZXRpbWVMZW5ndGguXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2NvbG9yLnZhbHVlPW5ldyBUSFJFRS5Db2xvcigpXSBFaXRoZXIgYSBzaW5nbGUgVEhSRUUuQ29sb3IgaW5zdGFuY2UsIG9yIGFuIGFycmF5IG9mIFRIUkVFLkNvbG9yIGluc3RhbmNlcyB0byBkZXNjcmliZSB0aGUgY29sb3Igb2YgYSBwYXJ0aWNsZSBvdmVyIGl0J3MgbGlmZXRpbWUuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2NvbG9yLnNwcmVhZD1uZXcgVEhSRUUuVmVjdG9yMygpXSBFaXRoZXIgYSBzaW5nbGUgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZSwgb3IgYW4gYXJyYXkgb2YgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZXMgdG8gZGVzY3JpYmUgdGhlIGNvbG9yIHZhcmlhbmNlIG9mIGEgcGFydGljbGUgb3ZlciBpdCdzIGxpZmV0aW1lLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbY29sb3IucmFuZG9taXNlPWZhbHNlXSBXaGVuIGEgcGFydGljbGUgaXMgcmUtc3Bhd25lZCwgd2hldGhlciBpdCdzIGNvbG9yIHNob3VsZCBiZSByZS1yYW5kb21pc2VkIG9yIG5vdC4gQ2FuIGluY3VyIGEgcGVyZm9ybWFuY2UgaGl0LlxuICpcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gW29wYWNpdHk9e31dIEFuIG9iamVjdCBkZXNjcmliaW5nIGEgcGFydGljbGUncyBvcGFjaXR5LiBUaGlzIHByb3BlcnR5IGlzIGEgXCJ2YWx1ZS1vdmVyLWxpZmV0aW1lXCIgcHJvcGVydHksIG1lYW5pbmcgYW4gYXJyYXkgb2YgdmFsdWVzIGFuZCBzcHJlYWRzIGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW4gdG8gZGVzY3JpYmUgc3BlY2lmaWMgdmFsdWUgY2hhbmdlcyBvdmVyIGEgcGFydGljbGUncyBsaWZldGltZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgU1BFLnZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoLCBpZiBhcnJheXMgb2YgbnVtYmVycyBhcmUgZ2l2ZW4sIHRoZW4gdGhlIGFycmF5IHdpbGwgYmUgaW50ZXJwb2xhdGVkIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGEgbGVuZ3RoIG1hdGNoaW5nIHRoZSB2YWx1ZSBvZiBTUEUudmFsdWVPdmVyTGlmZXRpbWVMZW5ndGguXG4gKiBAcHJvcGVydHkge051bWJlcn0gW29wYWNpdHkudmFsdWU9MV0gRWl0aGVyIGEgc2luZ2xlIG51bWJlciwgb3IgYW4gYXJyYXkgb2YgbnVtYmVycyB0byBkZXNjcmliZSB0aGUgb3BhY2l0eSBvZiBhIHBhcnRpY2xlIG92ZXIgaXQncyBsaWZldGltZS5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbb3BhY2l0eS5zcHJlYWQ9MF0gRWl0aGVyIGEgc2luZ2xlIG51bWJlciwgb3IgYW4gYXJyYXkgb2YgbnVtYmVycyB0byBkZXNjcmliZSB0aGUgb3BhY2l0eSB2YXJpYW5jZSBvZiBhIHBhcnRpY2xlIG92ZXIgaXQncyBsaWZldGltZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW29wYWNpdHkucmFuZG9taXNlPWZhbHNlXSBXaGVuIGEgcGFydGljbGUgaXMgcmUtc3Bhd25lZCwgd2hldGhlciBpdCdzIG9wYWNpdHkgc2hvdWxkIGJlIHJlLXJhbmRvbWlzZWQgb3Igbm90LiBDYW4gaW5jdXIgYSBwZXJmb3JtYW5jZSBoaXQuXG4gKlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbc2l6ZT17fV0gQW4gb2JqZWN0IGRlc2NyaWJpbmcgYSBwYXJ0aWNsZSdzIHNpemUuIFRoaXMgcHJvcGVydHkgaXMgYSBcInZhbHVlLW92ZXItbGlmZXRpbWVcIiBwcm9wZXJ0eSwgbWVhbmluZyBhbiBhcnJheSBvZiB2YWx1ZXMgYW5kIHNwcmVhZHMgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaXZlbiB0byBkZXNjcmliZSBzcGVjaWZpYyB2YWx1ZSBjaGFuZ2VzIG92ZXIgYSBwYXJ0aWNsZSdzIGxpZmV0aW1lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBTUEUudmFsdWVPdmVyTGlmZXRpbWVMZW5ndGgsIGlmIGFycmF5cyBvZiBudW1iZXJzIGFyZSBnaXZlbiwgdGhlbiB0aGUgYXJyYXkgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUgYSBsZW5ndGggbWF0Y2hpbmcgdGhlIHZhbHVlIG9mIFNQRS52YWx1ZU92ZXJMaWZldGltZUxlbmd0aC5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2l6ZS52YWx1ZT0xXSBFaXRoZXIgYSBzaW5nbGUgbnVtYmVyLCBvciBhbiBhcnJheSBvZiBudW1iZXJzIHRvIGRlc2NyaWJlIHRoZSBzaXplIG9mIGEgcGFydGljbGUgb3ZlciBpdCdzIGxpZmV0aW1lLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzaXplLnNwcmVhZD0wXSBFaXRoZXIgYSBzaW5nbGUgbnVtYmVyLCBvciBhbiBhcnJheSBvZiBudW1iZXJzIHRvIGRlc2NyaWJlIHRoZSBzaXplIHZhcmlhbmNlIG9mIGEgcGFydGljbGUgb3ZlciBpdCdzIGxpZmV0aW1lLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbc2l6ZS5yYW5kb21pc2U9ZmFsc2VdIFdoZW4gYSBwYXJ0aWNsZSBpcyByZS1zcGF3bmVkLCB3aGV0aGVyIGl0J3Mgc2l6ZSBzaG91bGQgYmUgcmUtcmFuZG9taXNlZCBvciBub3QuIENhbiBpbmN1ciBhIHBlcmZvcm1hbmNlIGhpdC5cbiAqXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFthbmdsZT17fV0gQW4gb2JqZWN0IGRlc2NyaWJpbmcgYSBwYXJ0aWNsZSdzIGFuZ2xlLiBUaGUgYW5nbGUgaXMgYSAyZC1yb3RhdGlvbiwgbWVhc3VyZWQgaW4gcmFkaWFucywgYXBwbGllZCB0byB0aGUgcGFydGljbGUncyB0ZXh0dXJlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9URTogaWYgYSBwYXJ0aWNsZSdzIHRleHR1cmUgaXMgYSBzcHJpdGUtc2hlZXQsIHRoaXMgdmFsdWUgSVMgSUdOT1JFRC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgcHJvcGVydHkgaXMgYSBcInZhbHVlLW92ZXItbGlmZXRpbWVcIiBwcm9wZXJ0eSwgbWVhbmluZyBhbiBhcnJheSBvZiB2YWx1ZXMgYW5kIHNwcmVhZHMgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaXZlbiB0byBkZXNjcmliZSBzcGVjaWZpYyB2YWx1ZSBjaGFuZ2VzIG92ZXIgYSBwYXJ0aWNsZSdzIGxpZmV0aW1lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBTUEUudmFsdWVPdmVyTGlmZXRpbWVMZW5ndGgsIGlmIGFycmF5cyBvZiBudW1iZXJzIGFyZSBnaXZlbiwgdGhlbiB0aGUgYXJyYXkgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUgYSBsZW5ndGggbWF0Y2hpbmcgdGhlIHZhbHVlIG9mIFNQRS52YWx1ZU92ZXJMaWZldGltZUxlbmd0aC5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYW5nbGUudmFsdWU9MF0gRWl0aGVyIGEgc2luZ2xlIG51bWJlciwgb3IgYW4gYXJyYXkgb2YgbnVtYmVycyB0byBkZXNjcmliZSB0aGUgYW5nbGUgb2YgYSBwYXJ0aWNsZSBvdmVyIGl0J3MgbGlmZXRpbWUuXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2FuZ2xlLnNwcmVhZD0wXSBFaXRoZXIgYSBzaW5nbGUgbnVtYmVyLCBvciBhbiBhcnJheSBvZiBudW1iZXJzIHRvIGRlc2NyaWJlIHRoZSBhbmdsZSB2YXJpYW5jZSBvZiBhIHBhcnRpY2xlIG92ZXIgaXQncyBsaWZldGltZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FuZ2xlLnJhbmRvbWlzZT1mYWxzZV0gV2hlbiBhIHBhcnRpY2xlIGlzIHJlLXNwYXduZWQsIHdoZXRoZXIgaXQncyBhbmdsZSBzaG91bGQgYmUgcmUtcmFuZG9taXNlZCBvciBub3QuIENhbiBpbmN1ciBhIHBlcmZvcm1hbmNlIGhpdC5cbiAqXG4gKi9cblxuLyoqXG4gKiBUaGUgU1BFLkVtaXR0ZXIgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtFbWl0dGVyT3B0aW9uc30gb3B0aW9ucyBBIG1hcCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgZW1pdHRlci5cbiAqL1xuU1BFLkVtaXR0ZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgdXRpbHMgPSBTUEUudXRpbHMsXG4gICAgICAgIHR5cGVzID0gdXRpbHMudHlwZXMsXG4gICAgICAgIGxpZmV0aW1lTGVuZ3RoID0gU1BFLnZhbHVlT3ZlckxpZmV0aW1lTGVuZ3RoO1xuXG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSBtYXAgb2Ygb3B0aW9ucyB0byBwbGF5IHdpdGgsXG4gICAgLy8gYW5kIHRoYXQgZWFjaCBvcHRpb24gaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0LlxuICAgIG9wdGlvbnMgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucywgdHlwZXMuT0JKRUNULCB7fSApO1xuICAgIG9wdGlvbnMucG9zaXRpb24gPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5wb3NpdGlvbiwgdHlwZXMuT0JKRUNULCB7fSApO1xuICAgIG9wdGlvbnMudmVsb2NpdHkgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy52ZWxvY2l0eSwgdHlwZXMuT0JKRUNULCB7fSApO1xuICAgIG9wdGlvbnMuYWNjZWxlcmF0aW9uID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuYWNjZWxlcmF0aW9uLCB0eXBlcy5PQkpFQ1QsIHt9ICk7XG4gICAgb3B0aW9ucy5yYWRpdXMgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5yYWRpdXMsIHR5cGVzLk9CSkVDVCwge30gKTtcbiAgICBvcHRpb25zLmRyYWcgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5kcmFnLCB0eXBlcy5PQkpFQ1QsIHt9ICk7XG4gICAgb3B0aW9ucy5yb3RhdGlvbiA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnJvdGF0aW9uLCB0eXBlcy5PQkpFQ1QsIHt9ICk7XG4gICAgb3B0aW9ucy5jb2xvciA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLmNvbG9yLCB0eXBlcy5PQkpFQ1QsIHt9ICk7XG4gICAgb3B0aW9ucy5vcGFjaXR5ID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMub3BhY2l0eSwgdHlwZXMuT0JKRUNULCB7fSApO1xuICAgIG9wdGlvbnMuc2l6ZSA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnNpemUsIHR5cGVzLk9CSkVDVCwge30gKTtcbiAgICBvcHRpb25zLmFuZ2xlID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuYW5nbGUsIHR5cGVzLk9CSkVDVCwge30gKTtcbiAgICBvcHRpb25zLndpZ2dsZSA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLndpZ2dsZSwgdHlwZXMuT0JKRUNULCB7fSApO1xuICAgIG9wdGlvbnMubWF4QWdlID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMubWF4QWdlLCB0eXBlcy5PQkpFQ1QsIHt9ICk7XG5cbiAgICBpZiAoIG9wdGlvbnMub25QYXJ0aWNsZVNwYXduICkge1xuICAgICAgICBjb25zb2xlLndhcm4oICdvblBhcnRpY2xlU3Bhd24gaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHNldCBwcm9wZXJ0aWVzIGRpcmVjdGx5IHRvIGFsdGVyIHZhbHVlcyBhdCBydW50aW1lLicgKTtcbiAgICB9XG5cbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgdGhpcy50eXBlID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMudHlwZSwgdHlwZXMuTlVNQkVSLCBTUEUuZGlzdHJpYnV0aW9ucy5CT1ggKTtcblxuICAgIC8vIFN0YXJ0IGFzc2lnbmluZyBwcm9wZXJ0aWVzLi4ua2lja2luZyBpdCBvZmYgd2l0aCBwcm9wcyB0aGF0IERPTidUIHN1cHBvcnQgdmFsdWVzIG92ZXJcbiAgICAvLyBsaWZldGltZXMuXG4gICAgLy9cbiAgICAvLyBCdHcsIHZhbHVlcyBvdmVyIGxpZmV0aW1lcyBhcmUganVzdCB0aGUgbmV3IHdheSBvZiByZWZlcnJpbmcgdG8gKlN0YXJ0LCAqTWlkZGxlLCBhbmQgKkVuZC5cbiAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICBfdmFsdWU6IHV0aWxzLmVuc3VyZUluc3RhbmNlT2YoIG9wdGlvbnMucG9zaXRpb24udmFsdWUsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKCkgKSxcbiAgICAgICAgX3NwcmVhZDogdXRpbHMuZW5zdXJlSW5zdGFuY2VPZiggb3B0aW9ucy5wb3NpdGlvbi5zcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKCkgKSxcbiAgICAgICAgX3NwcmVhZENsYW1wOiB1dGlscy5lbnN1cmVJbnN0YW5jZU9mKCBvcHRpb25zLnBvc2l0aW9uLnNwcmVhZENsYW1wLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMygpICksXG4gICAgICAgIF9kaXN0cmlidXRpb246IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnBvc2l0aW9uLmRpc3RyaWJ1dGlvbiwgdHlwZXMuTlVNQkVSLCB0aGlzLnR5cGUgKSxcbiAgICAgICAgX3JhbmRvbWlzZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApLFxuICAgICAgICBfcmFkaXVzOiB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5wb3NpdGlvbi5yYWRpdXMsIHR5cGVzLk5VTUJFUiwgMTAgKSxcbiAgICAgICAgX3JhZGl1c1NjYWxlOiB1dGlscy5lbnN1cmVJbnN0YW5jZU9mKCBvcHRpb25zLnBvc2l0aW9uLnJhZGl1c1NjYWxlLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApICksXG4gICAgICAgIF9kaXN0cmlidXRpb25DbGFtcDogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24uZGlzdHJpYnV0aW9uQ2xhbXAsIHR5cGVzLk5VTUJFUiwgMCApLFxuICAgIH07XG5cbiAgICB0aGlzLnZlbG9jaXR5ID0ge1xuICAgICAgICBfdmFsdWU6IHV0aWxzLmVuc3VyZUluc3RhbmNlT2YoIG9wdGlvbnMudmVsb2NpdHkudmFsdWUsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKCkgKSxcbiAgICAgICAgX3NwcmVhZDogdXRpbHMuZW5zdXJlSW5zdGFuY2VPZiggb3B0aW9ucy52ZWxvY2l0eS5zcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKCkgKSxcbiAgICAgICAgX2Rpc3RyaWJ1dGlvbjogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMudmVsb2NpdHkuZGlzdHJpYnV0aW9uLCB0eXBlcy5OVU1CRVIsIHRoaXMudHlwZSApLFxuICAgICAgICBfcmFuZG9taXNlOiB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5wb3NpdGlvbi5yYW5kb21pc2UsIHR5cGVzLkJPT0xFQU4sIGZhbHNlIClcbiAgICB9O1xuXG4gICAgdGhpcy5hY2NlbGVyYXRpb24gPSB7XG4gICAgICAgIF92YWx1ZTogdXRpbHMuZW5zdXJlSW5zdGFuY2VPZiggb3B0aW9ucy5hY2NlbGVyYXRpb24udmFsdWUsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKCkgKSxcbiAgICAgICAgX3NwcmVhZDogdXRpbHMuZW5zdXJlSW5zdGFuY2VPZiggb3B0aW9ucy5hY2NlbGVyYXRpb24uc3ByZWFkLCBUSFJFRS5WZWN0b3IzLCBuZXcgVEhSRUUuVmVjdG9yMygpICksXG4gICAgICAgIF9kaXN0cmlidXRpb246IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLmFjY2VsZXJhdGlvbi5kaXN0cmlidXRpb24sIHR5cGVzLk5VTUJFUiwgdGhpcy50eXBlICksXG4gICAgICAgIF9yYW5kb21pc2U6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnBvc2l0aW9uLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKVxuICAgIH07XG5cbiAgICB0aGlzLmRyYWcgPSB7XG4gICAgICAgIF92YWx1ZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuZHJhZy52YWx1ZSwgdHlwZXMuTlVNQkVSLCAwICksXG4gICAgICAgIF9zcHJlYWQ6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLmRyYWcuc3ByZWFkLCB0eXBlcy5OVU1CRVIsIDAgKSxcbiAgICAgICAgX3JhbmRvbWlzZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApXG4gICAgfTtcblxuICAgIHRoaXMud2lnZ2xlID0ge1xuICAgICAgICBfdmFsdWU6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLndpZ2dsZS52YWx1ZSwgdHlwZXMuTlVNQkVSLCAwICksXG4gICAgICAgIF9zcHJlYWQ6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLndpZ2dsZS5zcHJlYWQsIHR5cGVzLk5VTUJFUiwgMCApXG4gICAgfTtcblxuICAgIHRoaXMucm90YXRpb24gPSB7XG4gICAgICAgIF9heGlzOiB1dGlscy5lbnN1cmVJbnN0YW5jZU9mKCBvcHRpb25zLnJvdGF0aW9uLmF4aXMsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKCAwLjAsIDEuMCwgMC4wICkgKSxcbiAgICAgICAgX2F4aXNTcHJlYWQ6IHV0aWxzLmVuc3VyZUluc3RhbmNlT2YoIG9wdGlvbnMucm90YXRpb24uYXhpc1NwcmVhZCwgVEhSRUUuVmVjdG9yMywgbmV3IFRIUkVFLlZlY3RvcjMoKSApLFxuICAgICAgICBfYW5nbGU6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnJvdGF0aW9uLmFuZ2xlLCB0eXBlcy5OVU1CRVIsIDAgKSxcbiAgICAgICAgX2FuZ2xlU3ByZWFkOiB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5yb3RhdGlvbi5hbmdsZVNwcmVhZCwgdHlwZXMuTlVNQkVSLCAwICksXG4gICAgICAgIF9zdGF0aWM6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnJvdGF0aW9uLnN0YXRpYywgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKSxcbiAgICAgICAgX2NlbnRlcjogdXRpbHMuZW5zdXJlSW5zdGFuY2VPZiggb3B0aW9ucy5yb3RhdGlvbi5jZW50ZXIsIFRIUkVFLlZlY3RvcjMsIHRoaXMucG9zaXRpb24uX3ZhbHVlLmNsb25lKCkgKSxcbiAgICAgICAgX3JhbmRvbWlzZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApXG4gICAgfTtcblxuXG4gICAgdGhpcy5tYXhBZ2UgPSB7XG4gICAgICAgIF92YWx1ZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMubWF4QWdlLnZhbHVlLCB0eXBlcy5OVU1CRVIsIDIgKSxcbiAgICAgICAgX3NwcmVhZDogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMubWF4QWdlLnNwcmVhZCwgdHlwZXMuTlVNQkVSLCAwIClcbiAgICB9O1xuXG5cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBjYW4gc3VwcG9ydCBlaXRoZXIgc2luZ2xlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgY2hhbmdlXG4gICAgLy8gdGhlIHByb3BlcnR5IG92ZXIgYSBwYXJ0aWNsZSdzIGxpZmV0aW1lICh2YWx1ZSBvdmVyIGxpZmV0aW1lKS5cbiAgICB0aGlzLmNvbG9yID0ge1xuICAgICAgICBfdmFsdWU6IHV0aWxzLmVuc3VyZUFycmF5SW5zdGFuY2VPZiggb3B0aW9ucy5jb2xvci52YWx1ZSwgVEhSRUUuQ29sb3IsIG5ldyBUSFJFRS5Db2xvcigpICksXG4gICAgICAgIF9zcHJlYWQ6IHV0aWxzLmVuc3VyZUFycmF5SW5zdGFuY2VPZiggb3B0aW9ucy5jb2xvci5zcHJlYWQsIFRIUkVFLlZlY3RvcjMsIG5ldyBUSFJFRS5WZWN0b3IzKCkgKSxcbiAgICAgICAgX3JhbmRvbWlzZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApXG4gICAgfTtcblxuICAgIHRoaXMub3BhY2l0eSA9IHtcbiAgICAgICAgX3ZhbHVlOiB1dGlscy5lbnN1cmVBcnJheVR5cGVkQXJnKCBvcHRpb25zLm9wYWNpdHkudmFsdWUsIHR5cGVzLk5VTUJFUiwgMSApLFxuICAgICAgICBfc3ByZWFkOiB1dGlscy5lbnN1cmVBcnJheVR5cGVkQXJnKCBvcHRpb25zLm9wYWNpdHkuc3ByZWFkLCB0eXBlcy5OVU1CRVIsIDAgKSxcbiAgICAgICAgX3JhbmRvbWlzZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApXG4gICAgfTtcblxuICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgX3ZhbHVlOiB1dGlscy5lbnN1cmVBcnJheVR5cGVkQXJnKCBvcHRpb25zLnNpemUudmFsdWUsIHR5cGVzLk5VTUJFUiwgMSApLFxuICAgICAgICBfc3ByZWFkOiB1dGlscy5lbnN1cmVBcnJheVR5cGVkQXJnKCBvcHRpb25zLnNpemUuc3ByZWFkLCB0eXBlcy5OVU1CRVIsIDAgKSxcbiAgICAgICAgX3JhbmRvbWlzZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApXG4gICAgfTtcblxuICAgIHRoaXMuYW5nbGUgPSB7XG4gICAgICAgIF92YWx1ZTogdXRpbHMuZW5zdXJlQXJyYXlUeXBlZEFyZyggb3B0aW9ucy5hbmdsZS52YWx1ZSwgdHlwZXMuTlVNQkVSLCAwICksXG4gICAgICAgIF9zcHJlYWQ6IHV0aWxzLmVuc3VyZUFycmF5VHlwZWRBcmcoIG9wdGlvbnMuYW5nbGUuc3ByZWFkLCB0eXBlcy5OVU1CRVIsIDAgKSxcbiAgICAgICAgX3JhbmRvbWlzZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucG9zaXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApXG4gICAgfTtcblxuXG4gICAgLy8gQXNzaWduIHJlbmFpbmluZyBvcHRpb24gdmFsdWVzLlxuICAgIHRoaXMucGFydGljbGVDb3VudCA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnBhcnRpY2xlQ291bnQsIHR5cGVzLk5VTUJFUiwgMTAwICk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLmR1cmF0aW9uLCB0eXBlcy5OVU1CRVIsIG51bGwgKTtcbiAgICB0aGlzLmlzU3RhdGljID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuaXNTdGF0aWMsIHR5cGVzLkJPT0xFQU4sIGZhbHNlICk7XG4gICAgdGhpcy5hY3RpdmVNdWx0aXBsaWVyID0gdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuYWN0aXZlTXVsdGlwbGllciwgdHlwZXMuTlVNQkVSLCAxICk7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5kaXJlY3Rpb24sIHR5cGVzLk5VTUJFUiwgMSApO1xuXG4gICAgLy8gV2hldGhlciB0aGlzIGVtaXR0ZXIgaXMgYWxpdmUgb3Igbm90LlxuICAgIHRoaXMuYWxpdmUgPSB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5hbGl2ZSwgdHlwZXMuQk9PTEVBTiwgdHJ1ZSApO1xuXG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHNldCBpbnRlcm5hbGx5IGFuZCBhcmUgbm90XG4gICAgLy8gdXNlci1jb250cm9sbGFibGUuXG4gICAgdGhpcy5wYXJ0aWNsZXNQZXJTZWNvbmQgPSAwO1xuXG4gICAgLy8gVGhlIGN1cnJlbnQgcGFydGljbGUgaW5kZXggZm9yIHdoaWNoIHBhcnRpY2xlcyBzaG91bGRcbiAgICAvLyBiZSBtYXJrZWQgYXMgYWN0aXZlIG9uIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZS5cbiAgICB0aGlzLmFjdGl2YXRpb25JbmRleCA9IDA7XG5cbiAgICAvLyBUaGUgb2Zmc2V0IGluIHRoZSB0eXBlZCBhcnJheXMgdGhpcyBlbWl0dGVyJ3NcbiAgICAvLyBwYXJ0aWNsZSdzIHZhbHVlcyB3aWxsIHN0YXJ0IGF0XG4gICAgdGhpcy5hdHRyaWJ1dGVPZmZzZXQgPSAwO1xuXG4gICAgLy8gVGhlIGVuZCBvZiB0aGUgcmFuZ2UgaW4gdGhlIGF0dHJpYnV0ZSBidWZmZXJzXG4gICAgdGhpcy5hdHRyaWJ1dGVFbmQgPSAwO1xuXG5cblxuICAgIC8vIEhvbGRzIHRoZSB0aW1lIHRoZSBlbWl0dGVyIGhhcyBiZWVuIGFsaXZlIGZvci5cbiAgICB0aGlzLmFnZSA9IDAuMDtcblxuICAgIC8vIEhvbGRzIHRoZSBudW1iZXIgb2YgY3VycmVudGx5LWFsaXZlIHBhcnRpY2xlc1xuICAgIHRoaXMuYWN0aXZlUGFydGljbGVDb3VudCA9IDAuMDtcblxuICAgIC8vIEhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoaXMgZW1pdHRlcidzIGdyb3VwIG9uY2VcbiAgICAvLyBpdCdzIGFkZGVkIHRvIG9uZS5cbiAgICB0aGlzLmdyb3VwID0gbnVsbDtcblxuICAgIC8vIEhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoaXMgZW1pdHRlcidzIGdyb3VwJ3MgYXR0cmlidXRlcyBvYmplY3RcbiAgICAvLyBmb3IgZWFzaWVyIGFjY2Vzcy5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuXG4gICAgLy8gSG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmFtcyBhdHRyaWJ1dGUncyB0eXBlZCBhcnJheVxuICAgIC8vIGZvciBxdWlja2VyIGFjY2Vzcy5cbiAgICB0aGlzLnBhcmFtc0FycmF5ID0gbnVsbDtcblxuICAgIC8vIEEgc2V0IG9mIGZsYWdzIHRvIGRldGVybWluZSB3aGV0aGVyIHBhcnRpY3VsYXIgcHJvcGVydGllc1xuICAgIC8vIHNob3VsZCBiZSByZS1yYW5kb21pc2VkIHdoZW4gYSBwYXJ0aWNsZSBpcyByZXNldC5cbiAgICAvL1xuICAgIC8vIElmIGEgYHJhbmRvbWlzZWAgcHJvcGVydHkgaXMgZ2l2ZW4sIHRoaXMgaXMgcHJlZmVycmVkLlxuICAgIC8vIE90aGVyd2lzZSwgaXQgbG9va3MgYXQgd2hldGhlciBhIHNwcmVhZCB2YWx1ZSBoYXMgYmVlblxuICAgIC8vIGdpdmVuLlxuICAgIC8vXG4gICAgLy8gSXQgYWxsb3dzIHJhbmRvbWl6YXRpb24gdG8gYmUgdHVybmVkIG9mZiBhcyBkZXNpcmVkLiBJZlxuICAgIC8vIGFsbCByYW5kb21pemF0aW9uIGlzIHR1cm5lZCBvZmYsIHRoZW4gSSdkIGV4cGVjdCBhIHBlcmZvcm1hbmNlXG4gICAgLy8gYm9vc3QgYXMgbm8gYXR0cmlidXRlIGJ1ZmZlcnMgKGV4Y2x1ZGluZyB0aGUgYHBhcmFtc2ApXG4gICAgLy8gd291bGQgaGF2ZSB0byBiZSByZS1wYXNzZWQgdG8gdGhlIEdQVSBlYWNoIGZyYW1lIChzaW5jZSBub3RoaW5nXG4gICAgLy8gZXhjZXB0IHRoZSBgcGFyYW1zYCBhdHRyaWJ1dGUgd291bGQgaGF2ZSBjaGFuZ2VkKS5cbiAgICB0aGlzLnJlc2V0RmxhZ3MgPSB7XG4gICAgICAgIC8vIHBhcmFtczogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMubWF4QWdlLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgISFvcHRpb25zLm1heEFnZS5zcHJlYWQgKSB8fFxuICAgICAgICAvLyAgICAgdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMud2lnZ2xlLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgISFvcHRpb25zLndpZ2dsZS5zcHJlYWQgKSxcbiAgICAgICAgcG9zaXRpb246IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnBvc2l0aW9uLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKSB8fFxuICAgICAgICAgICAgdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMucmFkaXVzLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKSxcbiAgICAgICAgdmVsb2NpdHk6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnZlbG9jaXR5LnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKSxcbiAgICAgICAgYWNjZWxlcmF0aW9uOiB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5hY2NlbGVyYXRpb24ucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApIHx8XG4gICAgICAgICAgICB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5kcmFnLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKSxcbiAgICAgICAgcm90YXRpb246IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnJvdGF0aW9uLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKSxcbiAgICAgICAgcm90YXRpb25DZW50ZXI6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLnJvdGF0aW9uLnJhbmRvbWlzZSwgdHlwZXMuQk9PTEVBTiwgZmFsc2UgKSxcbiAgICAgICAgc2l6ZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuc2l6ZS5yYW5kb21pc2UsIHR5cGVzLkJPT0xFQU4sIGZhbHNlICksXG4gICAgICAgIGNvbG9yOiB1dGlscy5lbnN1cmVUeXBlZEFyZyggb3B0aW9ucy5jb2xvci5yYW5kb21pc2UsIHR5cGVzLkJPT0xFQU4sIGZhbHNlICksXG4gICAgICAgIG9wYWNpdHk6IHV0aWxzLmVuc3VyZVR5cGVkQXJnKCBvcHRpb25zLm9wYWNpdHkucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApLFxuICAgICAgICBhbmdsZTogdXRpbHMuZW5zdXJlVHlwZWRBcmcoIG9wdGlvbnMuYW5nbGUucmFuZG9taXNlLCB0eXBlcy5CT09MRUFOLCBmYWxzZSApXG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlRmxhZ3MgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZUNvdW50cyA9IHt9O1xuXG4gICAgLy8gQSBtYXAgdG8gaW5kaWNhdGUgd2hpY2ggZW1pdHRlciBwYXJhbWV0ZXJzIHNob3VsZCB1cGRhdGVcbiAgICAvLyB3aGljaCBhdHRyaWJ1dGUuXG4gICAgdGhpcy51cGRhdGVNYXAgPSB7XG4gICAgICAgIG1heEFnZTogJ3BhcmFtcycsXG4gICAgICAgIHBvc2l0aW9uOiAncG9zaXRpb24nLFxuICAgICAgICB2ZWxvY2l0eTogJ3ZlbG9jaXR5JyxcbiAgICAgICAgYWNjZWxlcmF0aW9uOiAnYWNjZWxlcmF0aW9uJyxcbiAgICAgICAgZHJhZzogJ2FjY2VsZXJhdGlvbicsXG4gICAgICAgIHdpZ2dsZTogJ3BhcmFtcycsXG4gICAgICAgIHJvdGF0aW9uOiAncm90YXRpb24nLFxuICAgICAgICBzaXplOiAnc2l6ZScsXG4gICAgICAgIGNvbG9yOiAnY29sb3InLFxuICAgICAgICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gICAgICAgIGFuZ2xlOiAnYW5nbGUnXG4gICAgfTtcblxuICAgIGZvciAoIHZhciBpIGluIHRoaXMudXBkYXRlTWFwICkge1xuICAgICAgICBpZiAoIHRoaXMudXBkYXRlTWFwLmhhc093blByb3BlcnR5KCBpICkgKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvdW50c1sgdGhpcy51cGRhdGVNYXBbIGkgXSBdID0gMC4wO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGbGFnc1sgdGhpcy51cGRhdGVNYXBbIGkgXSBdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVHZXR0ZXJTZXR0ZXJzKCB0aGlzWyBpIF0sIGkgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyVXBkYXRlUmFuZ2VzID0ge307XG4gICAgdGhpcy5hdHRyaWJ1dGVLZXlzID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZUNvdW50ID0gMDtcblxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHZhbHVlLW92ZXItbGlmZXRpbWUgcHJvcGVydHkgb2JqZWN0cyBhYm92ZVxuICAgIC8vIGhhdmUgdmFsdWUgYW5kIHNwcmVhZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9mIHRoZSBzYW1lIGxlbmd0aC5cbiAgICAvL1xuICAgIC8vIEFsc28sIGZvciBub3csIG1ha2Ugc3VyZSB0aGV5IGhhdmUgYSBsZW5ndGggb2YgMyAobWluL21heCBhcmd1bWVudHMgaGVyZSkuXG4gICAgdXRpbHMuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKCB0aGlzLmNvbG9yLCBsaWZldGltZUxlbmd0aCwgbGlmZXRpbWVMZW5ndGggKTtcbiAgICB1dGlscy5lbnN1cmVWYWx1ZU92ZXJMaWZldGltZUNvbXBsaWFuY2UoIHRoaXMub3BhY2l0eSwgbGlmZXRpbWVMZW5ndGgsIGxpZmV0aW1lTGVuZ3RoICk7XG4gICAgdXRpbHMuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKCB0aGlzLnNpemUsIGxpZmV0aW1lTGVuZ3RoLCBsaWZldGltZUxlbmd0aCApO1xuICAgIHV0aWxzLmVuc3VyZVZhbHVlT3ZlckxpZmV0aW1lQ29tcGxpYW5jZSggdGhpcy5hbmdsZSwgbGlmZXRpbWVMZW5ndGgsIGxpZmV0aW1lTGVuZ3RoICk7XG59O1xuXG5TUEUuRW1pdHRlci5jb25zdHJ1Y3RvciA9IFNQRS5FbWl0dGVyO1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX2NyZWF0ZUdldHRlclNldHRlcnMgPSBmdW5jdGlvbiggcHJvcE9iaiwgcHJvcE5hbWUgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yICggdmFyIGkgaW4gcHJvcE9iaiApIHtcbiAgICAgICAgaWYgKCBwcm9wT2JqLmhhc093blByb3BlcnR5KCBpICkgKSB7XG5cbiAgICAgICAgICAgIHZhciBuYW1lID0gaS5yZXBsYWNlKCAnXycsICcnICk7XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggcHJvcE9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGdldDogKCBmdW5jdGlvbiggcHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbIHByb3AgXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCBpICkgKSxcblxuICAgICAgICAgICAgICAgIHNldDogKCBmdW5jdGlvbiggcHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBOYW1lID0gc2VsZi51cGRhdGVNYXBbIHByb3BOYW1lIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlID0gdGhpc1sgcHJvcCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IFNQRS52YWx1ZU92ZXJMaWZldGltZUxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9wID09PSAnX3JvdGF0aW9uQ2VudGVyJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUZsYWdzLnJvdGF0aW9uQ2VudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUNvdW50cy5yb3RhdGlvbkNlbnRlciA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBwcm9wID09PSAnX3JhbmRvbWlzZScgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNldEZsYWdzWyBtYXBOYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRmxhZ3NbIG1hcE5hbWUgXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDb3VudHNbIG1hcE5hbWUgXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cC5fdXBkYXRlRGVmaW5lcygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyBwcm9wIF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBhbiBhcnJheSwgdGhlbiBtYWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXJlIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBpbnRlcnBvbGF0ZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBwcmV2VmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTUEUudXRpbHMuZW5zdXJlVmFsdWVPdmVyTGlmZXRpbWVDb21wbGlhbmNlKCBzZWxmWyBwcm9wTmFtZSBdLCBsZW5ndGgsIGxlbmd0aCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oIGkgKSApXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX3NldEJ1ZmZlclVwZGF0ZVJhbmdlcyA9IGZ1bmN0aW9uKCBrZXlzICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuYXR0cmlidXRlS2V5cyA9IGtleXM7XG4gICAgdGhpcy5hdHRyaWJ1dGVDb3VudCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICggdmFyIGkgPSB0aGlzLmF0dHJpYnV0ZUNvdW50IC0gMTsgaSA+PSAwOyAtLWkgKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyVXBkYXRlUmFuZ2VzWyBrZXlzWyBpIF0gXSA9IHtcbiAgICAgICAgICAgIG1pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZVBQU1ZhbHVlID0gZnVuY3Rpb24oIGdyb3VwTWF4QWdlICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBwYXJ0aWNsZUNvdW50ID0gdGhpcy5wYXJ0aWNsZUNvdW50O1xuXG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGBwYXJ0aWNsZXNQZXJTZWNvbmRgIHZhbHVlIGZvciB0aGlzIGVtaXR0ZXIuIEl0J3MgdXNlZFxuICAgIC8vIHdoZW4gZGV0ZXJtaW5pbmcgd2hpY2ggcGFydGljbGVzIHNob3VsZCBkaWUgYW5kIHdoaWNoIHNob3VsZCBsaXZlIHRvXG4gICAgLy8gc2VlIGFub3RoZXIgZGF5LiBPciBiZSBib3JuLCBmb3IgdGhhdCBtYXR0ZXIuIFRoZSBcIkdvZFwiIHByb3BlcnR5LlxuICAgIGlmICggdGhpcy5kdXJhdGlvbiApIHtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXNQZXJTZWNvbmQgPSBwYXJ0aWNsZUNvdW50IC8gKCBncm91cE1heEFnZSA8IHRoaXMuZHVyYXRpb24gPyBncm91cE1heEFnZSA6IHRoaXMuZHVyYXRpb24gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMucGFydGljbGVzUGVyU2Vjb25kID0gcGFydGljbGVDb3VudCAvIGdyb3VwTWF4QWdlO1xuICAgIH1cbn07XG5cblNQRS5FbWl0dGVyLnByb3RvdHlwZS5fc2V0QXR0cmlidXRlT2Zmc2V0ID0gZnVuY3Rpb24oIHN0YXJ0SW5kZXggKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVPZmZzZXQgPSBzdGFydEluZGV4O1xuICAgIHRoaXMuYWN0aXZhdGlvbkluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB0aGlzLmFjdGl2YXRpb25FbmQgPSBzdGFydEluZGV4ICsgdGhpcy5wYXJ0aWNsZUNvdW50O1xufTtcblxuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnblZhbHVlID0gZnVuY3Rpb24oIHByb3AsIGluZGV4ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHN3aXRjaCAoIHByb3AgKSB7XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgICAgIHRoaXMuX2Fzc2lnblBvc2l0aW9uVmFsdWUoIGluZGV4ICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2ZWxvY2l0eSc6XG4gICAgICAgIGNhc2UgJ2FjY2VsZXJhdGlvbic6XG4gICAgICAgICAgICB0aGlzLl9hc3NpZ25Gb3JjZVZhbHVlKCBpbmRleCwgcHJvcCApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICAgICAgdGhpcy5fYXNzaWduQWJzTGlmZXRpbWVWYWx1ZSggaW5kZXgsIHByb3AgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FuZ2xlJzpcbiAgICAgICAgICAgIHRoaXMuX2Fzc2lnbkFuZ2xlVmFsdWUoIGluZGV4ICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYXJhbXMnOlxuICAgICAgICAgICAgdGhpcy5fYXNzaWduUGFyYW1zVmFsdWUoIGluZGV4ICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyb3RhdGlvbic6XG4gICAgICAgICAgICB0aGlzLl9hc3NpZ25Sb3RhdGlvblZhbHVlKCBpbmRleCApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgdGhpcy5fYXNzaWduQ29sb3JWYWx1ZSggaW5kZXggKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cblNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduUG9zaXRpb25WYWx1ZSA9IGZ1bmN0aW9uKCBpbmRleCApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZGlzdHJpYnV0aW9ucyA9IFNQRS5kaXN0cmlidXRpb25zLFxuICAgICAgICB1dGlscyA9IFNQRS51dGlscyxcbiAgICAgICAgcHJvcCA9IHRoaXMucG9zaXRpb24sXG4gICAgICAgIGF0dHIgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sXG4gICAgICAgIHZhbHVlID0gcHJvcC5fdmFsdWUsXG4gICAgICAgIHNwcmVhZCA9IHByb3AuX3NwcmVhZCxcbiAgICAgICAgZGlzdHJpYnV0aW9uID0gcHJvcC5fZGlzdHJpYnV0aW9uO1xuXG4gICAgc3dpdGNoICggZGlzdHJpYnV0aW9uICkge1xuICAgICAgICBjYXNlIGRpc3RyaWJ1dGlvbnMuQk9YOlxuICAgICAgICAgICAgdXRpbHMucmFuZG9tVmVjdG9yMyggYXR0ciwgaW5kZXgsIHZhbHVlLCBzcHJlYWQsIHByb3AuX3NwcmVhZENsYW1wICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGRpc3RyaWJ1dGlvbnMuU1BIRVJFOlxuICAgICAgICAgICAgdXRpbHMucmFuZG9tVmVjdG9yM09uU3BoZXJlKCBhdHRyLCBpbmRleCwgdmFsdWUsIHByb3AuX3JhZGl1cywgcHJvcC5fc3ByZWFkLngsIHByb3AuX3JhZGl1c1NjYWxlLCBwcm9wLl9zcHJlYWRDbGFtcC54LCBwcm9wLl9kaXN0cmlidXRpb25DbGFtcCB8fCB0aGlzLnBhcnRpY2xlQ291bnQgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGlzdHJpYnV0aW9ucy5ESVNDOlxuICAgICAgICAgICAgdXRpbHMucmFuZG9tVmVjdG9yM09uRGlzYyggYXR0ciwgaW5kZXgsIHZhbHVlLCBwcm9wLl9yYWRpdXMsIHByb3AuX3NwcmVhZC54LCBwcm9wLl9yYWRpdXNTY2FsZSwgcHJvcC5fc3ByZWFkQ2xhbXAueCApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25Gb3JjZVZhbHVlID0gZnVuY3Rpb24oIGluZGV4LCBhdHRyTmFtZSApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZGlzdHJpYnV0aW9ucyA9IFNQRS5kaXN0cmlidXRpb25zLFxuICAgICAgICB1dGlscyA9IFNQRS51dGlscyxcbiAgICAgICAgcHJvcCA9IHRoaXNbIGF0dHJOYW1lIF0sXG4gICAgICAgIHZhbHVlID0gcHJvcC5fdmFsdWUsXG4gICAgICAgIHNwcmVhZCA9IHByb3AuX3NwcmVhZCxcbiAgICAgICAgZGlzdHJpYnV0aW9uID0gcHJvcC5fZGlzdHJpYnV0aW9uLFxuICAgICAgICBwb3MsXG4gICAgICAgIHBvc2l0aW9uWCxcbiAgICAgICAgcG9zaXRpb25ZLFxuICAgICAgICBwb3NpdGlvblosXG4gICAgICAgIGk7XG5cbiAgICBzd2l0Y2ggKCBkaXN0cmlidXRpb24gKSB7XG4gICAgICAgIGNhc2UgZGlzdHJpYnV0aW9ucy5CT1g6XG4gICAgICAgICAgICB1dGlscy5yYW5kb21WZWN0b3IzKCB0aGlzLmF0dHJpYnV0ZXNbIGF0dHJOYW1lIF0sIGluZGV4LCB2YWx1ZSwgc3ByZWFkICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGRpc3RyaWJ1dGlvbnMuU1BIRVJFOlxuICAgICAgICAgICAgcG9zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLnR5cGVkQXJyYXkuYXJyYXk7XG4gICAgICAgICAgICBpID0gaW5kZXggKiAzO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgcG9zaXRpb24gdmFsdWVzIGFyZW4ndCB6ZXJvLCBvdGhlcndpc2Ugbm8gZm9yY2Ugd2lsbCBiZVxuICAgICAgICAgICAgLy8gYXBwbGllZC5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uWCA9IHV0aWxzLnplcm9Ub0Vwc2lsb24oIHBvc1sgaSBdLCB0cnVlICk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvblkgPSB1dGlscy56ZXJvVG9FcHNpbG9uKCBwb3NbIGkgKyAxIF0sIHRydWUgKTtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uWiA9IHV0aWxzLnplcm9Ub0Vwc2lsb24oIHBvc1sgaSArIDIgXSwgdHJ1ZSApO1xuICAgICAgICAgICAgcG9zaXRpb25YID0gcG9zWyBpIF07XG4gICAgICAgICAgICBwb3NpdGlvblkgPSBwb3NbIGkgKyAxIF07XG4gICAgICAgICAgICBwb3NpdGlvblogPSBwb3NbIGkgKyAyIF07XG5cbiAgICAgICAgICAgIHV0aWxzLnJhbmRvbURpcmVjdGlvblZlY3RvcjNPblNwaGVyZShcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbIGF0dHJOYW1lIF0sIGluZGV4LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWCwgcG9zaXRpb25ZLCBwb3NpdGlvblosXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5fdmFsdWUsXG4gICAgICAgICAgICAgICAgcHJvcC5fdmFsdWUueCxcbiAgICAgICAgICAgICAgICBwcm9wLl9zcHJlYWQueFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGlzdHJpYnV0aW9ucy5ESVNDOlxuICAgICAgICAgICAgcG9zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLnR5cGVkQXJyYXkuYXJyYXk7XG4gICAgICAgICAgICBpID0gaW5kZXggKiAzO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgcG9zaXRpb24gdmFsdWVzIGFyZW4ndCB6ZXJvLCBvdGhlcndpc2Ugbm8gZm9yY2Ugd2lsbCBiZVxuICAgICAgICAgICAgLy8gYXBwbGllZC5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uWCA9IHV0aWxzLnplcm9Ub0Vwc2lsb24oIHBvc1sgaSBdLCB0cnVlICk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvblkgPSB1dGlscy56ZXJvVG9FcHNpbG9uKCBwb3NbIGkgKyAxIF0sIHRydWUgKTtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uWiA9IHV0aWxzLnplcm9Ub0Vwc2lsb24oIHBvc1sgaSArIDIgXSwgdHJ1ZSApO1xuICAgICAgICAgICAgcG9zaXRpb25YID0gcG9zWyBpIF07XG4gICAgICAgICAgICBwb3NpdGlvblkgPSBwb3NbIGkgKyAxIF07XG4gICAgICAgICAgICBwb3NpdGlvblogPSBwb3NbIGkgKyAyIF07XG5cbiAgICAgICAgICAgIHV0aWxzLnJhbmRvbURpcmVjdGlvblZlY3RvcjNPbkRpc2MoXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzWyBhdHRyTmFtZSBdLCBpbmRleCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvblgsIHBvc2l0aW9uWSwgcG9zaXRpb25aLFxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24uX3ZhbHVlLFxuICAgICAgICAgICAgICAgIHByb3AuX3ZhbHVlLngsXG4gICAgICAgICAgICAgICAgcHJvcC5fc3ByZWFkLnhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoIGF0dHJOYW1lID09PSAnYWNjZWxlcmF0aW9uJyApIHtcbiAgICAgICAgdmFyIGRyYWcgPSB1dGlscy5jbGFtcCggdXRpbHMucmFuZG9tRmxvYXQoIHRoaXMuZHJhZy5fdmFsdWUsIHRoaXMuZHJhZy5fc3ByZWFkICksIDAsIDEgKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmFjY2VsZXJhdGlvbi50eXBlZEFycmF5LmFycmF5WyBpbmRleCAqIDQgKyAzIF0gPSBkcmFnO1xuICAgIH1cbn07XG5cblNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduQWJzTGlmZXRpbWVWYWx1ZSA9IGZ1bmN0aW9uKCBpbmRleCwgcHJvcE5hbWUgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGFycmF5ID0gdGhpcy5hdHRyaWJ1dGVzWyBwcm9wTmFtZSBdLnR5cGVkQXJyYXksXG4gICAgICAgIHByb3AgPSB0aGlzWyBwcm9wTmFtZSBdLFxuICAgICAgICB1dGlscyA9IFNQRS51dGlscyxcbiAgICAgICAgdmFsdWU7XG5cbiAgICBpZiAoIHV0aWxzLmFycmF5VmFsdWVzQXJlRXF1YWwoIHByb3AuX3ZhbHVlICkgJiYgdXRpbHMuYXJyYXlWYWx1ZXNBcmVFcXVhbCggcHJvcC5fc3ByZWFkICkgKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5hYnMoIHV0aWxzLnJhbmRvbUZsb2F0KCBwcm9wLl92YWx1ZVsgMCBdLCBwcm9wLl9zcHJlYWRbIDAgXSApICk7XG4gICAgICAgIGFycmF5LnNldFZlYzRDb21wb25lbnRzKCBpbmRleCwgdmFsdWUsIHZhbHVlLCB2YWx1ZSwgdmFsdWUgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFycmF5LnNldFZlYzRDb21wb25lbnRzKCBpbmRleCxcbiAgICAgICAgICAgIE1hdGguYWJzKCB1dGlscy5yYW5kb21GbG9hdCggcHJvcC5fdmFsdWVbIDAgXSwgcHJvcC5fc3ByZWFkWyAwIF0gKSApLFxuICAgICAgICAgICAgTWF0aC5hYnMoIHV0aWxzLnJhbmRvbUZsb2F0KCBwcm9wLl92YWx1ZVsgMSBdLCBwcm9wLl9zcHJlYWRbIDEgXSApICksXG4gICAgICAgICAgICBNYXRoLmFicyggdXRpbHMucmFuZG9tRmxvYXQoIHByb3AuX3ZhbHVlWyAyIF0sIHByb3AuX3NwcmVhZFsgMiBdICkgKSxcbiAgICAgICAgICAgIE1hdGguYWJzKCB1dGlscy5yYW5kb21GbG9hdCggcHJvcC5fdmFsdWVbIDMgXSwgcHJvcC5fc3ByZWFkWyAzIF0gKSApXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25BbmdsZVZhbHVlID0gZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXR0cmlidXRlcy5hbmdsZS50eXBlZEFycmF5LFxuICAgICAgICBwcm9wID0gdGhpcy5hbmdsZSxcbiAgICAgICAgdXRpbHMgPSBTUEUudXRpbHMsXG4gICAgICAgIHZhbHVlO1xuXG4gICAgaWYgKCB1dGlscy5hcnJheVZhbHVlc0FyZUVxdWFsKCBwcm9wLl92YWx1ZSApICYmIHV0aWxzLmFycmF5VmFsdWVzQXJlRXF1YWwoIHByb3AuX3NwcmVhZCApICkge1xuICAgICAgICB2YWx1ZSA9IHV0aWxzLnJhbmRvbUZsb2F0KCBwcm9wLl92YWx1ZVsgMCBdLCBwcm9wLl9zcHJlYWRbIDAgXSApO1xuICAgICAgICBhcnJheS5zZXRWZWM0Q29tcG9uZW50cyggaW5kZXgsIHZhbHVlLCB2YWx1ZSwgdmFsdWUsIHZhbHVlICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcnJheS5zZXRWZWM0Q29tcG9uZW50cyggaW5kZXgsXG4gICAgICAgICAgICB1dGlscy5yYW5kb21GbG9hdCggcHJvcC5fdmFsdWVbIDAgXSwgcHJvcC5fc3ByZWFkWyAwIF0gKSxcbiAgICAgICAgICAgIHV0aWxzLnJhbmRvbUZsb2F0KCBwcm9wLl92YWx1ZVsgMSBdLCBwcm9wLl9zcHJlYWRbIDEgXSApLFxuICAgICAgICAgICAgdXRpbHMucmFuZG9tRmxvYXQoIHByb3AuX3ZhbHVlWyAyIF0sIHByb3AuX3NwcmVhZFsgMiBdICksXG4gICAgICAgICAgICB1dGlscy5yYW5kb21GbG9hdCggcHJvcC5fdmFsdWVbIDMgXSwgcHJvcC5fc3ByZWFkWyAzIF0gKVxuICAgICAgICApO1xuICAgIH1cbn07XG5cblNQRS5FbWl0dGVyLnByb3RvdHlwZS5fYXNzaWduUGFyYW1zVmFsdWUgPSBmdW5jdGlvbiggaW5kZXggKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzLnBhcmFtcy50eXBlZEFycmF5LnNldFZlYzRDb21wb25lbnRzKCBpbmRleCxcbiAgICAgICAgdGhpcy5pc1N0YXRpYyA/IDEgOiAwLFxuICAgICAgICAwLjAsXG4gICAgICAgIE1hdGguYWJzKCBTUEUudXRpbHMucmFuZG9tRmxvYXQoIHRoaXMubWF4QWdlLl92YWx1ZSwgdGhpcy5tYXhBZ2UuX3NwcmVhZCApICksXG4gICAgICAgIFNQRS51dGlscy5yYW5kb21GbG9hdCggdGhpcy53aWdnbGUuX3ZhbHVlLCB0aGlzLndpZ2dsZS5fc3ByZWFkIClcbiAgICApO1xufTtcblxuU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9hc3NpZ25Sb3RhdGlvblZhbHVlID0gZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuYXR0cmlidXRlcy5yb3RhdGlvbi50eXBlZEFycmF5LnNldFZlYzNDb21wb25lbnRzKCBpbmRleCxcbiAgICAgICAgU1BFLnV0aWxzLmdldFBhY2tlZFJvdGF0aW9uQXhpcyggdGhpcy5yb3RhdGlvbi5fYXhpcywgdGhpcy5yb3RhdGlvbi5fYXhpc1NwcmVhZCApLFxuICAgICAgICBTUEUudXRpbHMucmFuZG9tRmxvYXQoIHRoaXMucm90YXRpb24uX2FuZ2xlLCB0aGlzLnJvdGF0aW9uLl9hbmdsZVNwcmVhZCApLFxuICAgICAgICB0aGlzLnJvdGF0aW9uLl9zdGF0aWMgPyAwIDogMVxuICAgICk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMucm90YXRpb25DZW50ZXIudHlwZWRBcnJheS5zZXRWZWMzKCBpbmRleCwgdGhpcy5yb3RhdGlvbi5fY2VudGVyICk7XG59O1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX2Fzc2lnbkNvbG9yVmFsdWUgPSBmdW5jdGlvbiggaW5kZXggKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIFNQRS51dGlscy5yYW5kb21Db2xvckFzSGV4KCB0aGlzLmF0dHJpYnV0ZXMuY29sb3IsIGluZGV4LCB0aGlzLmNvbG9yLl92YWx1ZSwgdGhpcy5jb2xvci5fc3ByZWFkICk7XG59O1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX3Jlc2V0UGFydGljbGUgPSBmdW5jdGlvbiggaW5kZXggKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHJlc2V0RmxhZ3MgPSB0aGlzLnJlc2V0RmxhZ3MsXG4gICAgICAgIHVwZGF0ZUZsYWdzID0gdGhpcy51cGRhdGVGbGFncyxcbiAgICAgICAgdXBkYXRlQ291bnRzID0gdGhpcy51cGRhdGVDb3VudHMsXG4gICAgICAgIGtleXMgPSB0aGlzLmF0dHJpYnV0ZUtleXMsXG4gICAgICAgIGtleSxcbiAgICAgICAgdXBkYXRlRmxhZztcblxuICAgIGZvciAoIHZhciBpID0gdGhpcy5hdHRyaWJ1dGVDb3VudCAtIDE7IGkgPj0gMDsgLS1pICkge1xuICAgICAgICBrZXkgPSBrZXlzWyBpIF07XG4gICAgICAgIHVwZGF0ZUZsYWcgPSB1cGRhdGVGbGFnc1sga2V5IF07XG5cbiAgICAgICAgaWYgKCByZXNldEZsYWdzWyBrZXkgXSA9PT0gdHJ1ZSB8fCB1cGRhdGVGbGFnID09PSB0cnVlICkge1xuICAgICAgICAgICAgdGhpcy5fYXNzaWduVmFsdWUoIGtleSwgaW5kZXggKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZVVwZGF0ZVJhbmdlKCBrZXksIGluZGV4ICk7XG5cbiAgICAgICAgICAgIGlmICggdXBkYXRlRmxhZyA9PT0gdHJ1ZSAmJiB1cGRhdGVDb3VudHNbIGtleSBdID09PSB0aGlzLnBhcnRpY2xlQ291bnQgKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRmxhZ3NbIGtleSBdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnRzWyBrZXkgXSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCB1cGRhdGVGbGFnID09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgKyt1cGRhdGVDb3VudHNbIGtleSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuU1BFLkVtaXR0ZXIucHJvdG90eXBlLl91cGRhdGVBdHRyaWJ1dGVVcGRhdGVSYW5nZSA9IGZ1bmN0aW9uKCBhdHRyLCBpICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciByYW5nZXMgPSB0aGlzLmJ1ZmZlclVwZGF0ZVJhbmdlc1sgYXR0ciBdO1xuXG4gICAgcmFuZ2VzLm1pbiA9IE1hdGgubWluKCBpLCByYW5nZXMubWluICk7XG4gICAgcmFuZ2VzLm1heCA9IE1hdGgubWF4KCBpLCByYW5nZXMubWF4ICk7XG59O1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX3Jlc2V0QnVmZmVyUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHJhbmdlcyA9IHRoaXMuYnVmZmVyVXBkYXRlUmFuZ2VzLFxuICAgICAgICBrZXlzID0gdGhpcy5idWZmZXJVcGRhdGVLZXlzLFxuICAgICAgICBpID0gdGhpcy5idWZmZXJVcGRhdGVDb3VudCAtIDEsXG4gICAgICAgIGtleTtcblxuICAgIGZvciAoIGk7IGkgPj0gMDsgLS1pICkge1xuICAgICAgICBrZXkgPSBrZXlzWyBpIF07XG4gICAgICAgIHJhbmdlc1sga2V5IF0ubWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICByYW5nZXNbIGtleSBdLm1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB9XG59O1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX29uUmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFJlc2V0IGFueSBwcm9wZXJ0aWVzIG9mIHRoZSBlbWl0dGVyIHRoYXQgd2VyZSBzZXQgYnlcbiAgICAvLyBhIGdyb3VwIHdoZW4gaXQgd2FzIGFkZGVkLlxuICAgIHRoaXMucGFydGljbGVzUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmF0dHJpYnV0ZU9mZnNldCA9IDA7XG4gICAgdGhpcy5hY3RpdmF0aW9uSW5kZXggPSAwO1xuICAgIHRoaXMuYWN0aXZlUGFydGljbGVDb3VudCA9IDA7XG4gICAgdGhpcy5ncm91cCA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB0aGlzLnBhcmFtc0FycmF5ID0gbnVsbDtcbiAgICB0aGlzLmFnZSA9IDAuMDtcbn07XG5cblNQRS5FbWl0dGVyLnByb3RvdHlwZS5fZGVjcmVtZW50UGFydGljbGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAtLXRoaXMuYWN0aXZlUGFydGljbGVDb3VudDtcblxuICAgIC8vIFRPRE86XG4gICAgLy8gIC0gVHJpZ2dlciBldmVudCBpZiBjb3VudCA9PT0gMC5cbn07XG5cblNQRS5FbWl0dGVyLnByb3RvdHlwZS5faW5jcmVtZW50UGFydGljbGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICArK3RoaXMuYWN0aXZlUGFydGljbGVDb3VudDtcblxuICAgIC8vIFRPRE86XG4gICAgLy8gIC0gVHJpZ2dlciBldmVudCBpZiBjb3VudCA9PT0gdGhpcy5wYXJ0aWNsZUNvdW50LlxufTtcblxuU1BFLkVtaXR0ZXIucHJvdG90eXBlLl9jaGVja1BhcnRpY2xlQWdlcyA9IGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBwYXJhbXMsIGR0ICkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmb3IgKCB2YXIgaSA9IGVuZCAtIDEsIGluZGV4LCBtYXhBZ2UsIGFnZSwgYWxpdmU7IGkgPj0gc3RhcnQ7IC0taSApIHtcbiAgICAgICAgaW5kZXggPSBpICogNDtcblxuICAgICAgICBhbGl2ZSA9IHBhcmFtc1sgaW5kZXggXTtcblxuICAgICAgICBpZiAoIGFsaXZlID09PSAwLjAgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlbWVudCBhZ2VcbiAgICAgICAgYWdlID0gcGFyYW1zWyBpbmRleCArIDEgXTtcbiAgICAgICAgbWF4QWdlID0gcGFyYW1zWyBpbmRleCArIDIgXTtcblxuICAgICAgICBpZiAoIHRoaXMuZGlyZWN0aW9uID09PSAxICkge1xuICAgICAgICAgICAgYWdlICs9IGR0O1xuXG4gICAgICAgICAgICBpZiAoIGFnZSA+PSBtYXhBZ2UgKSB7XG4gICAgICAgICAgICAgICAgYWdlID0gMC4wO1xuICAgICAgICAgICAgICAgIGFsaXZlID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY3JlbWVudFBhcnRpY2xlQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFnZSAtPSBkdDtcblxuICAgICAgICAgICAgaWYgKCBhZ2UgPD0gMC4wICkge1xuICAgICAgICAgICAgICAgIGFnZSA9IG1heEFnZTtcbiAgICAgICAgICAgICAgICBhbGl2ZSA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWNyZW1lbnRQYXJ0aWNsZUNvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNbIGluZGV4IF0gPSBhbGl2ZTtcbiAgICAgICAgcGFyYW1zWyBpbmRleCArIDEgXSA9IGFnZTtcblxuICAgICAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVVcGRhdGVSYW5nZSggJ3BhcmFtcycsIGkgKTtcbiAgICB9XG59O1xuXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuX2FjdGl2YXRlUGFydGljbGVzID0gZnVuY3Rpb24oIGFjdGl2YXRpb25TdGFydCwgYWN0aXZhdGlvbkVuZCwgcGFyYW1zLCBkdFBlclBhcnRpY2xlICkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG5cbiAgICBmb3IgKCB2YXIgaSA9IGFjdGl2YXRpb25TdGFydCwgaW5kZXgsIGR0VmFsdWU7IGkgPCBhY3RpdmF0aW9uRW5kOyArK2kgKSB7XG4gICAgICAgIGluZGV4ID0gaSAqIDQ7XG5cbiAgICAgICAgLy8gRG9uJ3QgcmUtYWN0aXZhdGUgcGFydGljbGVzIHRoYXQgYXJlbid0IGRlYWQgeWV0LlxuICAgICAgICAvLyBpZiAoIHBhcmFtc1sgaW5kZXggXSAhPT0gMC4wICYmICggdGhpcy5wYXJ0aWNsZUNvdW50ICE9PSAxIHx8IHRoaXMuYWN0aXZlTXVsdGlwbGllciAhPT0gMSApICkge1xuICAgICAgICAvLyAgICAgY29udGludWU7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoIHBhcmFtc1sgaW5kZXggXSAhPSAwLjAgJiYgdGhpcy5wYXJ0aWNsZUNvdW50ICE9PSAxICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIGFjdGl2ZSBwYXJ0aWNsZSBjb3VudC5cbiAgICAgICAgdGhpcy5faW5jcmVtZW50UGFydGljbGVDb3VudCgpO1xuXG4gICAgICAgIC8vIE1hcmsgdGhlIHBhcnRpY2xlIGFzIGFsaXZlLlxuICAgICAgICBwYXJhbXNbIGluZGV4IF0gPSAxLjA7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnRpY2xlXG4gICAgICAgIHRoaXMuX3Jlc2V0UGFydGljbGUoIGkgKTtcblxuICAgICAgICAvLyBNb3ZlIGVhY2ggcGFydGljbGUgYmVpbmcgYWN0aXZhdGVkIHRvXG4gICAgICAgIC8vIGl0J3MgYWN0dWFsIHBvc2l0aW9uIGluIHRpbWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgc3RvcHMgcGFydGljbGVzIGJlaW5nICdjbHVtcGVkJyB0b2dldGhlclxuICAgICAgICAvLyB3aGVuIGZyYW1lIHJhdGVzIGFyZSBvbiB0aGUgbG93ZXIgc2lkZSBvZiA2MGZwc1xuICAgICAgICAvLyBvciBub3QgY29uc3RhbnQgKGEgdmVyeSByZWFsIHBvc3NpYmlsaXR5ISlcbiAgICAgICAgZHRWYWx1ZSA9IGR0UGVyUGFydGljbGUgKiAoIGkgLSBhY3RpdmF0aW9uU3RhcnQgKVxuICAgICAgICBwYXJhbXNbIGluZGV4ICsgMSBdID0gZGlyZWN0aW9uID09PSAtMSA/IHBhcmFtc1sgaW5kZXggKyAyIF0gLSBkdFZhbHVlIDogZHRWYWx1ZTtcblxuICAgICAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVVcGRhdGVSYW5nZSggJ3BhcmFtcycsIGkgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNpbXVsYXRlcyBvbmUgZnJhbWUncyB3b3J0aCBvZiBwYXJ0aWNsZXMsIHVwZGF0aW5nIHBhcnRpY2xlc1xuICogdGhhdCBhcmUgYWxyZWFkeSBhbGl2ZSwgYW5kIG1hcmtpbmcgb25lcyB0aGF0IGFyZSBjdXJyZW50bHkgZGVhZFxuICogYnV0IHNob3VsZCBiZSBhbGl2ZSBhcyBhbGl2ZS5cbiAqXG4gKiBJZiB0aGUgZW1pdHRlciBpcyBtYXJrZWQgYXMgc3RhdGljLCB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCBkbyBub3RoaW5nLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gZHQgVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIHNpbXVsYXRlIChkZWx0YVRpbWUpXG4gKi9cblNQRS5FbWl0dGVyLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oIGR0ICkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICggdGhpcy5pc1N0YXRpYyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICggdGhpcy5wYXJhbXNBcnJheSA9PT0gbnVsbCApIHtcbiAgICAgICAgdGhpcy5wYXJhbXNBcnJheSA9IHRoaXMuYXR0cmlidXRlcy5wYXJhbXMudHlwZWRBcnJheS5hcnJheTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLmF0dHJpYnV0ZU9mZnNldCxcbiAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLnBhcnRpY2xlQ291bnQsXG4gICAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zQXJyYXksIC8vIHZlYzMoIGFsaXZlLCBhZ2UsIG1heEFnZSwgd2lnZ2xlIClcbiAgICAgICAgcHBzRHQgPSB0aGlzLnBhcnRpY2xlc1BlclNlY29uZCAqIHRoaXMuYWN0aXZlTXVsdGlwbGllciAqIGR0LFxuICAgICAgICBhY3RpdmF0aW9uSW5kZXggPSB0aGlzLmFjdGl2YXRpb25JbmRleDtcblxuICAgIC8vIFJlc2V0IHRoZSBidWZmZXIgdXBkYXRlIGluZGljZXMuXG4gICAgdGhpcy5fcmVzZXRCdWZmZXJSYW5nZXMoKTtcblxuICAgIC8vIEluY3JlbWVudCBhZ2UgZm9yIHRob3NlIHBhcnRpY2xlcyB0aGF0IGFyZSBhbGl2ZSxcbiAgICAvLyBhbmQga2lsbCBvZmYgYW55IHBhcnRpY2xlcyB3aG9zZSBhZ2UgaXMgb3ZlciB0aGUgbGltaXQuXG4gICAgdGhpcy5fY2hlY2tQYXJ0aWNsZUFnZXMoIHN0YXJ0LCBlbmQsIHBhcmFtcywgZHQgKTtcblxuICAgIC8vIElmIHRoZSBlbWl0dGVyIGlzIGRlYWQsIHJlc2V0IHRoZSBhZ2Ugb2YgdGhlIGVtaXR0ZXIgdG8gemVybyxcbiAgICAvLyByZWFkeSB0byBnbyBhZ2FpbiBpZiByZXF1aXJlZFxuICAgIGlmICggdGhpcy5hbGl2ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgIHRoaXMuYWdlID0gMC4wO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGVtaXR0ZXIgaGFzIGEgc3BlY2lmaWVkIGxpZmV0aW1lIGFuZCB3ZSd2ZSBleGNlZWRlZCBpdCxcbiAgICAvLyBtYXJrIHRoZSBlbWl0dGVyIGFzIGRlYWQuXG4gICAgaWYgKCB0aGlzLmR1cmF0aW9uICE9PSBudWxsICYmIHRoaXMuYWdlID4gdGhpcy5kdXJhdGlvbiApIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFnZSA9IDAuMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgdmFyIGFjdGl2YXRpb25TdGFydCA9IHRoaXMucGFydGljbGVDb3VudCA9PT0gMSA/IGFjdGl2YXRpb25JbmRleCA6ICggYWN0aXZhdGlvbkluZGV4IHwgMCApLFxuICAgICAgICBhY3RpdmF0aW9uRW5kID0gTWF0aC5taW4oIGFjdGl2YXRpb25TdGFydCArIHBwc0R0LCB0aGlzLmFjdGl2YXRpb25FbmQgKSxcbiAgICAgICAgYWN0aXZhdGlvbkNvdW50ID0gYWN0aXZhdGlvbkVuZCAtIHRoaXMuYWN0aXZhdGlvbkluZGV4IHwgMCxcbiAgICAgICAgZHRQZXJQYXJ0aWNsZSA9IGFjdGl2YXRpb25Db3VudCA+IDAgPyBkdCAvIGFjdGl2YXRpb25Db3VudCA6IDA7XG5cbiAgICB0aGlzLl9hY3RpdmF0ZVBhcnRpY2xlcyggYWN0aXZhdGlvblN0YXJ0LCBhY3RpdmF0aW9uRW5kLCBwYXJhbXMsIGR0UGVyUGFydGljbGUgKTtcblxuICAgIC8vIE1vdmUgdGhlIGFjdGl2YXRpb24gd2luZG93IGZvcndhcmQsIHNvbGRpZXIuXG4gICAgdGhpcy5hY3RpdmF0aW9uSW5kZXggKz0gcHBzRHQ7XG5cbiAgICBpZiAoIHRoaXMuYWN0aXZhdGlvbkluZGV4ID4gZW5kICkge1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25JbmRleCA9IHN0YXJ0O1xuICAgIH1cblxuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBhZ2Ugb2YgdGhlIGVtaXR0ZXIuXG4gICAgdGhpcy5hZ2UgKz0gZHQ7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBhbGwgdGhlIGVtaXR0ZXIncyBwYXJ0aWNsZXMgdG8gdGhlaXIgc3RhcnQgcG9zaXRpb25zXG4gKiBhbmQgbWFya3MgdGhlIHBhcnRpY2xlcyBhcyBkZWFkIGlmIHRoZSBgZm9yY2VgIGFyZ3VtZW50IGlzXG4gKiB0cnVlLlxuICpcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtmb3JjZT11bmRlZmluZWRdIElmIHRydWUsIGFsbCBwYXJ0aWNsZXMgd2lsbCBiZSBtYXJrZWQgYXMgZGVhZCBpbnN0YW50bHkuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfSAgICAgICBUaGlzIGVtaXR0ZXIgaW5zdGFuY2UuXG4gKi9cblNQRS5FbWl0dGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCBmb3JjZSApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLmFnZSA9IDAuMDtcbiAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG5cbiAgICBpZiAoIGZvcmNlID09PSB0cnVlICkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmF0dHJpYnV0ZU9mZnNldCxcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgdGhpcy5wYXJ0aWNsZUNvdW50LFxuICAgICAgICAgICAgYXJyYXkgPSB0aGlzLnBhcmFtc0FycmF5LFxuICAgICAgICAgICAgYXR0ciA9IHRoaXMuYXR0cmlidXRlcy5wYXJhbXMuYnVmZmVyQXR0cmlidXRlO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gZW5kIC0gMSwgaW5kZXg7IGkgPj0gc3RhcnQ7IC0taSApIHtcbiAgICAgICAgICAgIGluZGV4ID0gaSAqIDQ7XG5cbiAgICAgICAgICAgIGFycmF5WyBpbmRleCBdID0gMC4wO1xuICAgICAgICAgICAgYXJyYXlbIGluZGV4ICsgMSBdID0gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0ci51cGRhdGVSYW5nZS5vZmZzZXQgPSAwO1xuICAgICAgICBhdHRyLnVwZGF0ZVJhbmdlLmNvdW50ID0gLTE7XG4gICAgICAgIGF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIHRoZSBlbWl0dGVyLiBJZiBub3QgYWxyZWFkeSBlbmFibGVkLCB0aGUgZW1pdHRlclxuICogd2lsbCBzdGFydCBlbWl0dGluZyBwYXJ0aWNsZXMuXG4gKlxuICogQHJldHVybiB7RW1pdHRlcn0gVGhpcyBlbWl0dGVyIGluc3RhbmNlLlxuICovXG5TUEUuRW1pdHRlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlcyB0aCBlbWl0dGVyLCBidXQgZG9lcyBub3QgaW5zdGFudGx5IHJlbW92ZSBpdCdzXG4gKiBwYXJ0aWNsZXMgZnJvbXQgdGhlIHNjZW5lLiBXaGVuIGNhbGxlZCwgdGhlIGVtaXR0ZXIgd2lsbCBiZVxuICogJ3N3aXRjaGVkIG9mZicgYW5kIGp1c3Qgc3RvcCBlbWl0dGluZy4gQW55IHBhcnRpY2xlJ3MgYWxpdmUgd2lsbFxuICogYmUgYWxsb3dlZCB0byBmaW5pc2ggdGhlaXIgbGlmZWN5Y2xlLlxuICpcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9IFRoaXMgZW1pdHRlciBpbnN0YW5jZS5cbiAqL1xuU1BFLkVtaXR0ZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGlzIGVtaXR0ZXIgZnJvbSBpdCdzIHBhcmVudCBncm91cCAoaWYgaXQgaGFzIGJlZW4gYWRkZWQgdG8gb25lKS5cbiAqIERlbGdhdGVzIHRvIFNQRS5ncm91cC5wcm90b3R5cGUucmVtb3ZlRW1pdHRlcigpLlxuICpcbiAqIFdoZW4gY2FsbGVkLCBhbGwgcGFydGljbGUncyBiZWxvbmdpbmcgdG8gdGhpcyBlbWl0dGVyIHdpbGwgYmUgaW5zdGFudGx5XG4gKiByZW1vdmVkIGZyb20gdGhlIHNjZW5lLlxuICpcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9IFRoaXMgZW1pdHRlciBpbnN0YW5jZS5cbiAqXG4gKiBAc2VlIFNQRS5Hcm91cC5wcm90b3R5cGUucmVtb3ZlRW1pdHRlclxuICovXG5TUEUuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICggdGhpcy5ncm91cCAhPT0gbnVsbCApIHtcbiAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVFbWl0dGVyKCB0aGlzICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCAnRW1pdHRlciBkb2VzIG5vdCBiZWxvbmcgdG8gYSBncm91cCwgY2Fubm90IHJlbW92ZS4nICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FmcmFtZS1wYXJ0aWNsZS1zeXN0ZW0tY29tcG9uZW50L2xpYi9TUEUuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ2Jhc2ljJzoge3dyYXBDb3VudDogMzAsIGlucHV0T2Zmc2V0WTogMC4wMDgsIGlucHV0T2Zmc2V0WDogMC4wOCwgaW1nOiAnc2stYmFzaWMucG5nJywgbGF5b3V0OiBbeydrZXknOiAnMScsICd4JzogMC4wNDQsICd5JzogMC4yMjYsICd3JzogMC4wNzksICdoJzogMC4xNTJ9LCB7J2tleSc6ICcyJywgJ3gnOiAwLjEyNCwgJ3knOiAwLjIyNiwgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1Mn0sIHsna2V5JzogJzMnLCAneCc6IDAuMjAzLCAneSc6IDAuMjI2LCAndyc6IDAuMDc5LCAnaCc6IDAuMTUyfSwgeydrZXknOiAnNCcsICd4JzogMC4yODIsICd5JzogMC4yMjYsICd3JzogMC4wOCwgJ2gnOiAwLjE1Mn0sIHsna2V5JzogJzUnLCAneCc6IDAuMzYzLCAneSc6IDAuMjI2LCAndyc6IDAuMDc5LCAnaCc6IDAuMTUyfSwgeydrZXknOiAnNicsICd4JzogMC40NDIsICd5JzogMC4yMjYsICd3JzogMC4wNzksICdoJzogMC4xNTJ9LCB7J2tleSc6ICc3JywgJ3gnOiAwLjUyMSwgJ3knOiAwLjIyNiwgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1Mn0sIHsna2V5JzogJzgnLCAneCc6IDAuNjAxLCAneSc6IDAuMjI2LCAndyc6IDAuMDgsICdoJzogMC4xNTJ9LCB7J2tleSc6ICc5JywgJ3gnOiAwLjY4MSwgJ3knOiAwLjIyNiwgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1Mn0sIHsna2V5JzogJzAnLCAneCc6IDAuNzYxLCAneSc6IDAuMjI2LCAndyc6IDAuMDc5LCAnaCc6IDAuMTUyfSwgeydrZXknOiAnRGVsZXRlJywgJ3gnOiAwLjg0NiwgJ3knOiAwLjIyNywgJ3cnOiAwLjEwOCwgJ2gnOiAwLjE0Nn0sIHsna2V5JzogJ0VudGVyJywgJ3gnOiAwLjg0NywgJ3knOiAwLjUyNiwgJ3cnOiAwLjEwOCwgJ2gnOiAwLjI0NH0sIHsna2V5JzogJ3EnLCAneCc6IDAuMDQ0LCAneSc6IDAuMzc3LCAndyc6IDAuMDc5LCAnaCc6IDAuMTUyfSwgeydrZXknOiAndycsICd4JzogMC4xMjQsICd5JzogMC4zNzcsICd3JzogMC4wNzksICdoJzogMC4xNTJ9LCB7J2tleSc6ICdlJywgJ3gnOiAwLjIwMywgJ3knOiAwLjM3NywgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1Mn0sIHsna2V5JzogJ3InLCAneCc6IDAuMjgyLCAneSc6IDAuMzc3LCAndyc6IDAuMDgsICdoJzogMC4xNTJ9LCB7J2tleSc6ICd0JywgJ3gnOiAwLjM2MywgJ3knOiAwLjM3NywgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1Mn0sIHsna2V5JzogJ3knLCAneCc6IDAuNDQyLCAneSc6IDAuMzc3LCAndyc6IDAuMDc5LCAnaCc6IDAuMTUyfSwgeydrZXknOiAndScsICd4JzogMC41MjEsICd5JzogMC4zNzcsICd3JzogMC4wNzksICdoJzogMC4xNTJ9LCB7J2tleSc6ICdpJywgJ3gnOiAwLjYwMSwgJ3knOiAwLjM3NywgJ3cnOiAwLjA4LCAnaCc6IDAuMTUyfSwgeydrZXknOiAnbycsICd4JzogMC42ODEsICd5JzogMC4zNzcsICd3JzogMC4wNzksICdoJzogMC4xNTJ9LCB7J2tleSc6ICdwJywgJ3gnOiAwLjc2MSwgJ3knOiAwLjM3NywgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1Mn0sIHsna2V5JzogJ2wnLCAneCc6IDAuNzI5LCAneSc6IDAuNTMsICd3JzogMC4wOCwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ2EnLCAneCc6IDAuMDkyLCAneSc6IDAuNTMsICd3JzogMC4wOCwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ3MnLCAneCc6IDAuMTcxLCAneSc6IDAuNTMsICd3JzogMC4wOCwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ2QnLCAneCc6IDAuMjUxLCAneSc6IDAuNTMsICd3JzogMC4wOCwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ2YnLCAneCc6IDAuMzMxLCAneSc6IDAuNTMsICd3JzogMC4wNzksICdoJzogMC4xNTR9LCB7J2tleSc6ICdnJywgJ3gnOiAwLjQxLCAneSc6IDAuNTMsICd3JzogMC4wOCwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ2gnLCAneCc6IDAuNDksICd5JzogMC41MywgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ2onLCAneCc6IDAuNTcsICd5JzogMC41MywgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ2snLCAneCc6IDAuNjQ5LCAneSc6IDAuNTMsICd3JzogMC4wOCwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ3onLCAneCc6IDAuMTcyLCAneSc6IDAuNjg0LCAndyc6IDAuMDc5LCAnaCc6IDAuMTU0fSwgeydrZXknOiAneCcsICd4JzogMC4yNTEsICd5JzogMC42ODQsICd3JzogMC4wOCwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ2MnLCAneCc6IDAuMzMxLCAneSc6IDAuNjg0LCAndyc6IDAuMDc5LCAnaCc6IDAuMTU0fSwgeydrZXknOiAndicsICd4JzogMC40MSwgJ3knOiAwLjY4NCwgJ3cnOiAwLjA4LCAnaCc6IDAuMTU0fSwgeydrZXknOiAnYicsICd4JzogMC40OSwgJ3knOiAwLjY4NCwgJ3cnOiAwLjA4LCAnaCc6IDAuMTU0fSwgeydrZXknOiAnbicsICd4JzogMC41NywgJ3knOiAwLjY4NCwgJ3cnOiAwLjA3OSwgJ2gnOiAwLjE1NH0sIHsna2V5JzogJ20nLCAneCc6IDAuNjQ5LCAneSc6IDAuNjg0LCAndyc6IDAuMDgsICdoJzogMC4xNTR9LCB7J2tleSc6ICcgJywgJ3gnOiAwLjI3LCAneSc6IDAuODM4LCAndyc6IDAuNDE1LCAnaCc6IDAuMTI2fSwgeydrZXknOiAnU2hpZnQnLCAneCc6IDAuMDQyLCAneSc6IDAuODI3LCAndyc6IDAuMDY4LCAnaCc6IDAuMTQyfSwgeydrZXknOiAnRXNjYXBlJywgJ3gnOiAwLjg3NiwgJ3knOiAwLjgyMywgJ3cnOiAwLjA3OCwgJ2gnOiAwLjEzNH0sIHsna2V5JzogJ0luc2VydCcsICd4JzogMC4wNTgsICd5JzogMCwgJ3cnOiAwLjg4MSwgJ2gnOiAwLjE0OX1dfSxcbiAgJ251bXBhZCc6IHt3cmFwQ291bnQ6IDIwLCBpbnB1dE9mZnNldFk6IDAuMDA1LCBpbnB1dE9mZnNldFg6IDAuMzIsIGltZzogJ3NrLW51bXBhZC5wbmcnLCBsYXlvdXQ6IFt7J2tleSc6ICc3JywgJ3gnOiAwLjMxMywgJ3knOiAwLjI1NCwgJ3cnOiAwLjA4OCwgJ2gnOiAwLjE3N30sIHsna2V5JzogJzgnLCAneCc6IDAuNDAxLCAneSc6IDAuMjU0LCAndyc6IDAuMDg4LCAnaCc6IDAuMTc3fSwgeydrZXknOiAnOScsICd4JzogMC40OSwgJ3knOiAwLjI1NCwgJ3cnOiAwLjA4OCwgJ2gnOiAwLjE3N30sIHsna2V5JzogJzQnLCAneCc6IDAuMzEzLCAneSc6IDAuNDMxLCAndyc6IDAuMDg4LCAnaCc6IDAuMTc3fSwgeydrZXknOiAnNScsICd4JzogMC40MDEsICd5JzogMC40MzEsICd3JzogMC4wODgsICdoJzogMC4xNzd9LCB7J2tleSc6ICc2JywgJ3gnOiAwLjQ5LCAneSc6IDAuNDMxLCAndyc6IDAuMDg4LCAnaCc6IDAuMTc3fSwgeydrZXknOiAnMicsICd4JzogMC40MDEsICd5JzogMC42MDgsICd3JzogMC4wODgsICdoJzogMC4xNzd9LCB7J2tleSc6ICcxJywgJ3gnOiAwLjMxMywgJ3knOiAwLjYwOCwgJ3cnOiAwLjA4OCwgJ2gnOiAwLjE3N30sIHsna2V5JzogJzMnLCAneCc6IDAuNDksICd5JzogMC42MDgsICd3JzogMC4wODgsICdoJzogMC4xNzd9LCB7J2tleSc6ICcwJywgJ3gnOiAwLjMxMywgJ3knOiAwLjc4NSwgJ3cnOiAwLjE3NywgJ2gnOiAwLjE2MX0sIHsna2V5JzogJy4nLCAneCc6IDAuNDksICd5JzogMC43ODUsICd3JzogMC4wODgsICdoJzogMC4xNjF9LCB7J2tleSc6ICdFc2NhcGUnLCAneCc6IDAuNTc4LCAneSc6IDAuNzg1LCAndyc6IDAuMTA1LCAnaCc6IDAuMTYxfSwgeydrZXknOiAnRW50ZXInLCAneCc6IDAuNTc4LCAneSc6IDAuNDMxLCAndyc6IDAuMTA1LCAnaCc6IDAuMzU0fSwgeydrZXknOiAnRGVsZXRlJywgJ3gnOiAwLjU3OCwgJ3knOiAwLjI1NCwgJ3cnOiAwLjEwNSwgJ2gnOiAwLjE3N30sIHsna2V5JzogJ0luc2VydCcsICd4JzogMC4yOTQsICd5JzogMC4wMDEsICd3JzogMC40MDksICdoJzogMC4xOX1dfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZnJhbWUtc3VwZXIta2V5Ym9hcmQva2V5Ym9hcmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBBbGdvbGlhU2VhcmNoQ29yZTtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgZXhpdFByb21pc2UgPSByZXF1aXJlKCcuL2V4aXRQcm9taXNlLmpzJyk7XG52YXIgSW5kZXhDb3JlID0gcmVxdWlyZSgnLi9JbmRleENvcmUuanMnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUuanMnKTtcblxuLy8gV2Ugd2lsbCBhbHdheXMgcHV0IHRoZSBBUEkgS0VZIGluIHRoZSBKU09OIGJvZHkgaW4gY2FzZSBvZiB0b28gbG9uZyBBUEkgS0VZLFxuLy8gdG8gYXZvaWQgcXVlcnkgc3RyaW5nIGJlaW5nIHRvbyBsb25nIGFuZCBmYWlsaW5nIGluIHZhcmlvdXMgY29uZGl0aW9ucyAob3VyIHNlcnZlciBsaW1pdCwgYnJvd3NlciBsaW1pdCxcbi8vIHByb3hpZXMgbGltaXQpXG52YXIgTUFYX0FQSV9LRVlfTEVOR1RIID0gNTAwO1xudmFyIFJFU0VUX0FQUF9EQVRBX1RJTUVSID1cbiAgcHJvY2Vzcy5lbnYuUkVTRVRfQVBQX0RBVEFfVElNRVIgJiYgcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVTRVRfQVBQX0RBVEFfVElNRVIsIDEwKSB8fFxuICA2MCAqIDIgKiAxMDAwOyAvLyBhZnRlciAyIG1pbnV0ZXMgcmVzZXQgdG8gZmlyc3QgaG9zdFxuXG4vKlxuICogQWxnb2xpYSBTZWFyY2ggbGlicmFyeSBpbml0aWFsaXphdGlvblxuICogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFwcGxpY2F0aW9uSUQgLSBZb3VyIGFwcGxpY2F0aW9uSUQsIGZvdW5kIGluIHlvdXIgZGFzaGJvYXJkXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5IC0gWW91ciBBUEkga2V5LCBmb3VuZCBpbiB5b3VyIGRhc2hib2FyZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MjAwMF0gLSBUaGUgcmVxdWVzdCB0aW1lb3V0IHNldCBpbiBtaWxsaXNlY29uZHMsXG4gKiBhbm90aGVyIHJlcXVlc3Qgd2lsbCBiZSBpc3N1ZWQgYWZ0ZXIgdGhpcyB0aW1lb3V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJvdG9jb2w9J2h0dHBzOiddIC0gVGhlIHByb3RvY29sIHVzZWQgdG8gcXVlcnkgQWxnb2xpYSBTZWFyY2ggQVBJLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0IHRvICdodHRwOicgdG8gZm9yY2UgdXNpbmcgaHR0cC5cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBbb3B0cy5ob3N0cz17XG4gKiAgICAgICAgICAgcmVhZDogW3RoaXMuYXBwbGljYXRpb25JRCArICctZHNuLmFsZ29saWEubmV0J10uY29uY2F0KFtcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMS5hbGdvbGlhbmV0LmNvbScsXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTIuYWxnb2xpYW5ldC5jb20nLFxuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0zLmFsZ29saWFuZXQuY29tJ11cbiAqICAgICAgICAgICBdKSxcbiAqICAgICAgICAgICB3cml0ZTogW3RoaXMuYXBwbGljYXRpb25JRCArICcuYWxnb2xpYS5uZXQnXS5jb25jYXQoW1xuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0xLmFsZ29saWFuZXQuY29tJyxcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMi5hbGdvbGlhbmV0LmNvbScsXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTMuYWxnb2xpYW5ldC5jb20nXVxuICogICAgICAgICAgIF0pIC0gVGhlIGhvc3RzIHRvIHVzZSBmb3IgQWxnb2xpYSBTZWFyY2ggQVBJLlxuICogICAgICAgICAgIElmIHlvdSBwcm92aWRlIHRoZW0sIHlvdSB3aWxsIGxlc3MgYmVuZWZpdCBmcm9tIG91ciBIQSBpbXBsZW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiBBbGdvbGlhU2VhcmNoQ29yZShhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpIHtcbiAgdmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxnb2xpYXNlYXJjaCcpO1xuXG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKTtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogYWxnb2xpYXNlYXJjaChhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpJztcblxuICBpZiAob3B0cy5fYWxsb3dFbXB0eUNyZWRlbnRpYWxzICE9PSB0cnVlICYmICFhcHBsaWNhdGlvbklEKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGFuIGFwcGxpY2F0aW9uIElELiAnICsgdXNhZ2UpO1xuICB9XG5cbiAgaWYgKG9wdHMuX2FsbG93RW1wdHlDcmVkZW50aWFscyAhPT0gdHJ1ZSAmJiAhYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGFuIEFQSSBrZXkuICcgKyB1c2FnZSk7XG4gIH1cblxuICB0aGlzLmFwcGxpY2F0aW9uSUQgPSBhcHBsaWNhdGlvbklEO1xuICB0aGlzLmFwaUtleSA9IGFwaUtleTtcblxuICB0aGlzLmhvc3RzID0ge1xuICAgIHJlYWQ6IFtdLFxuICAgIHdyaXRlOiBbXVxuICB9O1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuX3RpbWVvdXRzID0gb3B0cy50aW1lb3V0cyB8fCB7XG4gICAgY29ubmVjdDogMSAqIDEwMDAsIC8vIDUwMG1zIGNvbm5lY3QgaXMgR1BSUyBsYXRlbmN5XG4gICAgcmVhZDogMiAqIDEwMDAsXG4gICAgd3JpdGU6IDMwICogMTAwMFxuICB9O1xuXG4gIC8vIGJhY2t3YXJkIGNvbXBhdCwgaWYgb3B0cy50aW1lb3V0IGlzIHBhc3NlZCwgd2UgdXNlIGl0IHRvIGNvbmZpZ3VyZSBhbGwgdGltZW91dHMgbGlrZSBiZWZvcmVcbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHRoaXMuX3RpbWVvdXRzLmNvbm5lY3QgPSB0aGlzLl90aW1lb3V0cy5yZWFkID0gdGhpcy5fdGltZW91dHMud3JpdGUgPSBvcHRzLnRpbWVvdXQ7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8ICdodHRwczonO1xuICAvLyB3aGlsZSB3ZSBhZHZvY2F0ZSBmb3IgY29sb24tYXQtdGhlLWVuZCB2YWx1ZXM6ICdodHRwOicgZm9yIGBvcHRzLnByb3RvY29sYFxuICAvLyB3ZSBhbHNvIGFjY2VwdCBgaHR0cGAgYW5kIGBodHRwc2AuIEl0J3MgYSBjb21tb24gZXJyb3IuXG4gIGlmICghLzokLy50ZXN0KHByb3RvY29sKSkge1xuICAgIHByb3RvY29sID0gcHJvdG9jb2wgKyAnOic7XG4gIH1cblxuICBpZiAocHJvdG9jb2wgIT09ICdodHRwOicgJiYgcHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ3Byb3RvY29sIG11c3QgYmUgYGh0dHA6YCBvciBgaHR0cHM6YCAod2FzIGAnICsgb3B0cy5wcm90b2NvbCArICdgKScpO1xuICB9XG5cbiAgdGhpcy5fY2hlY2tBcHBJZERhdGEoKTtcblxuICBpZiAoIW9wdHMuaG9zdHMpIHtcbiAgICB2YXIgZGVmYXVsdEhvc3RzID0gbWFwKHRoaXMuX3NodWZmbGVSZXN1bHQsIGZ1bmN0aW9uKGhvc3ROdW1iZXIpIHtcbiAgICAgIHJldHVybiBhcHBsaWNhdGlvbklEICsgJy0nICsgaG9zdE51bWJlciArICcuYWxnb2xpYW5ldC5jb20nO1xuICAgIH0pO1xuXG4gICAgLy8gbm8gaG9zdHMgZ2l2ZW4sIGNvbXB1dGUgZGVmYXVsdHNcbiAgICB2YXIgbWFpblN1ZmZpeCA9IChvcHRzLmRzbiA9PT0gZmFsc2UgPyAnJyA6ICctZHNuJykgKyAnLmFsZ29saWEubmV0JztcbiAgICB0aGlzLmhvc3RzLnJlYWQgPSBbdGhpcy5hcHBsaWNhdGlvbklEICsgbWFpblN1ZmZpeF0uY29uY2F0KGRlZmF1bHRIb3N0cyk7XG4gICAgdGhpcy5ob3N0cy53cml0ZSA9IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLmFsZ29saWEubmV0J10uY29uY2F0KGRlZmF1bHRIb3N0cyk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShvcHRzLmhvc3RzKSkge1xuICAgIC8vIHdoZW4gcGFzc2luZyBjdXN0b20gaG9zdHMsIHdlIG5lZWQgdG8gaGF2ZSBhIGRpZmZlcmVudCBob3N0IGluZGV4IGlmIHRoZSBudW1iZXJcbiAgICAvLyBvZiB3cml0ZS9yZWFkIGhvc3RzIGFyZSBkaWZmZXJlbnQuXG4gICAgdGhpcy5ob3N0cy5yZWFkID0gY2xvbmUob3B0cy5ob3N0cyk7XG4gICAgdGhpcy5ob3N0cy53cml0ZSA9IGNsb25lKG9wdHMuaG9zdHMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaG9zdHMucmVhZCA9IGNsb25lKG9wdHMuaG9zdHMucmVhZCk7XG4gICAgdGhpcy5ob3N0cy53cml0ZSA9IGNsb25lKG9wdHMuaG9zdHMud3JpdGUpO1xuICB9XG5cbiAgLy8gYWRkIHByb3RvY29sIGFuZCBsb3dlcmNhc2UgaG9zdHNcbiAgdGhpcy5ob3N0cy5yZWFkID0gbWFwKHRoaXMuaG9zdHMucmVhZCwgcHJlcGFyZUhvc3QocHJvdG9jb2wpKTtcbiAgdGhpcy5ob3N0cy53cml0ZSA9IG1hcCh0aGlzLmhvc3RzLndyaXRlLCBwcmVwYXJlSG9zdChwcm90b2NvbCkpO1xuXG4gIHRoaXMuZXh0cmFIZWFkZXJzID0ge307XG5cbiAgLy8gSW4gc29tZSBzaXR1YXRpb25zIHlvdSBtaWdodCB3YW50IHRvIHdhcm0gdGhlIGNhY2hlXG4gIHRoaXMuY2FjaGUgPSBvcHRzLl9jYWNoZSB8fCB7fTtcblxuICB0aGlzLl91YSA9IG9wdHMuX3VhO1xuICB0aGlzLl91c2VDYWNoZSA9IG9wdHMuX3VzZUNhY2hlID09PSB1bmRlZmluZWQgfHwgb3B0cy5fY2FjaGUgPyB0cnVlIDogb3B0cy5fdXNlQ2FjaGU7XG4gIHRoaXMuX3VzZVJlcXVlc3RDYWNoZSA9IHRoaXMuX3VzZUNhY2hlICYmIG9wdHMuX3VzZVJlcXVlc3RDYWNoZTtcbiAgdGhpcy5fdXNlRmFsbGJhY2sgPSBvcHRzLnVzZUZhbGxiYWNrID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy51c2VGYWxsYmFjaztcblxuICB0aGlzLl9zZXRUaW1lb3V0ID0gb3B0cy5fc2V0VGltZW91dDtcblxuICBkZWJ1ZygnaW5pdCBkb25lLCAlaicsIHRoaXMpO1xufVxuXG4vKlxuICogR2V0IHRoZSBpbmRleCBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqXG4gKiBAcGFyYW0gaW5kZXhOYW1lIHRoZSBuYW1lIG9mIGluZGV4XG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayB3aXRoIG9uZSBhcmd1bWVudCAodGhlIEluZGV4IGluc3RhbmNlKVxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuaW5pdEluZGV4ID0gZnVuY3Rpb24oaW5kZXhOYW1lKSB7XG4gIHJldHVybiBuZXcgSW5kZXhDb3JlKHRoaXMsIGluZGV4TmFtZSk7XG59O1xuXG4vKipcbiogQWRkIGFuIGV4dHJhIGZpZWxkIHRvIHRoZSBIVFRQIHJlcXVlc3RcbipcbiogQHBhcmFtIG5hbWUgdGhlIGhlYWRlciBmaWVsZCBuYW1lXG4qIEBwYXJhbSB2YWx1ZSB0aGUgaGVhZGVyIGZpZWxkIHZhbHVlXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldEV4dHJhSGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5leHRyYUhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xufTtcblxuLyoqXG4qIEdldCB0aGUgdmFsdWUgb2YgYW4gZXh0cmEgSFRUUCBoZWFkZXJcbipcbiogQHBhcmFtIG5hbWUgdGhlIGhlYWRlciBmaWVsZCBuYW1lXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLmdldEV4dHJhSGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5leHRyYUhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuKiBSZW1vdmUgYW4gZXh0cmEgZmllbGQgZnJvbSB0aGUgSFRUUCByZXF1ZXN0XG4qXG4qIEBwYXJhbSBuYW1lIHRoZSBoZWFkZXIgZmllbGQgbmFtZVxuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS51bnNldEV4dHJhSGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICBkZWxldGUgdGhpcy5leHRyYUhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuKiBBdWdtZW50IHNlbnQgeC1hbGdvbGlhLWFnZW50IHdpdGggbW9yZSBkYXRhLCBlYWNoIGFnZW50IHBhcnRcbiogaXMgYXV0b21hdGljYWxseSBzZXBhcmF0ZWQgZnJvbSB0aGUgb3RoZXJzIGJ5IGEgc2VtaWNvbG9uO1xuKlxuKiBAcGFyYW0gYWxnb2xpYUFnZW50IHRoZSBhZ2VudCB0byBhZGRcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuYWRkQWxnb2xpYUFnZW50ID0gZnVuY3Rpb24oYWxnb2xpYUFnZW50KSB7XG4gIGlmICh0aGlzLl91YS5pbmRleE9mKCc7JyArIGFsZ29saWFBZ2VudCkgPT09IC0xKSB7XG4gICAgdGhpcy5fdWEgKz0gJzsnICsgYWxnb2xpYUFnZW50O1xuICB9XG59O1xuXG4vKlxuICogV3JhcHBlciB0aGF0IHRyeSBhbGwgaG9zdHMgdG8gbWF4aW1pemUgdGhlIHF1YWxpdHkgb2Ygc2VydmljZVxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2pzb25SZXF1ZXN0ID0gZnVuY3Rpb24oaW5pdGlhbE9wdHMpIHtcbiAgdGhpcy5fY2hlY2tBcHBJZERhdGEoKTtcblxuICB2YXIgcmVxdWVzdERlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxnb2xpYXNlYXJjaDonICsgaW5pdGlhbE9wdHMudXJsKTtcblxuXG4gIHZhciBib2R5O1xuICB2YXIgY2FjaGVJRDtcbiAgdmFyIGFkZGl0aW9uYWxVQSA9IGluaXRpYWxPcHRzLmFkZGl0aW9uYWxVQSB8fCAnJztcbiAgdmFyIGNhY2hlID0gaW5pdGlhbE9wdHMuY2FjaGU7XG4gIHZhciBjbGllbnQgPSB0aGlzO1xuICB2YXIgdHJpZXMgPSAwO1xuICB2YXIgdXNpbmdGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgaGFzRmFsbGJhY2sgPSBjbGllbnQuX3VzZUZhbGxiYWNrICYmIGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjayAmJiBpbml0aWFsT3B0cy5mYWxsYmFjaztcbiAgdmFyIGhlYWRlcnM7XG5cbiAgaWYgKFxuICAgIHRoaXMuYXBpS2V5Lmxlbmd0aCA+IE1BWF9BUElfS0VZX0xFTkdUSCAmJlxuICAgIGluaXRpYWxPcHRzLmJvZHkgIT09IHVuZGVmaW5lZCAmJlxuICAgIChpbml0aWFsT3B0cy5ib2R5LnBhcmFtcyAhPT0gdW5kZWZpbmVkIHx8IC8vIGluZGV4LnNlYXJjaCgpXG4gICAgaW5pdGlhbE9wdHMuYm9keS5yZXF1ZXN0cyAhPT0gdW5kZWZpbmVkKSAvLyBjbGllbnQuc2VhcmNoKClcbiAgKSB7XG4gICAgaW5pdGlhbE9wdHMuYm9keS5hcGlLZXkgPSB0aGlzLmFwaUtleTtcbiAgICBoZWFkZXJzID0gdGhpcy5fY29tcHV0ZVJlcXVlc3RIZWFkZXJzKHtcbiAgICAgIGFkZGl0aW9uYWxVQTogYWRkaXRpb25hbFVBLFxuICAgICAgd2l0aEFwaUtleTogZmFsc2UsXG4gICAgICBoZWFkZXJzOiBpbml0aWFsT3B0cy5oZWFkZXJzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHRoaXMuX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyh7XG4gICAgICBhZGRpdGlvbmFsVUE6IGFkZGl0aW9uYWxVQSxcbiAgICAgIGhlYWRlcnM6IGluaXRpYWxPcHRzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpbml0aWFsT3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBib2R5ID0gc2FmZUpTT05TdHJpbmdpZnkoaW5pdGlhbE9wdHMuYm9keSk7XG4gIH1cblxuICByZXF1ZXN0RGVidWcoJ3JlcXVlc3Qgc3RhcnQnKTtcbiAgdmFyIGRlYnVnRGF0YSA9IFtdO1xuXG5cbiAgZnVuY3Rpb24gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cykge1xuICAgIGNsaWVudC5fY2hlY2tBcHBJZERhdGEoKTtcblxuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUgJiYgIWNsaWVudC5fdXNlUmVxdWVzdENhY2hlKSB7XG4gICAgICBjYWNoZUlEID0gaW5pdGlhbE9wdHMudXJsO1xuICAgIH1cblxuICAgIC8vIGFzIHdlIHNvbWV0aW1lIHVzZSBQT1NUIHJlcXVlc3RzIHRvIHBhc3MgcGFyYW1ldGVycyAobGlrZSBxdWVyeT0nYWEnKSxcbiAgICAvLyB0aGUgY2FjaGVJRCBtdXN0IGFsc28gaW5jbHVkZSB0aGUgYm9keSB0byBiZSBkaWZmZXJlbnQgYmV0d2VlbiBjYWxsc1xuICAgIGlmIChjbGllbnQuX3VzZUNhY2hlICYmICFjbGllbnQuX3VzZVJlcXVlc3RDYWNoZSAmJiBib2R5KSB7XG4gICAgICBjYWNoZUlEICs9ICdfYm9keV8nICsgcmVxT3B0cy5ib2R5O1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBjYWNoZSBleGlzdGVuY2VcbiAgICBpZiAoaXNDYWNoZVZhbGlkV2l0aEN1cnJlbnRJRCghY2xpZW50Ll91c2VSZXF1ZXN0Q2FjaGUsIGNhY2hlLCBjYWNoZUlEKSkge1xuICAgICAgcmVxdWVzdERlYnVnKCdzZXJ2aW5nIHJlc3BvbnNlIGZyb20gY2FjaGUnKTtcblxuICAgICAgdmFyIHJlc3BvbnNlVGV4dCA9IGNhY2hlW2NhY2hlSURdO1xuXG4gICAgICAvLyBDYWNoZSByZXNwb25zZSBtdXN0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBvcmlnaW5hbCBvbmVcbiAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGJvZHk6IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KSxcbiAgICAgICAgcmVzcG9uc2VUZXh0OiByZXNwb25zZVRleHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIHJlYWNoZWQgbWF4IHRyaWVzXG4gICAgaWYgKHRyaWVzID49IGNsaWVudC5ob3N0c1tpbml0aWFsT3B0cy5ob3N0VHlwZV0ubGVuZ3RoKSB7XG4gICAgICBpZiAoIWhhc0ZhbGxiYWNrIHx8IHVzaW5nRmFsbGJhY2spIHtcbiAgICAgICAgcmVxdWVzdERlYnVnKCdjb3VsZCBub3QgZ2V0IGFueSByZXNwb25zZScpO1xuICAgICAgICAvLyB0aGVuIHN0b3BcbiAgICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5yZWplY3QobmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb25uZWN0IHRvIHRoZSBBbGdvbGlhU2VhcmNoIEFQSS4nICtcbiAgICAgICAgICAnIFNlbmQgYW4gZW1haWwgdG8gc3VwcG9ydEBhbGdvbGlhLmNvbSB0byByZXBvcnQgYW5kIHJlc29sdmUgdGhlIGlzc3VlLicgK1xuICAgICAgICAgICcgQXBwbGljYXRpb24gaWQgd2FzOiAnICsgY2xpZW50LmFwcGxpY2F0aW9uSUQsIHtkZWJ1Z0RhdGE6IGRlYnVnRGF0YX1cbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3REZWJ1Zygnc3dpdGNoaW5nIHRvIGZhbGxiYWNrJyk7XG5cbiAgICAgIC8vIGxldCdzIHRyeSB0aGUgZmFsbGJhY2sgc3RhcnRpbmcgZnJvbSBoZXJlXG4gICAgICB0cmllcyA9IDA7XG5cbiAgICAgIC8vIG1ldGhvZCwgdXJsIGFuZCBib2R5IGFyZSBmYWxsYmFjayBkZXBlbmRlbnRcbiAgICAgIHJlcU9wdHMubWV0aG9kID0gaW5pdGlhbE9wdHMuZmFsbGJhY2subWV0aG9kO1xuICAgICAgcmVxT3B0cy51cmwgPSBpbml0aWFsT3B0cy5mYWxsYmFjay51cmw7XG4gICAgICByZXFPcHRzLmpzb25Cb2R5ID0gaW5pdGlhbE9wdHMuZmFsbGJhY2suYm9keTtcbiAgICAgIGlmIChyZXFPcHRzLmpzb25Cb2R5KSB7XG4gICAgICAgIHJlcU9wdHMuYm9keSA9IHNhZmVKU09OU3RyaW5naWZ5KHJlcU9wdHMuanNvbkJvZHkpO1xuICAgICAgfVxuICAgICAgLy8gcmUtY29tcHV0ZSBoZWFkZXJzLCB0aGV5IGNvdWxkIGJlIG9taXR0aW5nIHRoZSBBUEkgS0VZXG4gICAgICBoZWFkZXJzID0gY2xpZW50Ll9jb21wdXRlUmVxdWVzdEhlYWRlcnMoe1xuICAgICAgICBhZGRpdGlvbmFsVUE6IGFkZGl0aW9uYWxVQSxcbiAgICAgICAgaGVhZGVyczogaW5pdGlhbE9wdHMuaGVhZGVyc1xuICAgICAgfSk7XG5cbiAgICAgIHJlcU9wdHMudGltZW91dHMgPSBjbGllbnQuX2dldFRpbWVvdXRzRm9yUmVxdWVzdChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICBjbGllbnQuX3NldEhvc3RJbmRleEJ5VHlwZSgwLCBpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICB1c2luZ0ZhbGxiYWNrID0gdHJ1ZTsgLy8gdGhlIGN1cnJlbnQgcmVxdWVzdCBpcyBub3cgdXNpbmcgZmFsbGJhY2tcbiAgICAgIHJldHVybiBkb1JlcXVlc3QoY2xpZW50Ll9yZXF1ZXN0LmZhbGxiYWNrLCByZXFPcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEhvc3QgPSBjbGllbnQuX2dldEhvc3RCeVR5cGUoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuXG4gICAgdmFyIHVybCA9IGN1cnJlbnRIb3N0ICsgcmVxT3B0cy51cmw7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBib2R5OiByZXFPcHRzLmJvZHksXG4gICAgICBqc29uQm9keTogcmVxT3B0cy5qc29uQm9keSxcbiAgICAgIG1ldGhvZDogcmVxT3B0cy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgdGltZW91dHM6IHJlcU9wdHMudGltZW91dHMsXG4gICAgICBkZWJ1ZzogcmVxdWVzdERlYnVnLFxuICAgICAgZm9yY2VBdXRoSGVhZGVyczogcmVxT3B0cy5mb3JjZUF1dGhIZWFkZXJzXG4gICAgfTtcblxuICAgIHJlcXVlc3REZWJ1ZygnbWV0aG9kOiAlcywgdXJsOiAlcywgaGVhZGVyczogJWosIHRpbWVvdXRzOiAlZCcsXG4gICAgICBvcHRpb25zLm1ldGhvZCwgdXJsLCBvcHRpb25zLmhlYWRlcnMsIG9wdGlvbnMudGltZW91dHMpO1xuXG4gICAgaWYgKHJlcXVlc3RlciA9PT0gY2xpZW50Ll9yZXF1ZXN0LmZhbGxiYWNrKSB7XG4gICAgICByZXF1ZXN0RGVidWcoJ3VzaW5nIGZhbGxiYWNrJyk7XG4gICAgfVxuXG4gICAgLy8gYHJlcXVlc3RlcmAgaXMgYW55IG9mIHRoaXMuX3JlcXVlc3Qgb3IgdGhpcy5fcmVxdWVzdC5mYWxsYmFja1xuICAgIC8vIHRodXMgaXQgbmVlZHMgdG8gYmUgY2FsbGVkIHVzaW5nIHRoZSBjbGllbnQgYXMgY29udGV4dFxuICAgIHJldHVybiByZXF1ZXN0ZXIuY2FsbChjbGllbnQsIHVybCwgb3B0aW9ucykudGhlbihzdWNjZXNzLCB0cnlGYWxsYmFjayk7XG5cbiAgICBmdW5jdGlvbiBzdWNjZXNzKGh0dHBSZXNwb25zZSkge1xuICAgICAgLy8gY29tcHV0ZSB0aGUgc3RhdHVzIG9mIHRoZSByZXNwb25zZSxcbiAgICAgIC8vXG4gICAgICAvLyBXaGVuIGluIGJyb3dzZXIgbW9kZSwgdXNpbmcgWERSIG9yIEpTT05QLCB3ZSBoYXZlIG5vIHN0YXR1c0NvZGUgYXZhaWxhYmxlXG4gICAgICAvLyBTbyB3ZSByZWx5IG9uIG91ciBBUEkgcmVzcG9uc2UgYHN0YXR1c2AgcHJvcGVydHkuXG4gICAgICAvLyBCdXQgYHdhaXRUYXNrYCBjYW4gc2V0IGEgYHN0YXR1c2AgcHJvcGVydHkgd2hpY2ggaXMgbm90IHRoZSBzdGF0dXNDb2RlIChpdCdzIHRoZSB0YXNrIHN0YXR1cylcbiAgICAgIC8vIFNvIHdlIGNoZWNrIGlmIHRoZXJlJ3MgYSBgbWVzc2FnZWAgYWxvbmcgYHN0YXR1c2AgYW5kIGl0IG1lYW5zIGl0J3MgYW4gZXJyb3JcbiAgICAgIC8vXG4gICAgICAvLyBUaGF0J3MgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgcmVzcG9uc2Uuc3RhdHVzIHRoYXQncyBub3QgdGhlIGh0dHAgc3RhdHVzQ29kZVxuICAgICAgdmFyIHN0YXR1cyA9IGh0dHBSZXNwb25zZSAmJiBodHRwUmVzcG9uc2UuYm9keSAmJiBodHRwUmVzcG9uc2UuYm9keS5tZXNzYWdlICYmIGh0dHBSZXNwb25zZS5ib2R5LnN0YXR1cyB8fFxuXG4gICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IHRvIGNoZWNrIHRoZSByZXF1ZXN0IHN0YXR1c0NvZGUgQUZURVIgdGhlIGJvZHkgZXZlbnR1YWxcbiAgICAgICAgLy8gc3RhdHVzQ29kZSBiZWNhdXNlIHNvbWUgaW1wbGVtZW50YXRpb25zIChqUXVlcnkgWERvbWFpblJlcXVlc3QgdHJhbnNwb3J0KSBtYXlcbiAgICAgICAgLy8gc2VuZCBzdGF0dXNDb2RlIDIwMCB3aGlsZSB3ZSBoYWQgYW4gZXJyb3JcbiAgICAgICAgaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgfHxcblxuICAgICAgICAvLyBXaGVuIGluIGJyb3dzZXIgbW9kZSwgdXNpbmcgWERSIG9yIEpTT05QXG4gICAgICAgIC8vIHdlIGRlZmF1bHQgdG8gc3VjY2VzcyB3aGVuIG5vIGVycm9yIChubyByZXNwb25zZS5zdGF0dXMgJiYgcmVzcG9uc2UubWVzc2FnZSlcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgSlNPTi5wYXJzZSgpIGVycm9yIHRoZW4gYm9keSBpcyBudWxsIGFuZCBpdCBmYWlsc1xuICAgICAgICBodHRwUmVzcG9uc2UgJiYgaHR0cFJlc3BvbnNlLmJvZHkgJiYgMjAwO1xuXG4gICAgICByZXF1ZXN0RGVidWcoJ3JlY2VpdmVkIHJlc3BvbnNlOiBzdGF0dXNDb2RlOiAlcywgY29tcHV0ZWQgc3RhdHVzQ29kZTogJWQsIGhlYWRlcnM6ICVqJyxcbiAgICAgICAgaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsIHN0YXR1cywgaHR0cFJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgICB2YXIgaHR0cFJlc3BvbnNlT2sgPSBNYXRoLmZsb29yKHN0YXR1cyAvIDEwMCkgPT09IDI7XG5cbiAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGRlYnVnRGF0YS5wdXNoKHtcbiAgICAgICAgY3VycmVudEhvc3Q6IGN1cnJlbnRIb3N0LFxuICAgICAgICBoZWFkZXJzOiByZW1vdmVDcmVkZW50aWFscyhoZWFkZXJzKSxcbiAgICAgICAgY29udGVudDogYm9keSB8fCBudWxsLFxuICAgICAgICBjb250ZW50TGVuZ3RoOiBib2R5ICE9PSB1bmRlZmluZWQgPyBib2R5Lmxlbmd0aCA6IG51bGwsXG4gICAgICAgIG1ldGhvZDogcmVxT3B0cy5tZXRob2QsXG4gICAgICAgIHRpbWVvdXRzOiByZXFPcHRzLnRpbWVvdXRzLFxuICAgICAgICB1cmw6IHJlcU9wdHMudXJsLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogZW5kVGltZSxcbiAgICAgICAgZHVyYXRpb246IGVuZFRpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChodHRwUmVzcG9uc2VPaykge1xuICAgICAgICBpZiAoY2xpZW50Ll91c2VDYWNoZSAmJiAhY2xpZW50Ll91c2VSZXF1ZXN0Q2FjaGUgJiYgY2FjaGUpIHtcbiAgICAgICAgICBjYWNoZVtjYWNoZUlEXSA9IGh0dHBSZXNwb25zZS5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3BvbnNlVGV4dDogaHR0cFJlc3BvbnNlLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICBib2R5OiBodHRwUmVzcG9uc2UuYm9keVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvdWxkUmV0cnkgPSBNYXRoLmZsb29yKHN0YXR1cyAvIDEwMCkgIT09IDQ7XG5cbiAgICAgIGlmIChzaG91bGRSZXRyeSkge1xuICAgICAgICB0cmllcyArPSAxO1xuICAgICAgICByZXR1cm4gcmV0cnlSZXF1ZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3REZWJ1ZygndW5yZWNvdmVyYWJsZSBlcnJvcicpO1xuXG4gICAgICAvLyBubyBzdWNjZXNzIGFuZCBubyByZXRyeSA9PiBmYWlsXG4gICAgICB2YXIgdW5yZWNvdmVyYWJsZUVycm9yID0gbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoXG4gICAgICAgIGh0dHBSZXNwb25zZS5ib2R5ICYmIGh0dHBSZXNwb25zZS5ib2R5Lm1lc3NhZ2UsIHtkZWJ1Z0RhdGE6IGRlYnVnRGF0YSwgc3RhdHVzQ29kZTogc3RhdHVzfVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5yZWplY3QodW5yZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cnlGYWxsYmFjayhlcnIpIHtcbiAgICAgIC8vIGVycm9yIGNhc2VzOlxuICAgICAgLy8gIFdoaWxlIG5vdCBpbiBmYWxsYmFjayBtb2RlOlxuICAgICAgLy8gICAgLSBDT1JTIG5vdCBzdXBwb3J0ZWRcbiAgICAgIC8vICAgIC0gbmV0d29yayBlcnJvclxuICAgICAgLy8gIFdoaWxlIGluIGZhbGxiYWNrIG1vZGU6XG4gICAgICAvLyAgICAtIHRpbWVvdXRcbiAgICAgIC8vICAgIC0gbmV0d29yayBlcnJvclxuICAgICAgLy8gICAgLSBiYWRseSBmb3JtYXR0ZWQgSlNPTlAgKHNjcmlwdCBsb2FkZWQsIGRpZCBub3QgY2FsbCBvdXIgY2FsbGJhY2spXG4gICAgICAvLyAgSW4gYm90aCBjYXNlczpcbiAgICAgIC8vICAgIC0gdW5jYXVnaHQgZXhjZXB0aW9uIG9jY3VycyAoVHlwZUVycm9yKVxuICAgICAgcmVxdWVzdERlYnVnKCdlcnJvcjogJXMsIHN0YWNrOiAlcycsIGVyci5tZXNzYWdlLCBlcnIuc3RhY2spO1xuXG4gICAgICB2YXIgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBkZWJ1Z0RhdGEucHVzaCh7XG4gICAgICAgIGN1cnJlbnRIb3N0OiBjdXJyZW50SG9zdCxcbiAgICAgICAgaGVhZGVyczogcmVtb3ZlQ3JlZGVudGlhbHMoaGVhZGVycyksXG4gICAgICAgIGNvbnRlbnQ6IGJvZHkgfHwgbnVsbCxcbiAgICAgICAgY29udGVudExlbmd0aDogYm9keSAhPT0gdW5kZWZpbmVkID8gYm9keS5sZW5ndGggOiBudWxsLFxuICAgICAgICBtZXRob2Q6IHJlcU9wdHMubWV0aG9kLFxuICAgICAgICB0aW1lb3V0czogcmVxT3B0cy50aW1lb3V0cyxcbiAgICAgICAgdXJsOiByZXFPcHRzLnVybCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lXG4gICAgICB9KTtcblxuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcikpIHtcbiAgICAgICAgZXJyID0gbmV3IGVycm9ycy5Vbmtub3duKGVyciAmJiBlcnIubWVzc2FnZSwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgdHJpZXMgKz0gMTtcblxuICAgICAgLy8gc3RvcCB0aGUgcmVxdWVzdCBpbXBsZW1lbnRhdGlvbiB3aGVuOlxuICAgICAgaWYgKFxuICAgICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIHRoaXMgZXJyb3IsXG4gICAgICAgIC8vIGl0IGNvbWVzIGZyb20gYSB0aHJvdyBpbiBzb21lIG90aGVyIHBpZWNlIG9mIGNvZGVcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgZXJyb3JzLlVua25vd24gfHxcblxuICAgICAgICAvLyBzZXJ2ZXIgc2VudCB1bnBhcnNhYmxlIEpTT05cbiAgICAgICAgZXJyIGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OIHx8XG5cbiAgICAgICAgLy8gbWF4IHRyaWVzIGFuZCBhbHJlYWR5IHVzaW5nIGZhbGxiYWNrIG9yIG5vIGZhbGxiYWNrXG4gICAgICAgIHRyaWVzID49IGNsaWVudC5ob3N0c1tpbml0aWFsT3B0cy5ob3N0VHlwZV0ubGVuZ3RoICYmXG4gICAgICAgICh1c2luZ0ZhbGxiYWNrIHx8ICFoYXNGYWxsYmFjaykpIHtcbiAgICAgICAgLy8gc3RvcCByZXF1ZXN0IGltcGxlbWVudGF0aW9uIGZvciB0aGlzIGNvbW1hbmRcbiAgICAgICAgZXJyLmRlYnVnRGF0YSA9IGRlYnVnRGF0YTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBhIHRpbWVvdXQgb2NjdXJlZCwgcmV0cnkgYnkgcmFpc2luZyB0aW1lb3V0XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgZXJyb3JzLlJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICAgIHJldHVybiByZXRyeVJlcXVlc3RXaXRoSGlnaGVyVGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0cnlSZXF1ZXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0cnlSZXF1ZXN0KCkge1xuICAgICAgcmVxdWVzdERlYnVnKCdyZXRyeWluZyByZXF1ZXN0Jyk7XG4gICAgICBjbGllbnQuX2luY3JlbWVudEhvc3RJbmRleChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICByZXR1cm4gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0cnlSZXF1ZXN0V2l0aEhpZ2hlclRpbWVvdXQoKSB7XG4gICAgICByZXF1ZXN0RGVidWcoJ3JldHJ5aW5nIHJlcXVlc3Qgd2l0aCBoaWdoZXIgdGltZW91dCcpO1xuICAgICAgY2xpZW50Ll9pbmNyZW1lbnRIb3N0SW5kZXgoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgY2xpZW50Ll9pbmNyZW1lbnRUaW1lb3V0TXVsdGlwbGVyKCk7XG4gICAgICByZXFPcHRzLnRpbWVvdXRzID0gY2xpZW50Ll9nZXRUaW1lb3V0c0ZvclJlcXVlc3QoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgcmV0dXJuIGRvUmVxdWVzdChyZXF1ZXN0ZXIsIHJlcU9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2FjaGVWYWxpZFdpdGhDdXJyZW50SUQoXG4gICAgdXNlUmVxdWVzdENhY2hlLFxuICAgIGN1cnJlbnRDYWNoZSxcbiAgICBjdXJyZW50Q2FjaGVJRFxuICApIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2xpZW50Ll91c2VDYWNoZSAmJlxuICAgICAgdXNlUmVxdWVzdENhY2hlICYmXG4gICAgICBjdXJyZW50Q2FjaGUgJiZcbiAgICAgIGN1cnJlbnRDYWNoZVtjdXJyZW50Q2FjaGVJRF0gIT09IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGludGVyb3BDYWxsYmFja1JldHVybihyZXF1ZXN0LCBjYWxsYmFjaykge1xuICAgIGlmIChpc0NhY2hlVmFsaWRXaXRoQ3VycmVudElEKGNsaWVudC5fdXNlUmVxdWVzdENhY2hlLCBjYWNoZSwgY2FjaGVJRCkpIHtcbiAgICAgIHJlcXVlc3QuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIGNhY2hlIG9uIGVycm9yXG4gICAgICAgIGRlbGV0ZSBjYWNoZVtjYWNoZUlEXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbE9wdHMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGVpdGhlciB3ZSBoYXZlIGEgY2FsbGJhY2tcbiAgICAgIHJlcXVlc3QudGhlbihmdW5jdGlvbiBva0NiKGNvbnRlbnQpIHtcbiAgICAgICAgZXhpdFByb21pc2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaW5pdGlhbE9wdHMuY2FsbGJhY2sobnVsbCwgY2FsbGJhY2soY29udGVudCkpO1xuICAgICAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gICAgICB9LCBmdW5jdGlvbiBub29rQ2IoZXJyKSB7XG4gICAgICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGluaXRpYWxPcHRzLmNhbGxiYWNrKGVycik7XG4gICAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgd2UgYXJlIHVzaW5nIHByb21pc2VzXG4gICAgICByZXR1cm4gcmVxdWVzdC50aGVuKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2xpZW50Ll91c2VDYWNoZSAmJiBjbGllbnQuX3VzZVJlcXVlc3RDYWNoZSkge1xuICAgIGNhY2hlSUQgPSBpbml0aWFsT3B0cy51cmw7XG4gIH1cblxuICAvLyBhcyB3ZSBzb21ldGltZSB1c2UgUE9TVCByZXF1ZXN0cyB0byBwYXNzIHBhcmFtZXRlcnMgKGxpa2UgcXVlcnk9J2FhJyksXG4gIC8vIHRoZSBjYWNoZUlEIG11c3QgYWxzbyBpbmNsdWRlIHRoZSBib2R5IHRvIGJlIGRpZmZlcmVudCBiZXR3ZWVuIGNhbGxzXG4gIGlmIChjbGllbnQuX3VzZUNhY2hlICYmIGNsaWVudC5fdXNlUmVxdWVzdENhY2hlICYmIGJvZHkpIHtcbiAgICBjYWNoZUlEICs9ICdfYm9keV8nICsgYm9keTtcbiAgfVxuXG4gIGlmIChpc0NhY2hlVmFsaWRXaXRoQ3VycmVudElEKGNsaWVudC5fdXNlUmVxdWVzdENhY2hlLCBjYWNoZSwgY2FjaGVJRCkpIHtcbiAgICByZXF1ZXN0RGVidWcoJ3NlcnZpbmcgcmVxdWVzdCBmcm9tIGNhY2hlJyk7XG5cbiAgICB2YXIgbWF5YmVQcm9taXNlRm9yQ2FjaGUgPSBjYWNoZVtjYWNoZUlEXTtcblxuICAgIC8vIEluIGNhc2UgdGhlIGNhY2hlIGlzIHdhcm11cCB3aXRoIHZhbHVlIHRoYXQgaXMgbm90IGEgcHJvbWlzZVxuICAgIHZhciBwcm9taXNlRm9yQ2FjaGUgPSB0eXBlb2YgbWF5YmVQcm9taXNlRm9yQ2FjaGUudGhlbiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBjbGllbnQuX3Byb21pc2UucmVzb2x2ZSh7cmVzcG9uc2VUZXh0OiBtYXliZVByb21pc2VGb3JDYWNoZX0pXG4gICAgICA6IG1heWJlUHJvbWlzZUZvckNhY2hlO1xuXG4gICAgcmV0dXJuIGludGVyb3BDYWxsYmFja1JldHVybihwcm9taXNlRm9yQ2FjaGUsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgdGhlIGNhY2hlIHJlcXVlc3QsIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQucmVzcG9uc2VUZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByZXF1ZXN0ID0gZG9SZXF1ZXN0KFxuICAgIGNsaWVudC5fcmVxdWVzdCwge1xuICAgICAgdXJsOiBpbml0aWFsT3B0cy51cmwsXG4gICAgICBtZXRob2Q6IGluaXRpYWxPcHRzLm1ldGhvZCxcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICBqc29uQm9keTogaW5pdGlhbE9wdHMuYm9keSxcbiAgICAgIHRpbWVvdXRzOiBjbGllbnQuX2dldFRpbWVvdXRzRm9yUmVxdWVzdChpbml0aWFsT3B0cy5ob3N0VHlwZSksXG4gICAgICBmb3JjZUF1dGhIZWFkZXJzOiBpbml0aWFsT3B0cy5mb3JjZUF1dGhIZWFkZXJzXG4gICAgfVxuICApO1xuXG4gIGlmIChjbGllbnQuX3VzZUNhY2hlICYmIGNsaWVudC5fdXNlUmVxdWVzdENhY2hlICYmIGNhY2hlKSB7XG4gICAgY2FjaGVbY2FjaGVJRF0gPSByZXF1ZXN0O1xuICB9XG5cbiAgcmV0dXJuIGludGVyb3BDYWxsYmFja1JldHVybihyZXF1ZXN0LCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgLy8gSW4gY2FzZSBvZiB0aGUgZmlyc3QgcmVxdWVzdCwgcmV0dXJuIHRoZSBKU09OIHZhbHVlXG4gICAgcmV0dXJuIGNvbnRlbnQuYm9keTtcbiAgfSk7XG59O1xuXG4vKlxuKiBUcmFuc2Zvcm0gc2VhcmNoIHBhcmFtIG9iamVjdCBpbiBxdWVyeSBzdHJpbmdcbiogQHBhcmFtIHtvYmplY3R9IGFyZ3MgYXJndW1lbnRzIHRvIGFkZCB0byB0aGUgY3VycmVudCBxdWVyeSBzdHJpbmdcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcyBjdXJyZW50IHF1ZXJ5IHN0cmluZ1xuKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBmaW5hbCBxdWVyeSBzdHJpbmdcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uKGFyZ3MsIHBhcmFtcykge1xuICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBhcmdzKSB7XG4gICAgaWYgKGtleSAhPT0gbnVsbCAmJiBhcmdzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBhcmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHBhcmFtcyArPSBwYXJhbXMgPT09ICcnID8gJycgOiAnJic7XG4gICAgICBwYXJhbXMgKz0ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmdzW2tleV0pID09PSAnW29iamVjdCBBcnJheV0nID8gc2FmZUpTT05TdHJpbmdpZnkoYXJnc1trZXldKSA6IGFyZ3Nba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGhlYWRlcnMgZm9yIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSBbc3RyaW5nXSBvcHRpb25zLmFkZGl0aW9uYWxVQSBzZW1pLWNvbG9uIHNlcGFyYXRlZCBzdHJpbmcgd2l0aCBvdGhlciB1c2VyIGFnZW50cyB0byBhZGRcbiAqIEBwYXJhbSBbYm9vbGVhbj10cnVlXSBvcHRpb25zLndpdGhBcGlLZXkgU2VuZCB0aGUgYXBpIGtleSBhcyBhIGhlYWRlclxuICogQHBhcmFtIFtPYmplY3RdIG9wdGlvbnMuaGVhZGVycyBFeHRyYSBoZWFkZXJzIHRvIHNlbmRcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9jb21wdXRlUmVxdWVzdEhlYWRlcnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG4gIHZhciB1YSA9IG9wdGlvbnMuYWRkaXRpb25hbFVBID9cbiAgICB0aGlzLl91YSArICc7JyArIG9wdGlvbnMuYWRkaXRpb25hbFVBIDpcbiAgICB0aGlzLl91YTtcblxuICB2YXIgcmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgJ3gtYWxnb2xpYS1hZ2VudCc6IHVhLFxuICAgICd4LWFsZ29saWEtYXBwbGljYXRpb24taWQnOiB0aGlzLmFwcGxpY2F0aW9uSURcbiAgfTtcblxuICAvLyBicm93c2VyIHdpbGwgaW5saW5lIGhlYWRlcnMgaW4gdGhlIHVybCwgbm9kZS5qcyB3aWxsIHVzZSBodHRwIGhlYWRlcnNcbiAgLy8gYnV0IGluIHNvbWUgc2l0dWF0aW9ucywgdGhlIEFQSSBLRVkgd2lsbCBiZSB0b28gbG9uZyAoYmlnIHNlY3VyZWQgQVBJIGtleXMpXG4gIC8vIHNvIGlmIHRoZSByZXF1ZXN0IGlzIGEgUE9TVCBhbmQgdGhlIEtFWSBpcyB2ZXJ5IGxvbmcsIHdlIHdpbGwgYmUgYXNrZWQgdG8gbm90IHB1dFxuICAvLyBpdCBpbnRvIGhlYWRlcnMgYnV0IGluIHRoZSBKU09OIGJvZHlcbiAgaWYgKG9wdGlvbnMud2l0aEFwaUtleSAhPT0gZmFsc2UpIHtcbiAgICByZXF1ZXN0SGVhZGVyc1sneC1hbGdvbGlhLWFwaS1rZXknXSA9IHRoaXMuYXBpS2V5O1xuICB9XG5cbiAgaWYgKHRoaXMudXNlclRva2VuKSB7XG4gICAgcmVxdWVzdEhlYWRlcnNbJ3gtYWxnb2xpYS11c2VydG9rZW4nXSA9IHRoaXMudXNlclRva2VuO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VjdXJpdHlUYWdzKSB7XG4gICAgcmVxdWVzdEhlYWRlcnNbJ3gtYWxnb2xpYS10YWdmaWx0ZXJzJ10gPSB0aGlzLnNlY3VyaXR5VGFncztcbiAgfVxuXG4gIGZvckVhY2godGhpcy5leHRyYUhlYWRlcnMsIGZ1bmN0aW9uIGFkZFRvUmVxdWVzdEhlYWRlcnModmFsdWUsIGtleSkge1xuICAgIHJlcXVlc3RIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgIGZvckVhY2gob3B0aW9ucy5oZWFkZXJzLCBmdW5jdGlvbiBhZGRUb1JlcXVlc3RIZWFkZXJzKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlcXVlc3RIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXF1ZXN0SGVhZGVycztcbn07XG5cbi8qKlxuICogU2VhcmNoIHRocm91Z2ggbXVsdGlwbGUgaW5kaWNlcyBhdCB0aGUgc2FtZSB0aW1lXG4gKiBAcGFyYW0gIHtPYmplY3RbXX0gICBxdWVyaWVzICBBbiBhcnJheSBvZiBxdWVyaWVzIHlvdSB3YW50IHRvIHJ1bi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyaWVzW10uaW5kZXhOYW1lIFRoZSBpbmRleCBuYW1lIHlvdSB3YW50IHRvIHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyaWVzW10ucXVlcnldIFRoZSBxdWVyeSB0byBpc3N1ZSBvbiB0aGlzIGluZGV4LiBDYW4gYWxzbyBiZSBwYXNzZWQgaW50byBgcGFyYW1zYFxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJpZXNbXS5wYXJhbXMgQW55IHNlYXJjaCBwYXJhbSBsaWtlIGhpdHNQZXJQYWdlLCAuLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZFxuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihxdWVyaWVzLCBvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwLmpzJyk7XG5cbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBjbGllbnQuc2VhcmNoKGFycmF5T2ZRdWVyaWVzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KHF1ZXJpZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGNsaWVudCA9IHRoaXM7XG5cbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IG1hcChxdWVyaWVzLCBmdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChxdWVyeSkge1xuICAgICAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gICAgICAvLyBhbGxvdyBxdWVyeS5xdWVyeVxuICAgICAgLy8gc28gd2UgYXJlIG1pbWljaW5nIHRoZSBpbmRleC5zZWFyY2gocXVlcnksIHBhcmFtcykgbWV0aG9kXG4gICAgICAvLyB7aW5kZXhOYW1lOiwgcXVlcnk6LCBwYXJhbXM6fVxuICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zICs9ICdxdWVyeT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5LnF1ZXJ5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXhOYW1lOiBxdWVyeS5pbmRleE5hbWUsXG4gICAgICAgIHBhcmFtczogY2xpZW50Ll9nZXRTZWFyY2hQYXJhbXMocXVlcnkucGFyYW1zLCBwYXJhbXMpXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG5cbiAgdmFyIEpTT05QUGFyYW1zID0gbWFwKHBvc3RPYmoucmVxdWVzdHMsIGZ1bmN0aW9uIHByZXBhcmVKU09OUFBhcmFtcyhyZXF1ZXN0LCByZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gcmVxdWVzdElkICsgJz0nICtcbiAgICAgIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0LmluZGV4TmFtZSkgKyAnPycgK1xuICAgICAgICByZXF1ZXN0LnBhcmFtc1xuICAgICAgKTtcbiAgfSkuam9pbignJicpO1xuXG4gIHZhciB1cmwgPSAnLzEvaW5kZXhlcy8qL3F1ZXJpZXMnO1xuXG4gIGlmIChvcHRzLnN0cmF0ZWd5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwgKz0gJz9zdHJhdGVneT0nICsgb3B0cy5zdHJhdGVneTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgY2FjaGU6IHRoaXMuY2FjaGUsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiB1cmwsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGZhbGxiYWNrOiB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiAnLzEvaW5kZXhlcy8qJyxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgcGFyYW1zOiBKU09OUFBhcmFtc1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4qIFNlYXJjaCBmb3IgZmFjZXQgdmFsdWVzXG4qIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0LWFwaS9zZWFyY2gjc2VhcmNoLWZvci1mYWNldC12YWx1ZXNcbiogVGhpcyBpcyB0aGUgdG9wLWxldmVsIEFQSSBmb3IgU0ZGVi5cbipcbiogQHBhcmFtIHtvYmplY3RbXX0gcXVlcmllcyBBbiBhcnJheSBvZiBxdWVyaWVzIHRvIHJ1bi5cbiogQHBhcmFtIHtzdHJpbmd9IHF1ZXJpZXNbXS5pbmRleE5hbWUgSW5kZXggbmFtZSwgbmFtZSBvZiB0aGUgaW5kZXggdG8gc2VhcmNoLlxuKiBAcGFyYW0ge29iamVjdH0gcXVlcmllc1tdLnBhcmFtcyBRdWVyeSBwYXJhbWV0ZXJzLlxuKiBAcGFyYW0ge3N0cmluZ30gcXVlcmllc1tdLnBhcmFtcy5mYWNldE5hbWUgRmFjZXQgbmFtZSwgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNlYXJjaCBmb3IgdmFsdWVzIGluLlxuKiBNdXN0IGJlIGRlY2xhcmVkIGFzIGEgZmFjZXRcbiogQHBhcmFtIHtzdHJpbmd9IHF1ZXJpZXNbXS5wYXJhbXMuZmFjZXRRdWVyeSBRdWVyeSBmb3IgdGhlIGZhY2V0IHNlYXJjaFxuKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJpZXNbXS5wYXJhbXMuKl0gQW55IHNlYXJjaCBwYXJhbWV0ZXIgb2YgQWxnb2xpYSxcbiogc2VlIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9hcGktY2xpZW50L2phdmFzY3JpcHQvc2VhcmNoI3NlYXJjaC1wYXJhbWV0ZXJzXG4qIFBhZ2luYXRpb24gaXMgbm90IHN1cHBvcnRlZC4gVGhlIHBhZ2UgYW5kIGhpdHNQZXJQYWdlIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZWFyY2hGb3JGYWNldFZhbHVlcyA9IGZ1bmN0aW9uKHF1ZXJpZXMpIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LnNlYXJjaEZvckZhY2V0VmFsdWVzKFt7aW5kZXhOYW1lLCBwYXJhbXM6IHtmYWNldE5hbWUsIGZhY2V0UXVlcnksIC4uLnBhcmFtc319LCAuLi5xdWVyaWVzXSknOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cblxuICBpZiAoIWlzQXJyYXkocXVlcmllcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGNsaWVudCA9IHRoaXM7XG5cbiAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5hbGwobWFwKHF1ZXJpZXMsIGZ1bmN0aW9uIHBlcmZvcm1RdWVyeShxdWVyeSkge1xuICAgIGlmIChcbiAgICAgICFxdWVyeSB8fFxuICAgICAgcXVlcnkuaW5kZXhOYW1lID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHF1ZXJ5LnBhcmFtcy5mYWNldE5hbWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgcXVlcnkucGFyYW1zLmZhY2V0UXVlcnkgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgICB9XG5cbiAgICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG4gICAgdmFyIG9taXQgPSByZXF1aXJlKCcuL29taXQuanMnKTtcblxuICAgIHZhciBpbmRleE5hbWUgPSBxdWVyeS5pbmRleE5hbWU7XG4gICAgdmFyIHBhcmFtcyA9IHF1ZXJ5LnBhcmFtcztcblxuICAgIHZhciBmYWNldE5hbWUgPSBwYXJhbXMuZmFjZXROYW1lO1xuICAgIHZhciBmaWx0ZXJlZFBhcmFtcyA9IG9taXQoY2xvbmUocGFyYW1zKSwgZnVuY3Rpb24oa2V5TmFtZSkge1xuICAgICAgcmV0dXJuIGtleU5hbWUgPT09ICdmYWNldE5hbWUnO1xuICAgIH0pO1xuICAgIHZhciBzZWFyY2hQYXJhbWV0ZXJzID0gY2xpZW50Ll9nZXRTZWFyY2hQYXJhbXMoZmlsdGVyZWRQYXJhbXMsICcnKTtcblxuICAgIHJldHVybiBjbGllbnQuX2pzb25SZXF1ZXN0KHtcbiAgICAgIGNhY2hlOiBjbGllbnQuY2FjaGUsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDpcbiAgICAgICAgJy8xL2luZGV4ZXMvJyArXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE5hbWUpICtcbiAgICAgICAgJy9mYWNldHMvJyArXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChmYWNldE5hbWUpICtcbiAgICAgICAgJy9xdWVyeScsXG4gICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgYm9keToge3BhcmFtczogc2VhcmNoUGFyYW1ldGVyc31cbiAgICB9KTtcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGV4dHJhIHNlY3VyaXR5IHRhZ0ZpbHRlcnMgaGVhZGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdGFncyBUaGUgbGlzdCBvZiB0YWdzIGRlZmluaW5nIHRoZSBjdXJyZW50IHNlY3VyaXR5IGZpbHRlcnNcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldFNlY3VyaXR5VGFncyA9IGZ1bmN0aW9uKHRhZ3MpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YWdzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHZhciBzdHJUYWdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhZ3NbaV0pID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHZhciBvcmVkVGFncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRhZ3NbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBvcmVkVGFncy5wdXNoKHRhZ3NbaV1bal0pO1xuICAgICAgICB9XG4gICAgICAgIHN0clRhZ3MucHVzaCgnKCcgKyBvcmVkVGFncy5qb2luKCcsJykgKyAnKScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyVGFncy5wdXNoKHRhZ3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0YWdzID0gc3RyVGFncy5qb2luKCcsJyk7XG4gIH1cblxuICB0aGlzLnNlY3VyaXR5VGFncyA9IHRhZ3M7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZXh0cmEgdXNlciB0b2tlbiBoZWFkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyVG9rZW4gVGhlIHRva2VuIGlkZW50aWZ5aW5nIGEgdW5pcSB1c2VyICh1c2VkIHRvIGFwcGx5IHJhdGUgbGltaXRzKVxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0VXNlclRva2VuID0gZnVuY3Rpb24odXNlclRva2VuKSB7XG4gIHRoaXMudXNlclRva2VuID0gdXNlclRva2VuO1xufTtcblxuLyoqXG4gKiBDbGVhciBhbGwgcXVlcmllcyBpbiBjbGllbnQncyBjYWNoZVxuICogQHJldHVybiB1bmRlZmluZWRcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYWNoZSA9IHt9O1xufTtcblxuLyoqXG4qIFNldCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhIHJlcXVlc3QgY2FuIHRha2UgYmVmb3JlIGF1dG9tYXRpY2FsbHkgYmVpbmcgdGVybWluYXRlZC5cbiogQGRlcHJlY2F0ZWRcbiogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRSZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uKG1pbGxpc2Vjb25kcykge1xuICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgdGhpcy5fdGltZW91dHMuY29ubmVjdCA9IHRoaXMuX3RpbWVvdXRzLnJlYWQgPSB0aGlzLl90aW1lb3V0cy53cml0ZSA9IG1pbGxpc2Vjb25kcztcbiAgfVxufTtcblxuLyoqXG4qIFNldCB0aGUgdGhyZWUgZGlmZmVyZW50IChjb25uZWN0LCByZWFkLCB3cml0ZSkgdGltZW91dHMgdG8gYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmdcbiogQHBhcmFtIHtPYmplY3R9IHRpbWVvdXRzXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldFRpbWVvdXRzID0gZnVuY3Rpb24odGltZW91dHMpIHtcbiAgdGhpcy5fdGltZW91dHMgPSB0aW1lb3V0cztcbn07XG5cbi8qKlxuKiBHZXQgdGhlIHRocmVlIGRpZmZlcmVudCAoY29ubmVjdCwgcmVhZCwgd3JpdGUpIHRpbWVvdXRzIHRvIGJlIHVzZWQgd2hlbiByZXF1ZXN0aW5nXG4qIEBwYXJhbSB7T2JqZWN0fSB0aW1lb3V0c1xuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5nZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGltZW91dHM7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldEFwcElkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IHN0b3JlLmdldCh0aGlzLmFwcGxpY2F0aW9uSUQpO1xuICBpZiAoZGF0YSAhPT0gbnVsbCkgdGhpcy5fY2FjaGVBcHBJZERhdGEoZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9zZXRBcHBJZERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRhdGEubGFzdENoYW5nZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHRoaXMuX2NhY2hlQXBwSWREYXRhKGRhdGEpO1xuICByZXR1cm4gc3RvcmUuc2V0KHRoaXMuYXBwbGljYXRpb25JRCwgZGF0YSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2NoZWNrQXBwSWREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZ2V0QXBwSWREYXRhKCk7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBub3cgLSBkYXRhLmxhc3RDaGFuZ2UgPiBSRVNFVF9BUFBfREFUQV9USU1FUikge1xuICAgIHJldHVybiB0aGlzLl9yZXNldEluaXRpYWxBcHBJZERhdGEoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fcmVzZXRJbml0aWFsQXBwSWREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbmV3RGF0YSA9IGRhdGEgfHwge307XG4gIG5ld0RhdGEuaG9zdEluZGV4ZXMgPSB7cmVhZDogMCwgd3JpdGU6IDB9O1xuICBuZXdEYXRhLnRpbWVvdXRNdWx0aXBsaWVyID0gMTtcbiAgbmV3RGF0YS5zaHVmZmxlUmVzdWx0ID0gbmV3RGF0YS5zaHVmZmxlUmVzdWx0IHx8IHNodWZmbGUoWzEsIDIsIDNdKTtcbiAgcmV0dXJuIHRoaXMuX3NldEFwcElkRGF0YShuZXdEYXRhKTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fY2FjaGVBcHBJZERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX2hvc3RJbmRleGVzID0gZGF0YS5ob3N0SW5kZXhlcztcbiAgdGhpcy5fdGltZW91dE11bHRpcGxpZXIgPSBkYXRhLnRpbWVvdXRNdWx0aXBsaWVyO1xuICB0aGlzLl9zaHVmZmxlUmVzdWx0ID0gZGF0YS5zaHVmZmxlUmVzdWx0O1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlID0gZnVuY3Rpb24obmV3RGF0YSkge1xuICB2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbiAgdmFyIGN1cnJlbnREYXRhID0gdGhpcy5fZ2V0QXBwSWREYXRhKCk7XG4gIGZvcmVhY2gobmV3RGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGN1cnJlbnREYXRhW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMuX3NldEFwcElkRGF0YShjdXJyZW50RGF0YSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldEhvc3RCeVR5cGUgPSBmdW5jdGlvbihob3N0VHlwZSkge1xuICByZXR1cm4gdGhpcy5ob3N0c1tob3N0VHlwZV1bdGhpcy5fZ2V0SG9zdEluZGV4QnlUeXBlKGhvc3RUeXBlKV07XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldFRpbWVvdXRNdWx0aXBsaWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aW1lb3V0TXVsdGlwbGllcjtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0SG9zdEluZGV4QnlUeXBlID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuX2hvc3RJbmRleGVzW2hvc3RUeXBlXTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fc2V0SG9zdEluZGV4QnlUeXBlID0gZnVuY3Rpb24oaG9zdEluZGV4LCBob3N0VHlwZSkge1xuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJyk7XG4gIHZhciBuZXdIb3N0SW5kZXhlcyA9IGNsb25lKHRoaXMuX2hvc3RJbmRleGVzKTtcbiAgbmV3SG9zdEluZGV4ZXNbaG9zdFR5cGVdID0gaG9zdEluZGV4O1xuICB0aGlzLl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlKHtob3N0SW5kZXhlczogbmV3SG9zdEluZGV4ZXN9KTtcbiAgcmV0dXJuIGhvc3RJbmRleDtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5faW5jcmVtZW50SG9zdEluZGV4ID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuX3NldEhvc3RJbmRleEJ5VHlwZShcbiAgICAodGhpcy5fZ2V0SG9zdEluZGV4QnlUeXBlKGhvc3RUeXBlKSArIDEpICUgdGhpcy5ob3N0c1tob3N0VHlwZV0ubGVuZ3RoLCBob3N0VHlwZVxuICApO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9pbmNyZW1lbnRUaW1lb3V0TXVsdGlwbGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aW1lb3V0TXVsdGlwbGllciA9IE1hdGgubWF4KHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyICsgMSwgNCk7XG4gIHJldHVybiB0aGlzLl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlKHt0aW1lb3V0TXVsdGlwbGllcjogdGltZW91dE11bHRpcGxpZXJ9KTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0VGltZW91dHNGb3JSZXF1ZXN0ID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0OiB0aGlzLl90aW1lb3V0cy5jb25uZWN0ICogdGhpcy5fdGltZW91dE11bHRpcGxpZXIsXG4gICAgY29tcGxldGU6IHRoaXMuX3RpbWVvdXRzW2hvc3RUeXBlXSAqIHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyXG4gIH07XG59O1xuXG5mdW5jdGlvbiBwcmVwYXJlSG9zdChwcm90b2NvbCkge1xuICByZXR1cm4gZnVuY3Rpb24gcHJlcGFyZShob3N0KSB7XG4gICAgcmV0dXJuIHByb3RvY29sICsgJy8vJyArIGhvc3QudG9Mb3dlckNhc2UoKTtcbiAgfTtcbn1cblxuLy8gUHJvdG90eXBlLmpzIDwgMS43LCBhIHdpZGVseSB1c2VkIGxpYnJhcnksIGRlZmluZXMgYSB3ZWlyZFxuLy8gQXJyYXkucHJvdG90eXBlLnRvSlNPTiBmdW5jdGlvbiB0aGF0IHdpbGwgZmFpbCB0byBzdHJpbmdpZnkgb3VyIGNvbnRlbnRcbi8vIGFwcHJvcHJpYXRlbHlcbi8vIHJlZnM6XG4vLyAgIC0gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIXRvcGljL3Byb3RvdHlwZS1jb3JlL0UtU0FWdlZfVjlRXG4vLyAgIC0gaHR0cHM6Ly9naXRodWIuY29tL3NzdGVwaGVuc29uL3Byb3RvdHlwZS9jb21taXQvMDM4YTI5ODVhNzA1OTNjMWE4NmMyMzBmYWRiZGZlMmU0ODk4YTQ4Y1xuLy8gICAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDg0NDEvMTQ3MDc5XG5mdW5jdGlvbiBzYWZlSlNPTlN0cmluZ2lmeShvYmopIHtcbiAgLyogZXNsaW50IG5vLWV4dGVuZC1uYXRpdmU6MCAqL1xuXG4gIGlmIChBcnJheS5wcm90b3R5cGUudG9KU09OID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgfVxuXG4gIHZhciB0b0pTT04gPSBBcnJheS5wcm90b3R5cGUudG9KU09OO1xuICBkZWxldGUgQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbiAgdmFyIG91dCA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIEFycmF5LnByb3RvdHlwZS50b0pTT04gPSB0b0pTT047XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICB2YXIgY3VycmVudEluZGV4ID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgdGVtcG9yYXJ5VmFsdWU7XG4gIHZhciByYW5kb21JbmRleDtcblxuICAvLyBXaGlsZSB0aGVyZSByZW1haW4gZWxlbWVudHMgdG8gc2h1ZmZsZS4uLlxuICB3aGlsZSAoY3VycmVudEluZGV4ICE9PSAwKSB7XG4gICAgLy8gUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li4uXG4gICAgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xuICAgIGN1cnJlbnRJbmRleCAtPSAxO1xuXG4gICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgIHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcbiAgICBhcnJheVtjdXJyZW50SW5kZXhdID0gYXJyYXlbcmFuZG9tSW5kZXhdO1xuICAgIGFycmF5W3JhbmRvbUluZGV4XSA9IHRlbXBvcmFyeVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDcmVkZW50aWFscyhoZWFkZXJzKSB7XG4gIHZhciBuZXdIZWFkZXJzID0ge307XG5cbiAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCBoZWFkZXJOYW1lKSkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZiAoaGVhZGVyTmFtZSA9PT0gJ3gtYWxnb2xpYS1hcGkta2V5JyB8fCBoZWFkZXJOYW1lID09PSAneC1hbGdvbGlhLWFwcGxpY2F0aW9uLWlkJykge1xuICAgICAgICB2YWx1ZSA9ICcqKmhpZGRlbiBmb3Igc2VjdXJpdHkgcHVycG9zZXMqKic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICB9XG5cbiAgICAgIG5ld0hlYWRlcnNbaGVhZGVyTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3SGVhZGVycztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9BbGdvbGlhU2VhcmNoQ29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBidWlsZFNlYXJjaE1ldGhvZCA9IHJlcXVpcmUoJy4vYnVpbGRTZWFyY2hNZXRob2QuanMnKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZS5qcycpO1xudmFyIGRlcHJlY2F0ZWRNZXNzYWdlID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkTWVzc2FnZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4Q29yZTtcblxuLypcbiogSW5kZXggY2xhc3MgY29uc3RydWN0b3IuXG4qIFlvdSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseSBidXQgdXNlIGluaXRJbmRleCgpIGZ1bmN0aW9uXG4qL1xuZnVuY3Rpb24gSW5kZXhDb3JlKGFsZ29saWFzZWFyY2gsIGluZGV4TmFtZSkge1xuICB0aGlzLmluZGV4TmFtZSA9IGluZGV4TmFtZTtcbiAgdGhpcy5hcyA9IGFsZ29saWFzZWFyY2g7XG4gIHRoaXMudHlwZUFoZWFkQXJncyA9IG51bGw7XG4gIHRoaXMudHlwZUFoZWFkVmFsdWVPcHRpb24gPSBudWxsO1xuXG4gIC8vIG1ha2Ugc3VyZSBldmVyeSBpbmRleCBpbnN0YW5jZSBoYXMgaXQncyBvd24gY2FjaGVcbiAgdGhpcy5jYWNoZSA9IHt9O1xufVxuXG4vKlxuKiBDbGVhciBhbGwgcXVlcmllcyBpbiBjYWNoZVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNhY2hlID0ge307XG59O1xuXG4vKlxuKiBTZWFyY2ggaW5zaWRlIHRoZSBpbmRleCB1c2luZyBYTUxIdHRwUmVxdWVzdCByZXF1ZXN0IChVc2luZyBhIFBPU1QgcXVlcnkgdG9cbiogbWluaW1pemUgbnVtYmVyIG9mIE9QVElPTlMgcXVlcmllczogQ3Jvc3MtT3JpZ2luIFJlc291cmNlIFNoYXJpbmcpLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5XSB0aGUgZnVsbCB0ZXh0IHF1ZXJ5XG4qIEBwYXJhbSB7b2JqZWN0fSBbYXJnc10gKG9wdGlvbmFsKSBpZiBzZXQsIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnM6XG4qIC0gcGFnZTogKGludGVnZXIpIFBhZ2luYXRpb24gcGFyYW1ldGVyIHVzZWQgdG8gc2VsZWN0IHRoZSBwYWdlIHRvIHJldHJpZXZlLlxuKiAgICAgICAgICAgICAgICAgICBQYWdlIGlzIHplcm8tYmFzZWQgYW5kIGRlZmF1bHRzIHRvIDAuIFRodXMsXG4qICAgICAgICAgICAgICAgICAgIHRvIHJldHJpZXZlIHRoZSAxMHRoIHBhZ2UgeW91IG5lZWQgdG8gc2V0IHBhZ2U9OVxuKiAtIGhpdHNQZXJQYWdlOiAoaW50ZWdlcikgUGFnaW5hdGlvbiBwYXJhbWV0ZXIgdXNlZCB0byBzZWxlY3QgdGhlIG51bWJlciBvZiBoaXRzIHBlciBwYWdlLiBEZWZhdWx0cyB0byAyMC5cbiogLSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZTogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBvYmplY3QgYXR0cmlidXRlc1xuKiB5b3Ugd2FudCB0byByZXRyaWV2ZSAobGV0IHlvdSBtaW5pbWl6ZSB0aGUgYW5zd2VyIHNpemUpLlxuKiAgIEF0dHJpYnV0ZXMgYXJlIHNlcGFyYXRlZCB3aXRoIGEgY29tbWEgKGZvciBleGFtcGxlIFwibmFtZSxhZGRyZXNzXCIpLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKGZvciBleGFtcGxlIFtcIm5hbWVcIixcImFkZHJlc3NcIl0pLlxuKiAgIEJ5IGRlZmF1bHQsIGFsbCBhdHRyaWJ1dGVzIGFyZSByZXRyaWV2ZWQuIFlvdSBjYW4gYWxzbyB1c2UgJyonIHRvIHJldHJpZXZlIGFsbFxuKiAgIHZhbHVlcyB3aGVuIGFuIGF0dHJpYnV0ZXNUb1JldHJpZXZlIHNldHRpbmcgaXMgc3BlY2lmaWVkIGZvciB5b3VyIGluZGV4LlxuKiAtIGF0dHJpYnV0ZXNUb0hpZ2hsaWdodDogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBhdHRyaWJ1dGVzIHlvdVxuKiAgIHdhbnQgdG8gaGlnaGxpZ2h0IGFjY29yZGluZyB0byB0aGUgcXVlcnkuXG4qICAgQXR0cmlidXRlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEuIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKGZvciBleGFtcGxlIFtcIm5hbWVcIixcImFkZHJlc3NcIl0pLlxuKiAgIElmIGFuIGF0dHJpYnV0ZSBoYXMgbm8gbWF0Y2ggZm9yIHRoZSBxdWVyeSwgdGhlIHJhdyB2YWx1ZSBpcyByZXR1cm5lZC5cbiogICBCeSBkZWZhdWx0IGFsbCBpbmRleGVkIHRleHQgYXR0cmlidXRlcyBhcmUgaGlnaGxpZ2h0ZWQuXG4qICAgWW91IGNhbiB1c2UgYCpgIGlmIHlvdSB3YW50IHRvIGhpZ2hsaWdodCBhbGwgdGV4dHVhbCBhdHRyaWJ1dGVzLlxuKiAgIE51bWVyaWNhbCBhdHRyaWJ1dGVzIGFyZSBub3QgaGlnaGxpZ2h0ZWQuXG4qICAgQSBtYXRjaExldmVsIGlzIHJldHVybmVkIGZvciBlYWNoIGhpZ2hsaWdodGVkIGF0dHJpYnV0ZSBhbmQgY2FuIGNvbnRhaW46XG4qICAgICAgLSBmdWxsOiBpZiBhbGwgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQgaW4gdGhlIGF0dHJpYnV0ZSxcbiogICAgICAtIHBhcnRpYWw6IGlmIG9ubHkgc29tZSBvZiB0aGUgcXVlcnkgdGVybXMgd2VyZSBmb3VuZCxcbiogICAgICAtIG5vbmU6IGlmIG5vbmUgb2YgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQuXG4qIC0gYXR0cmlidXRlc1RvU25pcHBldDogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIHNuaXBwZXQgYWxvbmdzaWRlXG4qIHRoZSBudW1iZXIgb2Ygd29yZHMgdG8gcmV0dXJuIChzeW50YXggaXMgYGF0dHJpYnV0ZU5hbWU6bmJXb3Jkc2ApLlxuKiAgICBBdHRyaWJ1dGVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBjb21tYSAoRXhhbXBsZTogYXR0cmlidXRlc1RvU25pcHBldD1uYW1lOjEwLGNvbnRlbnQ6MTApLlxuKiAgICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChFeGFtcGxlOiBhdHRyaWJ1dGVzVG9TbmlwcGV0OiBbJ25hbWU6MTAnLCdjb250ZW50OjEwJ10pLlxuKiAgICBCeSBkZWZhdWx0IG5vIHNuaXBwZXQgaXMgY29tcHV0ZWQuXG4qIC0gbWluV29yZFNpemVmb3IxVHlwbzogdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gYSBxdWVyeSB3b3JkIHRvIGFjY2VwdCBvbmUgdHlwbyBpbiB0aGlzIHdvcmQuXG4qIERlZmF1bHRzIHRvIDMuXG4qIC0gbWluV29yZFNpemVmb3IyVHlwb3M6IHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIGEgcXVlcnkgd29yZFxuKiB0byBhY2NlcHQgdHdvIHR5cG9zIGluIHRoaXMgd29yZC4gRGVmYXVsdHMgdG8gNy5cbiogLSBnZXRSYW5raW5nSW5mbzogaWYgc2V0IHRvIDEsIHRoZSByZXN1bHQgaGl0cyB3aWxsIGNvbnRhaW4gcmFua2luZ1xuKiBpbmZvcm1hdGlvbiBpbiBfcmFua2luZ0luZm8gYXR0cmlidXRlLlxuKiAtIGFyb3VuZExhdExuZzogc2VhcmNoIGZvciBlbnRyaWVzIGFyb3VuZCBhIGdpdmVuXG4qIGxhdGl0dWRlL2xvbmdpdHVkZSAoc3BlY2lmaWVkIGFzIHR3byBmbG9hdHMgc2VwYXJhdGVkIGJ5IGEgY29tbWEpLlxuKiAgIEZvciBleGFtcGxlIGFyb3VuZExhdExuZz00Ny4zMTY2NjksNS4wMTY2NzApLlxuKiAgIFlvdSBjYW4gc3BlY2lmeSB0aGUgbWF4aW11bSBkaXN0YW5jZSBpbiBtZXRlcnMgd2l0aCB0aGUgYXJvdW5kUmFkaXVzIHBhcmFtZXRlciAoaW4gbWV0ZXJzKVxuKiAgIGFuZCB0aGUgcHJlY2lzaW9uIGZvciByYW5raW5nIHdpdGggYXJvdW5kUHJlY2lzaW9uXG4qICAgKGZvciBleGFtcGxlIGlmIHlvdSBzZXQgYXJvdW5kUHJlY2lzaW9uPTEwMCwgdHdvIG9iamVjdHMgdGhhdCBhcmUgZGlzdGFudCBvZlxuKiAgIGxlc3MgdGhhbiAxMDBtIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBpZGVudGljYWwgZm9yIFwiZ2VvXCIgcmFua2luZyBwYXJhbWV0ZXIpLlxuKiAgIEF0IGluZGV4aW5nLCB5b3Ugc2hvdWxkIHNwZWNpZnkgZ2VvbG9jIG9mIGFuIG9iamVjdCB3aXRoIHRoZSBfZ2VvbG9jIGF0dHJpYnV0ZVxuKiAgIChpbiB0aGUgZm9ybSB7XCJfZ2VvbG9jXCI6e1wibGF0XCI6NDguODUzNDA5LCBcImxuZ1wiOjIuMzQ4ODAwfX0pXG4qIC0gaW5zaWRlQm91bmRpbmdCb3g6IHNlYXJjaCBlbnRyaWVzIGluc2lkZSBhIGdpdmVuIGFyZWEgZGVmaW5lZCBieSB0aGUgdHdvIGV4dHJlbWUgcG9pbnRzXG4qIG9mIGEgcmVjdGFuZ2xlIChkZWZpbmVkIGJ5IDQgZmxvYXRzOiBwMUxhdCxwMUxuZyxwMkxhdCxwMkxuZykuXG4qICAgRm9yIGV4YW1wbGUgaW5zaWRlQm91bmRpbmdCb3g9NDcuMzE2NSw0Ljk2NjUsNDcuMzQyNCw1LjAyMDEpLlxuKiAgIEF0IGluZGV4aW5nLCB5b3Ugc2hvdWxkIHNwZWNpZnkgZ2VvbG9jIG9mIGFuIG9iamVjdCB3aXRoIHRoZSBfZ2VvbG9jIGF0dHJpYnV0ZVxuKiAgIChpbiB0aGUgZm9ybSB7XCJfZ2VvbG9jXCI6e1wibGF0XCI6NDguODUzNDA5LCBcImxuZ1wiOjIuMzQ4ODAwfX0pXG4qIC0gbnVtZXJpY0ZpbHRlcnM6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgbnVtZXJpYyBmaWx0ZXJzIHlvdSB3YW50IHRvXG4qIGFwcGx5IHNlcGFyYXRlZCBieSBhIGNvbW1hLlxuKiAgIFRoZSBzeW50YXggb2Ygb25lIGZpbHRlciBpcyBgYXR0cmlidXRlTmFtZWAgZm9sbG93ZWQgYnkgYG9wZXJhbmRgIGZvbGxvd2VkIGJ5IGB2YWx1ZWAuXG4qICAgU3VwcG9ydGVkIG9wZXJhbmRzIGFyZSBgPGAsIGA8PWAsIGA9YCwgYD5gIGFuZCBgPj1gLlxuKiAgIFlvdSBjYW4gaGF2ZSBtdWx0aXBsZSBjb25kaXRpb25zIG9uIG9uZSBhdHRyaWJ1dGUgbGlrZSBmb3IgZXhhbXBsZSBudW1lcmljRmlsdGVycz1wcmljZT4xMDAscHJpY2U8MTAwMC5cbiogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBudW1lcmljRmlsdGVyczogW1wicHJpY2U+MTAwXCIsXCJwcmljZTwxMDAwXCJdKS5cbiogLSB0YWdGaWx0ZXJzOiBmaWx0ZXIgdGhlIHF1ZXJ5IGJ5IGEgc2V0IG9mIHRhZ3MuIFlvdSBjYW4gQU5EIHRhZ3MgYnkgc2VwYXJhdGluZyB0aGVtIGJ5IGNvbW1hcy5cbiogICBUbyBPUiB0YWdzLCB5b3UgbXVzdCBhZGQgcGFyZW50aGVzZXMuIEZvciBleGFtcGxlLCB0YWdzPXRhZzEsKHRhZzIsdGFnMykgbWVhbnMgdGFnMSBBTkQgKHRhZzIgT1IgdGFnMykuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSwgZm9yIGV4YW1wbGUgdGFnRmlsdGVyczogW1widGFnMVwiLFtcInRhZzJcIixcInRhZzNcIl1dXG4qICAgbWVhbnMgdGFnMSBBTkQgKHRhZzIgT1IgdGFnMykuXG4qICAgQXQgaW5kZXhpbmcsIHRhZ3Mgc2hvdWxkIGJlIGFkZGVkIGluIHRoZSBfdGFncyoqIGF0dHJpYnV0ZVxuKiAgIG9mIG9iamVjdHMgKGZvciBleGFtcGxlIHtcIl90YWdzXCI6W1widGFnMVwiLFwidGFnMlwiXX0pLlxuKiAtIGZhY2V0RmlsdGVyczogZmlsdGVyIHRoZSBxdWVyeSBieSBhIGxpc3Qgb2YgZmFjZXRzLlxuKiAgIEZhY2V0cyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcyBhbmQgZWFjaCBmYWNldCBpcyBlbmNvZGVkIGFzIGBhdHRyaWJ1dGVOYW1lOnZhbHVlYC5cbiogICBGb3IgZXhhbXBsZTogYGZhY2V0RmlsdGVycz1jYXRlZ29yeTpCb29rLGF1dGhvcjpKb2huJTIwRG9lYC5cbiogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBgW1wiY2F0ZWdvcnk6Qm9va1wiLFwiYXV0aG9yOkpvaG4lMjBEb2VcIl1gKS5cbiogLSBmYWNldHM6IExpc3Qgb2Ygb2JqZWN0IGF0dHJpYnV0ZXMgdGhhdCB5b3Ugd2FudCB0byB1c2UgZm9yIGZhY2V0aW5nLlxuKiAgIENvbW1hIHNlcGFyYXRlZCBsaXN0OiBgXCJjYXRlZ29yeSxhdXRob3JcImAgb3IgYXJyYXkgYFsnY2F0ZWdvcnknLCdhdXRob3InXWBcbiogICBPbmx5IGF0dHJpYnV0ZXMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgaW4gKiphdHRyaWJ1dGVzRm9yRmFjZXRpbmcqKiBpbmRleCBzZXR0aW5nXG4qICAgY2FuIGJlIHVzZWQgaW4gdGhpcyBwYXJhbWV0ZXIuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBgKmAgdG8gcGVyZm9ybSBmYWNldGluZyBvbiBhbGwgYXR0cmlidXRlcyBzcGVjaWZpZWQgaW4gKiphdHRyaWJ1dGVzRm9yRmFjZXRpbmcqKi5cbiogLSBxdWVyeVR5cGU6IHNlbGVjdCBob3cgdGhlIHF1ZXJ5IHdvcmRzIGFyZSBpbnRlcnByZXRlZCwgaXQgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlOlxuKiAgICAtIHByZWZpeEFsbDogYWxsIHF1ZXJ5IHdvcmRzIGFyZSBpbnRlcnByZXRlZCBhcyBwcmVmaXhlcyxcbiogICAgLSBwcmVmaXhMYXN0OiBvbmx5IHRoZSBsYXN0IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXggKGRlZmF1bHQgYmVoYXZpb3IpLFxuKiAgICAtIHByZWZpeE5vbmU6IG5vIHF1ZXJ5IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXguIFRoaXMgb3B0aW9uIGlzIG5vdCByZWNvbW1lbmRlZC5cbiogLSBvcHRpb25hbFdvcmRzOiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIHdvcmRzIHRoYXQgc2hvdWxkXG4qIGJlIGNvbnNpZGVyZWQgYXMgb3B0aW9uYWwgd2hlbiBmb3VuZCBpbiB0aGUgcXVlcnkuXG4qICAgQ29tbWEgc2VwYXJhdGVkIGFuZCBhcnJheSBhcmUgYWNjZXB0ZWQuXG4qIC0gZGlzdGluY3Q6IElmIHNldCB0byAxLCBlbmFibGUgdGhlIGRpc3RpbmN0IGZlYXR1cmUgKGRpc2FibGVkIGJ5IGRlZmF1bHQpXG4qIGlmIHRoZSBhdHRyaWJ1dGVGb3JEaXN0aW5jdCBpbmRleCBzZXR0aW5nIGlzIHNldC5cbiogICBUaGlzIGZlYXR1cmUgaXMgc2ltaWxhciB0byB0aGUgU1FMIFwiZGlzdGluY3RcIiBrZXl3b3JkOiB3aGVuIGVuYWJsZWRcbiogICBpbiBhIHF1ZXJ5IHdpdGggdGhlIGRpc3RpbmN0PTEgcGFyYW1ldGVyLFxuKiAgIGFsbCBoaXRzIGNvbnRhaW5pbmcgYSBkdXBsaWNhdGUgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGVGb3JEaXN0aW5jdCBhdHRyaWJ1dGUgYXJlIHJlbW92ZWQgZnJvbSByZXN1bHRzLlxuKiAgIEZvciBleGFtcGxlLCBpZiB0aGUgY2hvc2VuIGF0dHJpYnV0ZSBpcyBzaG93X25hbWUgYW5kIHNldmVyYWwgaGl0cyBoYXZlXG4qICAgdGhlIHNhbWUgdmFsdWUgZm9yIHNob3dfbmFtZSwgdGhlbiBvbmx5IHRoZSBiZXN0XG4qICAgb25lIGlzIGtlcHQgYW5kIG90aGVycyBhcmUgcmVtb3ZlZC5cbiogLSByZXN0cmljdFNlYXJjaGFibGVBdHRyaWJ1dGVzOiBMaXN0IG9mIGF0dHJpYnV0ZXMgeW91IHdhbnQgdG8gdXNlIGZvclxuKiB0ZXh0dWFsIHNlYXJjaCAobXVzdCBiZSBhIHN1YnNldCBvZiB0aGUgYXR0cmlidXRlc1RvSW5kZXggaW5kZXggc2V0dGluZylcbiogZWl0aGVyIGNvbW1hIHNlcGFyYXRlZCBvciBhcyBhbiBhcnJheVxuKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJykuIElmIGZhbHNlLCB0aGUgY29udGVudCBjb250YWlucyB0aGUgZXJyb3IuXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIHJlc3VsdHMuXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5zZWFyY2ggPSBidWlsZFNlYXJjaE1ldGhvZCgncXVlcnknKTtcblxuLypcbiogLS0gQkVUQSAtLVxuKiBTZWFyY2ggYSByZWNvcmQgc2ltaWxhciB0byB0aGUgcXVlcnkgaW5zaWRlIHRoZSBpbmRleCB1c2luZyBYTUxIdHRwUmVxdWVzdCByZXF1ZXN0IChVc2luZyBhIFBPU1QgcXVlcnkgdG9cbiogbWluaW1pemUgbnVtYmVyIG9mIE9QVElPTlMgcXVlcmllczogQ3Jvc3MtT3JpZ2luIFJlc291cmNlIFNoYXJpbmcpLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5XSB0aGUgc2ltaWxhciBxdWVyeVxuKiBAcGFyYW0ge29iamVjdH0gW2FyZ3NdIChvcHRpb25hbCkgaWYgc2V0LCBjb250YWlucyBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLlxuKiAgIEFsbCBzZWFyY2ggcGFyYW1ldGVycyBhcmUgc3VwcG9ydGVkIChzZWUgc2VhcmNoIGZ1bmN0aW9uKSwgcmVzdHJpY3RTZWFyY2hhYmxlQXR0cmlidXRlcyBhbmQgZmFjZXRGaWx0ZXJzXG4qICAgYXJlIHRoZSB0d28gbW9zdCB1c2VmdWwgdG8gcmVzdHJpY3QgdGhlIHNpbWlsYXIgcmVzdWx0cyBhbmQgZ2V0IG1vcmUgcmVsZXZhbnQgY29udGVudFxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuc2ltaWxhclNlYXJjaCA9IGJ1aWxkU2VhcmNoTWV0aG9kKCdzaW1pbGFyUXVlcnknKTtcblxuLypcbiogQnJvd3NlIGluZGV4IGNvbnRlbnQuIFRoZSByZXNwb25zZSBjb250ZW50IHdpbGwgaGF2ZSBhIGBjdXJzb3JgIHByb3BlcnR5IHRoYXQgeW91IGNhbiB1c2VcbiogdG8gYnJvd3NlIHN1YnNlcXVlbnQgcGFnZXMgZm9yIHRoaXMgcXVlcnkuIFVzZSBgaW5kZXguYnJvd3NlRnJvbShjdXJzb3IpYCB3aGVuIHlvdSB3YW50LlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgZnVsbCB0ZXh0IHF1ZXJ5XG4qIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbWV0ZXJzXSAtIEFueSBzZWFyY2ggcXVlcnkgcGFyYW1ldGVyXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgYnJvd3NlIHJlc3VsdFxuKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiogQGV4YW1wbGVcbiogaW5kZXguYnJvd3NlKCdjb29sIHNvbmdzJywge1xuKiAgIHRhZ0ZpbHRlcnM6ICdwdWJsaWMsY29tbWVudHMnLFxuKiAgIGhpdHNQZXJQYWdlOiA1MDBcbiogfSwgY2FsbGJhY2spO1xuKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleENvcmUucHJvdG90eXBlLmJyb3dzZSA9IGZ1bmN0aW9uKHF1ZXJ5LCBxdWVyeVBhcmFtZXRlcnMsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXJnZSA9IHJlcXVpcmUoJy4vbWVyZ2UuanMnKTtcblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuXG4gIHZhciBwYWdlO1xuICB2YXIgaGl0c1BlclBhZ2U7XG5cbiAgLy8gd2UgY2hlY2sgdmFyaWFkaWMgY2FsbHMgdGhhdCBhcmUgbm90IHRoZSBvbmUgZGVmaW5lZFxuICAvLyAuYnJvd3NlKCkvLmJyb3dzZShmbilcbiAgLy8gPT4gcGFnZSA9IDBcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGFnZSA9IDA7XG4gICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyAuYnJvd3NlKDIpLy5icm93c2UoMiwgMTApLy5icm93c2UoMiwgZm4pLy5icm93c2UoMiwgMTAsIGZuKVxuICAgIHBhZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICBoaXRzUGVyUGFnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgICAgaGl0c1BlclBhZ2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgIC8vIC5icm93c2UocXVlcnlQYXJhbWV0ZXJzKS8uYnJvd3NlKHF1ZXJ5UGFyYW1ldGVycywgY2IpXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICBxdWVyeVBhcmFtZXRlcnMgPSBhcmd1bWVudHNbMF07XG4gICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC5icm93c2UocXVlcnksIGNiKVxuICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSBpdCdzIGEgLmJyb3dzZShxdWVyeSkvLmJyb3dzZShxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzKS8uYnJvd3NlKHF1ZXJ5LCBxdWVyeVBhcmFtZXRlcnMsIGNiKVxuXG4gIC8vIGdldCBzZWFyY2ggcXVlcnkgcGFyYW1ldGVycyBjb21iaW5pbmcgdmFyaW91cyBwb3NzaWJsZSBjYWxsc1xuICAvLyB0byAuYnJvd3NlKCk7XG4gIHF1ZXJ5UGFyYW1ldGVycyA9IG1lcmdlKHt9LCBxdWVyeVBhcmFtZXRlcnMgfHwge30sIHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIGhpdHNQZXJQYWdlOiBoaXRzUGVyUGFnZSxcbiAgICBxdWVyeTogcXVlcnlcbiAgfSk7XG5cbiAgdmFyIHBhcmFtcyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhxdWVyeVBhcmFtZXRlcnMsICcnKTtcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9icm93c2UnLFxuICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc30sXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBDb250aW51ZSBicm93c2luZyBmcm9tIGEgcHJldmlvdXMgcG9zaXRpb24gKGN1cnNvciksIG9idGFpbmVkIHZpYSBhIGNhbGwgdG8gYC5icm93c2UoKWAuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBmdWxsIHRleHQgcXVlcnlcbiogQHBhcmFtIHtPYmplY3R9IFtxdWVyeVBhcmFtZXRlcnNdIC0gQW55IHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBicm93c2UgcmVzdWx0XG4qIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuKiBAZXhhbXBsZVxuKiBpbmRleC5icm93c2VGcm9tKCcxNGxrZnNha2wzMicsIGNhbGxiYWNrKTtcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0Jyb3dzZXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5icm93c2VGcm9tID0gZnVuY3Rpb24oY3Vyc29yLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL2Jyb3dzZScsXG4gICAgYm9keToge2N1cnNvcjogY3Vyc29yfSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIFNlYXJjaCBmb3IgZmFjZXQgdmFsdWVzXG4qIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0LWFwaS9zZWFyY2gjc2VhcmNoLWZvci1mYWNldC12YWx1ZXNcbipcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWNldE5hbWUgRmFjZXQgbmFtZSwgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNlYXJjaCBmb3IgdmFsdWVzIGluLlxuKiBNdXN0IGJlIGRlY2xhcmVkIGFzIGEgZmFjZXRcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWNldFF1ZXJ5IFF1ZXJ5IGZvciB0aGUgZmFjZXQgc2VhcmNoXG4qIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLipdIEFueSBzZWFyY2ggcGFyYW1ldGVyIG9mIEFsZ29saWEsXG4qIHNlZSBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvYXBpLWNsaWVudC9qYXZhc2NyaXB0L3NlYXJjaCNzZWFyY2gtcGFyYW1ldGVyc1xuKiBQYWdpbmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuIFRoZSBwYWdlIGFuZCBoaXRzUGVyUGFnZSBwYXJhbWV0ZXJzIHdpbGwgYmUgaWdub3JlZC5cbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbClcbiovXG5JbmRleENvcmUucHJvdG90eXBlLnNlYXJjaEZvckZhY2V0VmFsdWVzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG4gIHZhciBvbWl0ID0gcmVxdWlyZSgnLi9vbWl0LmpzJyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguc2VhcmNoRm9yRmFjZXRWYWx1ZXMoe2ZhY2V0TmFtZSwgZmFjZXRRdWVyeSwgLi4ucGFyYW1zfVssIGNhbGxiYWNrXSknO1xuXG4gIGlmIChwYXJhbXMuZmFjZXROYW1lID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmZhY2V0UXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgZmFjZXROYW1lID0gcGFyYW1zLmZhY2V0TmFtZTtcbiAgdmFyIGZpbHRlcmVkUGFyYW1zID0gb21pdChjbG9uZShwYXJhbXMpLCBmdW5jdGlvbihrZXlOYW1lKSB7XG4gICAgcmV0dXJuIGtleU5hbWUgPT09ICdmYWNldE5hbWUnO1xuICB9KTtcbiAgdmFyIHNlYXJjaFBhcmFtZXRlcnMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMoZmlsdGVyZWRQYXJhbXMsICcnKTtcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArXG4gICAgICBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9mYWNldHMvJyArIGVuY29kZVVSSUNvbXBvbmVudChmYWNldE5hbWUpICsgJy9xdWVyeScsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBib2R5OiB7cGFyYW1zOiBzZWFyY2hQYXJhbWV0ZXJzfSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleENvcmUucHJvdG90eXBlLnNlYXJjaEZhY2V0ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuc2VhcmNoRm9yRmFjZXRWYWx1ZXMocGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZShcbiAgJ2luZGV4LnNlYXJjaEZhY2V0KHBhcmFtc1ssIGNhbGxiYWNrXSknLFxuICAnaW5kZXguc2VhcmNoRm9yRmFjZXRWYWx1ZXMocGFyYW1zWywgY2FsbGJhY2tdKSdcbikpO1xuXG5JbmRleENvcmUucHJvdG90eXBlLl9zZWFyY2ggPSBmdW5jdGlvbihwYXJhbXMsIHVybCwgY2FsbGJhY2ssIGFkZGl0aW9uYWxVQSkge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdXJsIHx8ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9xdWVyeScsXG4gICAgYm9keToge3BhcmFtczogcGFyYW1zfSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGZhbGxiYWNrOiB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSxcbiAgICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc31cbiAgICB9LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBhZGRpdGlvbmFsVUE6IGFkZGl0aW9uYWxVQVxuICB9KTtcbn07XG5cbi8qXG4qIEdldCBhbiBvYmplY3QgZnJvbSB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBvYmplY3RJRCB0aGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIG9iamVjdCB0byByZXRyaWV2ZVxuKiBAcGFyYW0gYXR0cnMgKG9wdGlvbmFsKSBpZiBzZXQsIGNvbnRhaW5zIHRoZSBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gcmV0cmlldmVcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgb2JqZWN0IHRvIHJldHJpZXZlIG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5nZXRPYmplY3QgPSBmdW5jdGlvbihvYmplY3RJRCwgYXR0cnMsIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGF0dHJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBhdHRycztcbiAgICBhdHRycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBwYXJhbXMgPSAnJztcbiAgaWYgKGF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMgPSAnP2F0dHJpYnV0ZXM9JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBwYXJhbXMgKz0gJywnO1xuICAgICAgfVxuICAgICAgcGFyYW1zICs9IGF0dHJzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCkgKyBwYXJhbXMsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBHZXQgc2V2ZXJhbCBvYmplY3RzIGZyb20gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gb2JqZWN0SURzIHRoZSBhcnJheSBvZiB1bmlxdWUgaWRlbnRpZmllciBvZiBvYmplY3RzIHRvIHJldHJpZXZlXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5nZXRPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0SURzLCBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguZ2V0T2JqZWN0cyhhcnJheU9mT2JqZWN0SURzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9iamVjdElEcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgYXR0cmlidXRlc1RvUmV0cmlldmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGF0dHJpYnV0ZXNUb1JldHJpZXZlO1xuICAgIGF0dHJpYnV0ZXNUb1JldHJpZXZlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGJvZHkgPSB7XG4gICAgcmVxdWVzdHM6IG1hcChvYmplY3RJRHMsIGZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KG9iamVjdElEKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgaW5kZXhOYW1lOiBpbmRleE9iai5pbmRleE5hbWUsXG4gICAgICAgIG9iamVjdElEOiBvYmplY3RJRFxuICAgICAgfTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZXNUb1JldHJpZXZlKSB7XG4gICAgICAgIHJlcXVlc3QuYXR0cmlidXRlc1RvUmV0cmlldmUgPSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZS5qb2luKCcsJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0pXG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLyovb2JqZWN0cycsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBib2R5OiBib2R5LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4Q29yZS5wcm90b3R5cGUuYXMgPSBudWxsO1xuSW5kZXhDb3JlLnByb3RvdHlwZS5pbmRleE5hbWUgPSBudWxsO1xuSW5kZXhDb3JlLnByb3RvdHlwZS50eXBlQWhlYWRBcmdzID0gbnVsbDtcbkluZGV4Q29yZS5wcm90b3R5cGUudHlwZUFoZWFkVmFsdWVPcHRpb24gPSBudWxsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0luZGV4Q29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFsZ29saWFTZWFyY2hDb3JlID0gcmVxdWlyZSgnLi4vLi4vQWxnb2xpYVNlYXJjaENvcmUuanMnKTtcbnZhciBjcmVhdGVBbGdvbGlhc2VhcmNoID0gcmVxdWlyZSgnLi4vY3JlYXRlQWxnb2xpYXNlYXJjaC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFsZ29saWFzZWFyY2goQWxnb2xpYVNlYXJjaENvcmUsICcobGl0ZSkgJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9idWlsZHMvYWxnb2xpYXNlYXJjaExpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCdnbG9iYWwnKTtcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2UgfHwgcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuXG4vLyBUaGlzIGlzIHRoZSBzdGFuZGFsb25lIGJyb3dzZXIgYnVpbGQgZW50cnkgcG9pbnRcbi8vIEJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFsZ29saWEgU2VhcmNoIEphdmFTY3JpcHQgY2xpZW50LFxuLy8gdXNpbmcgWE1MSHR0cFJlcXVlc3QsIFhEb21haW5SZXF1ZXN0IGFuZCBKU09OUCBhcyBmYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVBbGdvbGlhc2VhcmNoKEFsZ29saWFTZWFyY2gsIHVhU3VmZml4KSB7XG4gIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4gIHZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbiAgdmFyIGlubGluZUhlYWRlcnMgPSByZXF1aXJlKCcuL2lubGluZS1oZWFkZXJzJyk7XG4gIHZhciBqc29ucFJlcXVlc3QgPSByZXF1aXJlKCcuL2pzb25wLXJlcXVlc3QnKTtcbiAgdmFyIHBsYWNlcyA9IHJlcXVpcmUoJy4uL3BsYWNlcy5qcycpO1xuICB1YVN1ZmZpeCA9IHVhU3VmZml4IHx8ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RlYnVnJykge1xuICAgIHJlcXVpcmUoJ2RlYnVnJykuZW5hYmxlKCdhbGdvbGlhc2VhcmNoKicpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxnb2xpYXNlYXJjaChhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpIHtcbiAgICB2YXIgY2xvbmVEZWVwID0gcmVxdWlyZSgnLi4vY2xvbmUuanMnKTtcblxuICAgIG9wdHMgPSBjbG9uZURlZXAob3B0cyB8fCB7fSk7XG5cbiAgICBvcHRzLl91YSA9IG9wdHMuX3VhIHx8IGFsZ29saWFzZWFyY2gudWE7XG5cbiAgICByZXR1cm4gbmV3IEFsZ29saWFTZWFyY2hCcm93c2VyKGFwcGxpY2F0aW9uSUQsIGFwaUtleSwgb3B0cyk7XG4gIH1cblxuICBhbGdvbGlhc2VhcmNoLnZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uLmpzJyk7XG4gIGFsZ29saWFzZWFyY2gudWEgPSAnQWxnb2xpYSBmb3IgdmFuaWxsYSBKYXZhU2NyaXB0ICcgKyB1YVN1ZmZpeCArIGFsZ29saWFzZWFyY2gudmVyc2lvbjtcbiAgYWxnb2xpYXNlYXJjaC5pbml0UGxhY2VzID0gcGxhY2VzKGFsZ29saWFzZWFyY2gpO1xuXG4gIC8vIHdlIGV4cG9zZSBpbnRvIHdpbmRvdyBubyBtYXR0ZXIgaG93IHdlIGFyZSB1c2VkLCB0aGlzIHdpbGwgYWxsb3dcbiAgLy8gdXMgdG8gZWFzaWx5IGRlYnVnIGFueSB3ZWJzaXRlIHJ1bm5pbmcgYWxnb2xpYVxuICBnbG9iYWwuX19hbGdvbGlhID0ge1xuICAgIGRlYnVnOiByZXF1aXJlKCdkZWJ1ZycpLFxuICAgIGFsZ29saWFzZWFyY2g6IGFsZ29saWFzZWFyY2hcbiAgfTtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBoYXNYTUxIdHRwUmVxdWVzdDogJ1hNTEh0dHBSZXF1ZXN0JyBpbiBnbG9iYWwsXG4gICAgaGFzWERvbWFpblJlcXVlc3Q6ICdYRG9tYWluUmVxdWVzdCcgaW4gZ2xvYmFsXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaGFzWE1MSHR0cFJlcXVlc3QpIHtcbiAgICBzdXBwb3J0LmNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFsZ29saWFTZWFyY2hCcm93c2VyKCkge1xuICAgIC8vIGNhbGwgQWxnb2xpYVNlYXJjaCBjb25zdHJ1Y3RvclxuICAgIEFsZ29saWFTZWFyY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXRzKEFsZ29saWFTZWFyY2hCcm93c2VyLCBBbGdvbGlhU2VhcmNoKTtcblxuICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiB3cmFwUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIG5vIGNvcnMgb3IgWERvbWFpblJlcXVlc3QsIG5vIHJlcXVlc3RcbiAgICAgIGlmICghc3VwcG9ydC5jb3JzICYmICFzdXBwb3J0Lmhhc1hEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIC8vIHZlcnkgb2xkIGJyb3dzZXIsIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnMuTmV0d29yaygnQ09SUyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVybCA9IGlubGluZUhlYWRlcnModXJsLCBvcHRzLmhlYWRlcnMpO1xuXG4gICAgICB2YXIgYm9keSA9IG9wdHMuYm9keTtcbiAgICAgIHZhciByZXEgPSBzdXBwb3J0LmNvcnMgPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgdmFyIHJlcVRpbWVvdXQ7XG4gICAgICB2YXIgdGltZWRPdXQ7XG4gICAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAgIHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgb3B0cy50aW1lb3V0cy5jb25uZWN0KTtcbiAgICAgIC8vIHdlIHNldCBhbiBlbXB0eSBvbnByb2dyZXNzIGxpc3RlbmVyXG4gICAgICAvLyBzbyB0aGF0IFhEb21haW5SZXF1ZXN0IG9uIElFOSBpcyBub3QgYWJvcnRlZFxuICAgICAgLy8gcmVmczpcbiAgICAgIC8vICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWpzL2lzc3Vlcy83NlxuICAgICAgLy8gIC0gaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9pZS9lbi1VUy8zMGVmM2FkZC03NjdjLTQ0MzYtYjhhOS1mMWNhMTliNDgxMmUvaWU5LXJ0bS14ZG9tYWlucmVxdWVzdC1pc3N1ZWQtcmVxdWVzdHMtbWF5LWFib3J0LWlmLWFsbC1ldmVudC1oYW5kbGVycy1ub3Qtc3BlY2lmaWVkP2ZvcnVtPWlld2ViZGV2ZWxvcG1lbnRcbiAgICAgIHJlcS5vbnByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICAgIGlmICgnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiByZXEpIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvblJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgICByZXEub25sb2FkID0gb25Mb2FkO1xuICAgICAgcmVxLm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICAvLyBkbyBub3QgcmVseSBvbiBkZWZhdWx0IFhIUiBhc3luYyBmbGFnLCBhcyBzb21lIGFuYWx5dGljcyBjb2RlIGxpa2UgaG90amFyXG4gICAgICAvLyBicmVha3MgaXQgYW5kIHNldCBpdCB0byBmYWxzZSBieSBkZWZhdWx0XG4gICAgICBpZiAocmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmVxLm9wZW4ob3B0cy5tZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVGhlIEFuYWx5dGljcyBBUEkgbmV2ZXIgYWNjZXB0cyBBdXRoIGhlYWRlcnMgYXMgcXVlcnkgc3RyaW5nXG4gICAgICAgIC8vIHRoaXMgb3B0aW9uIGV4aXN0cyBzcGVjaWZpY2FsbHkgZm9yIHRoZW0uXG4gICAgICAgIGlmIChvcHRzLmZvcmNlQXV0aEhlYWRlcnMpIHtcbiAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcbiAgICAgICAgICAgICd4LWFsZ29saWEtYXBwbGljYXRpb24taWQnLFxuICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWFsZ29saWEtYXBwbGljYXRpb24taWQnXVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgICAneC1hbGdvbGlhLWFwaS1rZXknLFxuICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWFsZ29saWEtYXBpLWtleSddXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLm9wZW4ob3B0cy5tZXRob2QsIHVybCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhlYWRlcnMgYXJlIG1lYW50IHRvIGJlIHNlbnQgYWZ0ZXIgb3BlblxuICAgICAgaWYgKHN1cHBvcnQuY29ycykge1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgIGlmIChvcHRzLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0FjY2Vzc19jb250cm9sX0NPUlMjU2ltcGxlX3JlcXVlc3RzXG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJlcS5zZW5kKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXZlbnQgb2JqZWN0IG5vdCByZWNlaXZlZCBpbiBJRTgsIGF0IGxlYXN0XG4gICAgICAvLyBidXQgd2UgZG8gbm90IHVzZSBpdCwgc3RpbGwgaW1wb3J0YW50IHRvIG5vdGVcbiAgICAgIGZ1bmN0aW9uIG9uTG9hZCgvKiBldmVudCAqLykge1xuICAgICAgICAvLyBXaGVuIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydHMgcmVxLnRpbWVvdXQsIHdlIGNhblxuICAgICAgICAvLyBoYXZlIGJvdGggYSBsb2FkIGFuZCB0aW1lb3V0IGV2ZW50LCBzaW5jZSBoYW5kbGVkIGJ5IGEgZHVtYiBzZXRUaW1lb3V0XG4gICAgICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcblxuICAgICAgICB2YXIgb3V0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ID0ge1xuICAgICAgICAgICAgYm9keTogSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KSxcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogcmVxLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlcS5zdGF0dXMsXG4gICAgICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBkb2VzIG5vdCBoYXZlIGFueSByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICBoZWFkZXJzOiByZXEuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzICYmIHJlcS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCB7fVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBvdXQgPSBuZXcgZXJyb3JzLlVucGFyc2FibGVKU09OKHtcbiAgICAgICAgICAgIG1vcmU6IHJlcS5yZXNwb25zZVRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXQgaW5zdGFuY2VvZiBlcnJvcnMuVW5wYXJzYWJsZUpTT04pIHtcbiAgICAgICAgICByZWplY3Qob3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cbiAgICAgICAgLy8gZXJyb3IgZXZlbnQgaXMgdHJpZ2VycmVkIGJvdGggd2l0aCBYRFIvWEhSIG9uOlxuICAgICAgICAvLyAgIC0gRE5TIGVycm9yXG4gICAgICAgIC8vICAgLSB1bmFsbG93ZWQgY3Jvc3MgZG9tYWluIHJlcXVlc3RcbiAgICAgICAgcmVqZWN0KFxuICAgICAgICAgIG5ldyBlcnJvcnMuTmV0d29yayh7XG4gICAgICAgICAgICBtb3JlOiBldmVudFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgICByZWplY3QobmV3IGVycm9ycy5SZXF1ZXN0VGltZW91dCgpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Db25uZWN0KCkge1xuICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG4gICAgICAgIHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgb3B0cy50aW1lb3V0cy5jb21wbGV0ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmICghY29ubmVjdGVkKSBvbkNvbm5lY3QoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWFkeVN0YXRlQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWNvbm5lY3RlZCAmJiByZXEucmVhZHlTdGF0ZSA+IDEpIG9uQ29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIEFsZ29saWFTZWFyY2hCcm93c2VyLnByb3RvdHlwZS5fcmVxdWVzdC5mYWxsYmFjayA9IGZ1bmN0aW9uIHJlcXVlc3RGYWxsYmFjayh1cmwsIG9wdHMpIHtcbiAgICB1cmwgPSBpbmxpbmVIZWFkZXJzKHVybCwgb3B0cy5oZWFkZXJzKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiB3cmFwSnNvbnBSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgICAganNvbnBSZXF1ZXN0KHVybCwgb3B0cywgZnVuY3Rpb24ganNvbnBSZXF1ZXN0RG9uZShlcnIsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoY29udGVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3Byb21pc2UgPSB7XG4gICAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3RQcm9taXNlKHZhbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbCk7XG4gICAgfSxcbiAgICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsKTtcbiAgICB9LFxuICAgIGRlbGF5OiBmdW5jdGlvbiBkZWxheVByb21pc2UobXMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiByZXNvbHZlT25UaW1lb3V0KHJlc29sdmUvKiAsIHJlamVjdCovKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhbGw6IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGFsZ29saWFzZWFyY2g7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvY3JlYXRlQWxnb2xpYXNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBpbmxpbmVIZWFkZXJzO1xuXG52YXIgZW5jb2RlID0gcmVxdWlyZSgncXVlcnlzdHJpbmctZXMzL2VuY29kZScpO1xuXG5mdW5jdGlvbiBpbmxpbmVIZWFkZXJzKHVybCwgaGVhZGVycykge1xuICBpZiAoL1xcPy8udGVzdCh1cmwpKSB7XG4gICAgdXJsICs9ICcmJztcbiAgfSBlbHNlIHtcbiAgICB1cmwgKz0gJz8nO1xuICB9XG5cbiAgcmV0dXJuIHVybCArIGVuY29kZShoZWFkZXJzKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2lubGluZS1oZWFkZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25wUmVxdWVzdDtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG52YXIgSlNPTlBDb3VudGVyID0gMDtcblxuZnVuY3Rpb24ganNvbnBSZXF1ZXN0KHVybCwgb3B0cywgY2IpIHtcbiAgaWYgKG9wdHMubWV0aG9kICE9PSAnR0VUJykge1xuICAgIGNiKG5ldyBFcnJvcignTWV0aG9kICcgKyBvcHRzLm1ldGhvZCArICcgJyArIHVybCArICcgaXMgbm90IHN1cHBvcnRlZCBieSBKU09OUC4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0cy5kZWJ1ZygnSlNPTlA6IHN0YXJ0Jyk7XG5cbiAgdmFyIGNiQ2FsbGVkID0gZmFsc2U7XG4gIHZhciB0aW1lZE91dCA9IGZhbHNlO1xuXG4gIEpTT05QQ291bnRlciArPSAxO1xuICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIGNiTmFtZSA9ICdhbGdvbGlhSlNPTlBfJyArIEpTT05QQ291bnRlcjtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcblxuICB3aW5kb3dbY2JOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZW1vdmVHbG9iYWxzKCk7XG5cbiAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgIG9wdHMuZGVidWcoJ0pTT05QOiBMYXRlIGFuc3dlciwgaWdub3JpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYkNhbGxlZCA9IHRydWU7XG5cbiAgICBjbGVhbigpO1xuXG4gICAgY2IobnVsbCwge1xuICAgICAgYm9keTogZGF0YSxcbiAgICAgIHJlc3BvbnNlVGV4dDogSlNPTi5zdHJpbmdpZnkoZGF0YSkvKiAsXG4gICAgICAvLyBXZSBkbyBub3Qgc2VuZCB0aGUgc3RhdHVzQ29kZSwgdGhlcmUncyBubyBzdGF0dXNDb2RlIGluIEpTT05QLCBpdCB3aWxsIGJlXG4gICAgICAvLyBjb21wdXRlZCB1c2luZyBkYXRhLnN0YXR1cyAmJiBkYXRhLm1lc3NhZ2UgbGlrZSB3aXRoIFhEUlxuICAgICAgc3RhdHVzQ29kZSovXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYWRkIGNhbGxiYWNrIGJ5IGhhbmRcbiAgdXJsICs9ICcmY2FsbGJhY2s9JyArIGNiTmFtZTtcblxuICAvLyBhZGQgYm9keSBwYXJhbXMgbWFudWFsbHlcbiAgaWYgKG9wdHMuanNvbkJvZHkgJiYgb3B0cy5qc29uQm9keS5wYXJhbXMpIHtcbiAgICB1cmwgKz0gJyYnICsgb3B0cy5qc29uQm9keS5wYXJhbXM7XG4gIH1cblxuICB2YXIgb250aW1lb3V0ID0gc2V0VGltZW91dCh0aW1lb3V0LCBvcHRzLnRpbWVvdXRzLmNvbXBsZXRlKTtcblxuICAvLyBzY3JpcHQgb25yZWFkeXN0YXRlY2hhbmdlIG5lZWRlZCBvbmx5IGZvclxuICAvLyA8PSBJRThcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvNDUyM1xuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZTtcbiAgc2NyaXB0Lm9ubG9hZCA9IHN1Y2Nlc3M7XG4gIHNjcmlwdC5vbmVycm9yID0gZXJyb3I7XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgb3B0cy5kZWJ1ZygnSlNPTlA6IHN1Y2Nlc3MnKTtcblxuICAgIGlmIChkb25lIHx8IHRpbWVkT3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9uZSA9IHRydWU7XG5cbiAgICAvLyBzY3JpcHQgbG9hZGVkIGJ1dCBkaWQgbm90IGNhbGwgdGhlIGZuID0+IHNjcmlwdCBsb2FkaW5nIGVycm9yXG4gICAgaWYgKCFjYkNhbGxlZCkge1xuICAgICAgb3B0cy5kZWJ1ZygnSlNPTlA6IEZhaWwuIFNjcmlwdCBsb2FkZWQgYnV0IGRpZCBub3QgY2FsbCB0aGUgY2FsbGJhY2snKTtcbiAgICAgIGNsZWFuKCk7XG4gICAgICBjYihuZXcgZXJyb3JzLkpTT05QU2NyaXB0RmFpbCgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgc3VjY2VzcygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgIGNsZWFyVGltZW91dChvbnRpbWVvdXQpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVHbG9iYWxzKCkge1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgd2luZG93W2NiTmFtZV07XG4gICAgICBkZWxldGUgd2luZG93W2NiTmFtZSArICdfbG9hZGVkJ107XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2luZG93W2NiTmFtZV0gPSB3aW5kb3dbY2JOYW1lICsgJ19sb2FkZWQnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lb3V0KCkge1xuICAgIG9wdHMuZGVidWcoJ0pTT05QOiBTY3JpcHQgdGltZW91dCcpO1xuICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICBjbGVhbigpO1xuICAgIGNiKG5ldyBlcnJvcnMuUmVxdWVzdFRpbWVvdXQoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICBvcHRzLmRlYnVnKCdKU09OUDogU2NyaXB0IGVycm9yJyk7XG5cbiAgICBpZiAoZG9uZSB8fCB0aW1lZE91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFuKCk7XG4gICAgY2IobmV3IGVycm9ycy5KU09OUFNjcmlwdEVycm9yKCkpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9qc29ucC1yZXF1ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZXByZWNhdGVkTWVzc2FnZShwcmV2aW91c1VzYWdlLCBuZXdVc2FnZSkge1xuICB2YXIgZ2l0aHViQW5jaG9yTGluayA9IHByZXZpb3VzVXNhZ2UudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC9bXFwuXFwoXFwpXS9nLCAnJyk7XG5cbiAgcmV0dXJuICdhbGdvbGlhc2VhcmNoOiBgJyArIHByZXZpb3VzVXNhZ2UgKyAnYCB3YXMgcmVwbGFjZWQgYnkgYCcgKyBuZXdVc2FnZSArXG4gICAgJ2AuIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYWxnb2xpYXNlYXJjaC1jbGllbnQtamF2YXNjcmlwdC93aWtpL0RlcHJlY2F0ZWQjJyArIGdpdGh1YkFuY2hvckxpbms7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2RlcHJlY2F0ZWRNZXNzYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gUGFyc2UgY2xvdWQgZG9lcyBub3Qgc3VwcG9ydHMgc2V0VGltZW91dFxuLy8gV2UgZG8gbm90IHN0b3JlIGEgc2V0VGltZW91dCByZWZlcmVuY2UgaW4gdGhlIGNsaWVudCBldmVyeXRpbWVcbi8vIFdlIG9ubHkgZmFsbGJhY2sgdG8gYSBmYWtlIHNldFRpbWVvdXQgd2hlbiBub3QgYXZhaWxhYmxlXG4vLyBzZXRUaW1lb3V0IGNhbm5vdCBiZSBvdmVycmlkZSBnbG9iYWxseSBzYWRseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGl0UHJvbWlzZShmbiwgX3NldFRpbWVvdXQpIHtcbiAgX3NldFRpbWVvdXQoZm4sIDApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9leGl0UHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmb3JlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlKGRlc3RpbmF0aW9uLyogLCBzb3VyY2VzICovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmb3JlYWNoKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIGZvciAodmFyIGtleU5hbWUgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleU5hbWUpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25ba2V5TmFtZV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBzb3VyY2Vba2V5TmFtZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25ba2V5TmFtZV0gPSBtZXJnZSh7fSwgZGVzdGluYXRpb25ba2V5TmFtZV0sIHNvdXJjZVtrZXlOYW1lXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlW2tleU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltrZXlOYW1lXSA9IHNvdXJjZVtrZXlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tZXJnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUGxhY2VzQ2xpZW50O1xuXG52YXIgYnVpbGRTZWFyY2hNZXRob2QgPSByZXF1aXJlKCcuL2J1aWxkU2VhcmNoTWV0aG9kLmpzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYWNlc0NsaWVudChhbGdvbGlhc2VhcmNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwbGFjZXMoYXBwSUQsIGFwaUtleSwgb3B0cykge1xuICAgIHZhciBjbG9uZURlZXAgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG5cbiAgICBvcHRzID0gb3B0cyAmJiBjbG9uZURlZXAob3B0cykgfHwge307XG4gICAgb3B0cy5ob3N0cyA9IG9wdHMuaG9zdHMgfHwgW1xuICAgICAgJ3BsYWNlcy1kc24uYWxnb2xpYS5uZXQnLFxuICAgICAgJ3BsYWNlcy0xLmFsZ29saWFuZXQuY29tJyxcbiAgICAgICdwbGFjZXMtMi5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAncGxhY2VzLTMuYWxnb2xpYW5ldC5jb20nXG4gICAgXTtcblxuICAgIC8vIGFsbG93IGluaXRQbGFjZXMoKSBubyBhcmd1bWVudHMgPT4gY29tbXVuaXR5IHJhdGUgbGltaXRlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBhcHBJRCA9PT0gJ29iamVjdCcgfHwgYXBwSUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXBwSUQgPSAnJztcbiAgICAgIGFwaUtleSA9ICcnO1xuICAgICAgb3B0cy5fYWxsb3dFbXB0eUNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2xpZW50ID0gYWxnb2xpYXNlYXJjaChhcHBJRCwgYXBpS2V5LCBvcHRzKTtcbiAgICB2YXIgaW5kZXggPSBjbGllbnQuaW5pdEluZGV4KCdwbGFjZXMnKTtcbiAgICBpbmRleC5zZWFyY2ggPSBidWlsZFNlYXJjaE1ldGhvZCgncXVlcnknLCAnLzEvcGxhY2VzL3F1ZXJ5Jyk7XG4gICAgaW5kZXguZ2V0T2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6ICcvMS9wbGFjZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvcGxhY2VzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxnb2xpYXNlYXJjaDpzcmMvaG9zdEluZGV4U3RhdGUuanMnKTtcbnZhciBsb2NhbFN0b3JhZ2VOYW1lc3BhY2UgPSAnYWxnb2xpYXNlYXJjaC1jbGllbnQtanMnO1xuXG52YXIgc3RvcmU7XG52YXIgbW9kdWxlU3RvcmUgPSB7XG4gIHN0YXRlOiB7fSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIGRhdGEpIHtcbiAgICB0aGlzLnN0YXRlW2tleV0gPSBkYXRhO1xuICAgIHJldHVybiB0aGlzLnN0YXRlW2tleV07XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVba2V5XSB8fCBudWxsO1xuICB9XG59O1xuXG52YXIgbG9jYWxTdG9yYWdlU3RvcmUgPSB7XG4gIHNldDogZnVuY3Rpb24oa2V5LCBkYXRhKSB7XG4gICAgbW9kdWxlU3RvcmUuc2V0KGtleSwgZGF0YSk7IC8vIGFsd2F5cyByZXBsaWNhdGUgbG9jYWxTdG9yYWdlU3RvcmUgdG8gbW9kdWxlU3RvcmUgaW4gY2FzZSBvZiBmYWlsdXJlXG5cbiAgICB0cnkge1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IEpTT04ucGFyc2UoZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdKTtcbiAgICAgIG5hbWVzcGFjZVtrZXldID0gZGF0YTtcbiAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSA9IEpTT04uc3RyaW5naWZ5KG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gbmFtZXNwYWNlW2tleV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZUZhaWx1cmUoa2V5LCBlKTtcbiAgICB9XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSlba2V5XSB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VGYWlsdXJlKGtleSwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2VGYWlsdXJlKGtleSwgZSkge1xuICBkZWJ1ZygnbG9jYWxTdG9yYWdlIGZhaWxlZCB3aXRoJywgZSk7XG4gIGNsZWFudXAoKTtcbiAgc3RvcmUgPSBtb2R1bGVTdG9yZTtcbiAgcmV0dXJuIHN0b3JlLmdldChrZXkpO1xufVxuXG5zdG9yZSA9IHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgPyBsb2NhbFN0b3JhZ2VTdG9yZSA6IG1vZHVsZVN0b3JlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0OiBnZXRPclNldCxcbiAgc2V0OiBnZXRPclNldCxcbiAgc3VwcG9ydHNMb2NhbFN0b3JhZ2U6IHN1cHBvcnRzTG9jYWxTdG9yYWdlXG59O1xuXG5mdW5jdGlvbiBnZXRPclNldChrZXksIGRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGtleSk7XG4gIH1cblxuICByZXR1cm4gc3RvcmUuc2V0KGtleSwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkge1xuICB0cnkge1xuICAgIGlmICgnbG9jYWxTdG9yYWdlJyBpbiBnbG9iYWwgJiZcbiAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UgIT09IG51bGwpIHtcbiAgICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdKSB7XG4gICAgICAgIC8vIGFjdHVhbCBjcmVhdGlvbiBvZiB0aGUgbmFtZXNwYWNlXG4gICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VOYW1lc3BhY2UsIEpTT04uc3RyaW5naWZ5KHt9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSW4gY2FzZSBvZiBhbnkgZXJyb3Igb24gbG9jYWxTdG9yYWdlLCB3ZSBjbGVhbiBvdXIgb3duIG5hbWVzcGFjZSwgdGhpcyBzaG91bGQgaGFuZGxlXG4vLyBxdW90YSBlcnJvcnMgd2hlbiBhIGxvdCBvZiBrZXlzICsgZGF0YSBhcmUgdXNlZFxuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgdHJ5IHtcbiAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obG9jYWxTdG9yYWdlTmFtZXNwYWNlKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL3N0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICczLjI5LjAnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL3ZlcnNpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuIDIwMTcgSnVsaWFuIEdhcm5pZXJcbiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiovXG52YXIgJGpzY29tcD17c2NvcGU6e319OyRqc2NvbXAuZGVmaW5lUHJvcGVydHk9XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnRpZXM/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKGUscixwKXtpZihwLmdldHx8cC5zZXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVTMyBkb2VzIG5vdCBzdXBwb3J0IGdldHRlcnMgYW5kIHNldHRlcnMuXCIpO2UhPUFycmF5LnByb3RvdHlwZSYmZSE9T2JqZWN0LnByb3RvdHlwZSYmKGVbcl09cC52YWx1ZSl9OyRqc2NvbXAuZ2V0R2xvYmFsPWZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdz09PWU/ZTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiZudWxsIT1nbG9iYWw/Z2xvYmFsOmV9OyRqc2NvbXAuZ2xvYmFsPSRqc2NvbXAuZ2V0R2xvYmFsKHRoaXMpOyRqc2NvbXAuU1lNQk9MX1BSRUZJWD1cImpzY29tcF9zeW1ib2xfXCI7XG4kanNjb21wLmluaXRTeW1ib2w9ZnVuY3Rpb24oKXskanNjb21wLmluaXRTeW1ib2w9ZnVuY3Rpb24oKXt9OyRqc2NvbXAuZ2xvYmFsLlN5bWJvbHx8KCRqc2NvbXAuZ2xvYmFsLlN5bWJvbD0kanNjb21wLlN5bWJvbCl9OyRqc2NvbXAuc3ltYm9sQ291bnRlcl89MDskanNjb21wLlN5bWJvbD1mdW5jdGlvbihlKXtyZXR1cm4gJGpzY29tcC5TWU1CT0xfUFJFRklYKyhlfHxcIlwiKSskanNjb21wLnN5bWJvbENvdW50ZXJfKyt9O1xuJGpzY29tcC5pbml0U3ltYm9sSXRlcmF0b3I9ZnVuY3Rpb24oKXskanNjb21wLmluaXRTeW1ib2woKTt2YXIgZT0kanNjb21wLmdsb2JhbC5TeW1ib2wuaXRlcmF0b3I7ZXx8KGU9JGpzY29tcC5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yPSRqc2NvbXAuZ2xvYmFsLlN5bWJvbChcIml0ZXJhdG9yXCIpKTtcImZ1bmN0aW9uXCIhPXR5cGVvZiBBcnJheS5wcm90b3R5cGVbZV0mJiRqc2NvbXAuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLGUse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpmdW5jdGlvbigpe3JldHVybiAkanNjb21wLmFycmF5SXRlcmF0b3IodGhpcyl9fSk7JGpzY29tcC5pbml0U3ltYm9sSXRlcmF0b3I9ZnVuY3Rpb24oKXt9fTskanNjb21wLmFycmF5SXRlcmF0b3I9ZnVuY3Rpb24oZSl7dmFyIHI9MDtyZXR1cm4gJGpzY29tcC5pdGVyYXRvclByb3RvdHlwZShmdW5jdGlvbigpe3JldHVybiByPGUubGVuZ3RoP3tkb25lOiExLHZhbHVlOmVbcisrXX06e2RvbmU6ITB9fSl9O1xuJGpzY29tcC5pdGVyYXRvclByb3RvdHlwZT1mdW5jdGlvbihlKXskanNjb21wLmluaXRTeW1ib2xJdGVyYXRvcigpO2U9e25leHQ6ZX07ZVskanNjb21wLmdsb2JhbC5TeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3JldHVybiBlfTskanNjb21wLmFycmF5PSRqc2NvbXAuYXJyYXl8fHt9OyRqc2NvbXAuaXRlcmF0b3JGcm9tQXJyYXk9ZnVuY3Rpb24oZSxyKXskanNjb21wLmluaXRTeW1ib2xJdGVyYXRvcigpO2UgaW5zdGFuY2VvZiBTdHJpbmcmJihlKz1cIlwiKTt2YXIgcD0wLG09e25leHQ6ZnVuY3Rpb24oKXtpZihwPGUubGVuZ3RoKXt2YXIgdT1wKys7cmV0dXJue3ZhbHVlOnIodSxlW3VdKSxkb25lOiExfX1tLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTohMCx2YWx1ZTp2b2lkIDB9fTtyZXR1cm4gbS5uZXh0KCl9fTttW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gbX07cmV0dXJuIG19O1xuJGpzY29tcC5wb2x5ZmlsbD1mdW5jdGlvbihlLHIscCxtKXtpZihyKXtwPSRqc2NvbXAuZ2xvYmFsO2U9ZS5zcGxpdChcIi5cIik7Zm9yKG09MDttPGUubGVuZ3RoLTE7bSsrKXt2YXIgdT1lW21dO3UgaW4gcHx8KHBbdV09e30pO3A9cFt1XX1lPWVbZS5sZW5ndGgtMV07bT1wW2VdO3I9cihtKTtyIT1tJiZudWxsIT1yJiYkanNjb21wLmRlZmluZVByb3BlcnR5KHAsZSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnJ9KX19OyRqc2NvbXAucG9seWZpbGwoXCJBcnJheS5wcm90b3R5cGUua2V5c1wiLGZ1bmN0aW9uKGUpe3JldHVybiBlP2U6ZnVuY3Rpb24oKXtyZXR1cm4gJGpzY29tcC5pdGVyYXRvckZyb21BcnJheSh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiBlfSl9fSxcImVzNi1pbXBsXCIsXCJlczNcIik7dmFyICRqc2NvbXAkdGhpcz10aGlzO1xuKGZ1bmN0aW9uKGUscil7XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10scik6XCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPXIoKTplLmFuaW1lPXIoKX0pKHRoaXMsZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGEpe2lmKCFoLmNvbChhKSl0cnl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYSl9Y2F0Y2goYyl7fX1mdW5jdGlvbiByKGEsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGI9Mjw9YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwLGY9W10sbj0wO248ZDtuKyspaWYobiBpbiBhKXt2YXIgaz1hW25dO2MuY2FsbChiLGssbixhKSYmZi5wdXNoKGspfXJldHVybiBmfWZ1bmN0aW9uIHAoYSl7cmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uKGEsZCl7cmV0dXJuIGEuY29uY2F0KGguYXJyKGQpP3AoZCk6ZCl9LFtdKX1mdW5jdGlvbiBtKGEpe2lmKGguYXJyKGEpKXJldHVybiBhO1xuaC5zdHIoYSkmJihhPWUoYSl8fGEpO3JldHVybiBhIGluc3RhbmNlb2YgTm9kZUxpc3R8fGEgaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbj9bXS5zbGljZS5jYWxsKGEpOlthXX1mdW5jdGlvbiB1KGEsYyl7cmV0dXJuIGEuc29tZShmdW5jdGlvbihhKXtyZXR1cm4gYT09PWN9KX1mdW5jdGlvbiBDKGEpe3ZhciBjPXt9LGQ7Zm9yKGQgaW4gYSljW2RdPWFbZF07cmV0dXJuIGN9ZnVuY3Rpb24gRChhLGMpe3ZhciBkPUMoYSksYjtmb3IoYiBpbiBhKWRbYl09Yy5oYXNPd25Qcm9wZXJ0eShiKT9jW2JdOmFbYl07cmV0dXJuIGR9ZnVuY3Rpb24geihhLGMpe3ZhciBkPUMoYSksYjtmb3IoYiBpbiBjKWRbYl09aC51bmQoYVtiXSk/Y1tiXTphW2JdO3JldHVybiBkfWZ1bmN0aW9uIFQoYSl7YT1hLnJlcGxhY2UoL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSxmdW5jdGlvbihhLGMsZCxrKXtyZXR1cm4gYytjK2QrZCtrK2t9KTt2YXIgYz0vXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoYSk7XG5hPXBhcnNlSW50KGNbMV0sMTYpO3ZhciBkPXBhcnNlSW50KGNbMl0sMTYpLGM9cGFyc2VJbnQoY1szXSwxNik7cmV0dXJuXCJyZ2JhKFwiK2ErXCIsXCIrZCtcIixcIitjK1wiLDEpXCJ9ZnVuY3Rpb24gVShhKXtmdW5jdGlvbiBjKGEsYyxiKXswPmImJihiKz0xKTsxPGImJi0tYjtyZXR1cm4gYjwxLzY/YSs2KihjLWEpKmI6LjU+Yj9jOmI8Mi8zP2ErKGMtYSkqKDIvMy1iKSo2OmF9dmFyIGQ9L2hzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKS9nLmV4ZWMoYSl8fC9oc2xhXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKylcXCkvZy5leGVjKGEpO2E9cGFyc2VJbnQoZFsxXSkvMzYwO3ZhciBiPXBhcnNlSW50KGRbMl0pLzEwMCxmPXBhcnNlSW50KGRbM10pLzEwMCxkPWRbNF18fDE7aWYoMD09YilmPWI9YT1mO2Vsc2V7dmFyIG49LjU+Zj9mKigxK2IpOmYrYi1mKmIsaz0yKmYtbixmPWMoayxuLGErMS8zKSxiPWMoayxuLGEpO2E9YyhrLG4sYS0xLzMpfXJldHVyblwicmdiYShcIitcbjI1NSpmK1wiLFwiKzI1NSpiK1wiLFwiKzI1NSphK1wiLFwiK2QrXCIpXCJ9ZnVuY3Rpb24geShhKXtpZihhPS8oW1xcK1xcLV0/WzAtOSNcXC5dKykoJXxweHxwdHxlbXxyZW18aW58Y218bW18ZXh8Y2h8cGN8dnd8dmh8dm1pbnx2bWF4fGRlZ3xyYWR8dHVybik/JC8uZXhlYyhhKSlyZXR1cm4gYVsyXX1mdW5jdGlvbiBWKGEpe2lmKC0xPGEuaW5kZXhPZihcInRyYW5zbGF0ZVwiKXx8XCJwZXJzcGVjdGl2ZVwiPT09YSlyZXR1cm5cInB4XCI7aWYoLTE8YS5pbmRleE9mKFwicm90YXRlXCIpfHwtMTxhLmluZGV4T2YoXCJza2V3XCIpKXJldHVyblwiZGVnXCJ9ZnVuY3Rpb24gSShhLGMpe3JldHVybiBoLmZuYyhhKT9hKGMudGFyZ2V0LGMuaWQsYy50b3RhbCk6YX1mdW5jdGlvbiBFKGEsYyl7aWYoYyBpbiBhLnN0eWxlKXJldHVybiBnZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSl8fFwiMFwifWZ1bmN0aW9uIEooYSxjKXtpZihoLmRvbShhKSYmXG51KFcsYykpcmV0dXJuXCJ0cmFuc2Zvcm1cIjtpZihoLmRvbShhKSYmKGEuZ2V0QXR0cmlidXRlKGMpfHxoLnN2ZyhhKSYmYVtjXSkpcmV0dXJuXCJhdHRyaWJ1dGVcIjtpZihoLmRvbShhKSYmXCJ0cmFuc2Zvcm1cIiE9PWMmJkUoYSxjKSlyZXR1cm5cImNzc1wiO2lmKG51bGwhPWFbY10pcmV0dXJuXCJvYmplY3RcIn1mdW5jdGlvbiBYKGEsYyl7dmFyIGQ9VihjKSxkPS0xPGMuaW5kZXhPZihcInNjYWxlXCIpPzE6MCtkO2E9YS5zdHlsZS50cmFuc2Zvcm07aWYoIWEpcmV0dXJuIGQ7Zm9yKHZhciBiPVtdLGY9W10sbj1bXSxrPS8oXFx3KylcXCgoLis/KVxcKS9nO2I9ay5leGVjKGEpOylmLnB1c2goYlsxXSksbi5wdXNoKGJbMl0pO2E9cihuLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGZbYl09PT1jfSk7cmV0dXJuIGEubGVuZ3RoP2FbMF06ZH1mdW5jdGlvbiBLKGEsYyl7c3dpdGNoKEooYSxjKSl7Y2FzZSBcInRyYW5zZm9ybVwiOnJldHVybiBYKGEsYyk7Y2FzZSBcImNzc1wiOnJldHVybiBFKGEsYyk7Y2FzZSBcImF0dHJpYnV0ZVwiOnJldHVybiBhLmdldEF0dHJpYnV0ZShjKX1yZXR1cm4gYVtjXXx8XG4wfWZ1bmN0aW9uIEwoYSxjKXt2YXIgZD0vXihcXCo9fFxcKz18LT0pLy5leGVjKGEpO2lmKCFkKXJldHVybiBhO3ZhciBiPXkoYSl8fDA7Yz1wYXJzZUZsb2F0KGMpO2E9cGFyc2VGbG9hdChhLnJlcGxhY2UoZFswXSxcIlwiKSk7c3dpdGNoKGRbMF1bMF0pe2Nhc2UgXCIrXCI6cmV0dXJuIGMrYStiO2Nhc2UgXCItXCI6cmV0dXJuIGMtYStiO2Nhc2UgXCIqXCI6cmV0dXJuIGMqYStifX1mdW5jdGlvbiBGKGEsYyl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhjLngtYS54LDIpK01hdGgucG93KGMueS1hLnksMikpfWZ1bmN0aW9uIE0oYSl7YT1hLnBvaW50cztmb3IodmFyIGM9MCxkLGI9MDtiPGEubnVtYmVyT2ZJdGVtcztiKyspe3ZhciBmPWEuZ2V0SXRlbShiKTswPGImJihjKz1GKGQsZikpO2Q9Zn1yZXR1cm4gY31mdW5jdGlvbiBOKGEpe2lmKGEuZ2V0VG90YWxMZW5ndGgpcmV0dXJuIGEuZ2V0VG90YWxMZW5ndGgoKTtzd2l0Y2goYS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpe2Nhc2UgXCJjaXJjbGVcIjpyZXR1cm4gMipcbk1hdGguUEkqYS5nZXRBdHRyaWJ1dGUoXCJyXCIpO2Nhc2UgXCJyZWN0XCI6cmV0dXJuIDIqYS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSsyKmEuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpO2Nhc2UgXCJsaW5lXCI6cmV0dXJuIEYoe3g6YS5nZXRBdHRyaWJ1dGUoXCJ4MVwiKSx5OmEuZ2V0QXR0cmlidXRlKFwieTFcIil9LHt4OmEuZ2V0QXR0cmlidXRlKFwieDJcIikseTphLmdldEF0dHJpYnV0ZShcInkyXCIpfSk7Y2FzZSBcInBvbHlsaW5lXCI6cmV0dXJuIE0oYSk7Y2FzZSBcInBvbHlnb25cIjp2YXIgYz1hLnBvaW50cztyZXR1cm4gTShhKStGKGMuZ2V0SXRlbShjLm51bWJlck9mSXRlbXMtMSksYy5nZXRJdGVtKDApKX19ZnVuY3Rpb24gWShhLGMpe2Z1bmN0aW9uIGQoYil7Yj12b2lkIDA9PT1iPzA6YjtyZXR1cm4gYS5lbC5nZXRQb2ludEF0TGVuZ3RoKDE8PWMrYj9jK2I6MCl9dmFyIGI9ZCgpLGY9ZCgtMSksbj1kKDEpO3N3aXRjaChhLnByb3BlcnR5KXtjYXNlIFwieFwiOnJldHVybiBiLng7Y2FzZSBcInlcIjpyZXR1cm4gYi55O1xuY2FzZSBcImFuZ2xlXCI6cmV0dXJuIDE4MCpNYXRoLmF0YW4yKG4ueS1mLnksbi54LWYueCkvTWF0aC5QSX19ZnVuY3Rpb24gTyhhLGMpe3ZhciBkPS8tP1xcZCpcXC4/XFxkKy9nLGI7Yj1oLnB0aChhKT9hLnRvdGFsTGVuZ3RoOmE7aWYoaC5jb2woYikpaWYoaC5yZ2IoYikpe3ZhciBmPS9yZ2JcXCgoXFxkKyxcXHMqW1xcZF0rLFxccypbXFxkXSspXFwpL2cuZXhlYyhiKTtiPWY/XCJyZ2JhKFwiK2ZbMV0rXCIsMSlcIjpifWVsc2UgYj1oLmhleChiKT9UKGIpOmguaHNsKGIpP1UoYik6dm9pZCAwO2Vsc2UgZj0oZj15KGIpKT9iLnN1YnN0cigwLGIubGVuZ3RoLWYubGVuZ3RoKTpiLGI9YyYmIS9cXHMvZy50ZXN0KGIpP2YrYzpmO2IrPVwiXCI7cmV0dXJue29yaWdpbmFsOmIsbnVtYmVyczpiLm1hdGNoKGQpP2IubWF0Y2goZCkubWFwKE51bWJlcik6WzBdLHN0cmluZ3M6aC5zdHIoYSl8fGM/Yi5zcGxpdChkKTpbXX19ZnVuY3Rpb24gUChhKXthPWE/cChoLmFycihhKT9hLm1hcChtKTptKGEpKTpbXTtyZXR1cm4gcihhLFxuZnVuY3Rpb24oYSxkLGIpe3JldHVybiBiLmluZGV4T2YoYSk9PT1kfSl9ZnVuY3Rpb24gWihhKXt2YXIgYz1QKGEpO3JldHVybiBjLm1hcChmdW5jdGlvbihhLGIpe3JldHVybnt0YXJnZXQ6YSxpZDpiLHRvdGFsOmMubGVuZ3RofX0pfWZ1bmN0aW9uIGFhKGEsYyl7dmFyIGQ9QyhjKTtpZihoLmFycihhKSl7dmFyIGI9YS5sZW5ndGg7MiE9PWJ8fGgub2JqKGFbMF0pP2guZm5jKGMuZHVyYXRpb24pfHwoZC5kdXJhdGlvbj1jLmR1cmF0aW9uL2IpOmE9e3ZhbHVlOmF9fXJldHVybiBtKGEpLm1hcChmdW5jdGlvbihhLGIpe2I9Yj8wOmMuZGVsYXk7YT1oLm9iaihhKSYmIWgucHRoKGEpP2E6e3ZhbHVlOmF9O2gudW5kKGEuZGVsYXkpJiYoYS5kZWxheT1iKTtyZXR1cm4gYX0pLm1hcChmdW5jdGlvbihhKXtyZXR1cm4geihhLGQpfSl9ZnVuY3Rpb24gYmEoYSxjKXt2YXIgZD17fSxiO2ZvcihiIGluIGEpe3ZhciBmPUkoYVtiXSxjKTtoLmFycihmKSYmKGY9Zi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIEkoYSxcbmMpfSksMT09PWYubGVuZ3RoJiYoZj1mWzBdKSk7ZFtiXT1mfWQuZHVyYXRpb249cGFyc2VGbG9hdChkLmR1cmF0aW9uKTtkLmRlbGF5PXBhcnNlRmxvYXQoZC5kZWxheSk7cmV0dXJuIGR9ZnVuY3Rpb24gY2EoYSl7cmV0dXJuIGguYXJyKGEpP0EuYXBwbHkodGhpcyxhKTpRW2FdfWZ1bmN0aW9uIGRhKGEsYyl7dmFyIGQ7cmV0dXJuIGEudHdlZW5zLm1hcChmdW5jdGlvbihiKXtiPWJhKGIsYyk7dmFyIGY9Yi52YWx1ZSxlPUsoYy50YXJnZXQsYS5uYW1lKSxrPWQ/ZC50by5vcmlnaW5hbDplLGs9aC5hcnIoZik/ZlswXTprLHc9TChoLmFycihmKT9mWzFdOmYsayksZT15KHcpfHx5KGspfHx5KGUpO2IuZnJvbT1PKGssZSk7Yi50bz1PKHcsZSk7Yi5zdGFydD1kP2QuZW5kOmEub2Zmc2V0O2IuZW5kPWIuc3RhcnQrYi5kZWxheStiLmR1cmF0aW9uO2IuZWFzaW5nPWNhKGIuZWFzaW5nKTtiLmVsYXN0aWNpdHk9KDFFMy1NYXRoLm1pbihNYXRoLm1heChiLmVsYXN0aWNpdHksMSksOTk5KSkvXG4xRTM7Yi5pc1BhdGg9aC5wdGgoZik7Yi5pc0NvbG9yPWguY29sKGIuZnJvbS5vcmlnaW5hbCk7Yi5pc0NvbG9yJiYoYi5yb3VuZD0xKTtyZXR1cm4gZD1ifSl9ZnVuY3Rpb24gZWEoYSxjKXtyZXR1cm4gcihwKGEubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBjLm1hcChmdW5jdGlvbihiKXt2YXIgYz1KKGEudGFyZ2V0LGIubmFtZSk7aWYoYyl7dmFyIGQ9ZGEoYixhKTtiPXt0eXBlOmMscHJvcGVydHk6Yi5uYW1lLGFuaW1hdGFibGU6YSx0d2VlbnM6ZCxkdXJhdGlvbjpkW2QubGVuZ3RoLTFdLmVuZCxkZWxheTpkWzBdLmRlbGF5fX1lbHNlIGI9dm9pZCAwO3JldHVybiBifSl9KSksZnVuY3Rpb24oYSl7cmV0dXJuIWgudW5kKGEpfSl9ZnVuY3Rpb24gUihhLGMsZCxiKXt2YXIgZj1cImRlbGF5XCI9PT1hO3JldHVybiBjLmxlbmd0aD8oZj9NYXRoLm1pbjpNYXRoLm1heCkuYXBwbHkoTWF0aCxjLm1hcChmdW5jdGlvbihiKXtyZXR1cm4gYlthXX0pKTpmP2IuZGVsYXk6ZC5vZmZzZXQrYi5kZWxheStcbmIuZHVyYXRpb259ZnVuY3Rpb24gZmEoYSl7dmFyIGM9RChnYSxhKSxkPUQoUyxhKSxiPVooYS50YXJnZXRzKSxmPVtdLGU9eihjLGQpLGs7Zm9yKGsgaW4gYSllLmhhc093blByb3BlcnR5KGspfHxcInRhcmdldHNcIj09PWt8fGYucHVzaCh7bmFtZTprLG9mZnNldDplLm9mZnNldCx0d2VlbnM6YWEoYVtrXSxkKX0pO2E9ZWEoYixmKTtyZXR1cm4geihjLHtjaGlsZHJlbjpbXSxhbmltYXRhYmxlczpiLGFuaW1hdGlvbnM6YSxkdXJhdGlvbjpSKFwiZHVyYXRpb25cIixhLGMsZCksZGVsYXk6UihcImRlbGF5XCIsYSxjLGQpfSl9ZnVuY3Rpb24gcShhKXtmdW5jdGlvbiBjKCl7cmV0dXJuIHdpbmRvdy5Qcm9taXNlJiZuZXcgUHJvbWlzZShmdW5jdGlvbihhKXtyZXR1cm4gcD1hfSl9ZnVuY3Rpb24gZChhKXtyZXR1cm4gZy5yZXZlcnNlZD9nLmR1cmF0aW9uLWE6YX1mdW5jdGlvbiBiKGEpe2Zvcih2YXIgYj0wLGM9e30sZD1nLmFuaW1hdGlvbnMsZj1kLmxlbmd0aDtiPGY7KXt2YXIgZT1kW2JdLFxuaz1lLmFuaW1hdGFibGUsaD1lLnR3ZWVucyxuPWgubGVuZ3RoLTEsbD1oW25dO24mJihsPXIoaCxmdW5jdGlvbihiKXtyZXR1cm4gYTxiLmVuZH0pWzBdfHxsKTtmb3IodmFyIGg9TWF0aC5taW4oTWF0aC5tYXgoYS1sLnN0YXJ0LWwuZGVsYXksMCksbC5kdXJhdGlvbikvbC5kdXJhdGlvbix3PWlzTmFOKGgpPzE6bC5lYXNpbmcoaCxsLmVsYXN0aWNpdHkpLGg9bC50by5zdHJpbmdzLHA9bC5yb3VuZCxuPVtdLG09dm9pZCAwLG09bC50by5udW1iZXJzLmxlbmd0aCx0PTA7dDxtO3QrKyl7dmFyIHg9dm9pZCAwLHg9bC50by5udW1iZXJzW3RdLHE9bC5mcm9tLm51bWJlcnNbdF0seD1sLmlzUGF0aD9ZKGwudmFsdWUsdyp4KTpxK3cqKHgtcSk7cCYmKGwuaXNDb2xvciYmMjx0fHwoeD1NYXRoLnJvdW5kKHgqcCkvcCkpO24ucHVzaCh4KX1pZihsPWgubGVuZ3RoKWZvcihtPWhbMF0sdz0wO3c8bDt3KyspcD1oW3crMV0sdD1uW3ddLGlzTmFOKHQpfHwobT1wP20rKHQrcCk6bSsodCtcIiBcIikpO1xuZWxzZSBtPW5bMF07aGFbZS50eXBlXShrLnRhcmdldCxlLnByb3BlcnR5LG0sYyxrLmlkKTtlLmN1cnJlbnRWYWx1ZT1tO2IrK31pZihiPU9iamVjdC5rZXlzKGMpLmxlbmd0aClmb3IoZD0wO2Q8YjtkKyspSHx8KEg9RShkb2N1bWVudC5ib2R5LFwidHJhbnNmb3JtXCIpP1widHJhbnNmb3JtXCI6XCItd2Via2l0LXRyYW5zZm9ybVwiKSxnLmFuaW1hdGFibGVzW2RdLnRhcmdldC5zdHlsZVtIXT1jW2RdLmpvaW4oXCIgXCIpO2cuY3VycmVudFRpbWU9YTtnLnByb2dyZXNzPWEvZy5kdXJhdGlvbioxMDB9ZnVuY3Rpb24gZihhKXtpZihnW2FdKWdbYV0oZyl9ZnVuY3Rpb24gZSgpe2cucmVtYWluaW5nJiYhMCE9PWcucmVtYWluaW5nJiZnLnJlbWFpbmluZy0tfWZ1bmN0aW9uIGsoYSl7dmFyIGs9Zy5kdXJhdGlvbixuPWcub2Zmc2V0LHc9bitnLmRlbGF5LHI9Zy5jdXJyZW50VGltZSx4PWcucmV2ZXJzZWQscT1kKGEpO2lmKGcuY2hpbGRyZW4ubGVuZ3RoKXt2YXIgdT1nLmNoaWxkcmVuLHY9dS5sZW5ndGg7XG5pZihxPj1nLmN1cnJlbnRUaW1lKWZvcih2YXIgRz0wO0c8djtHKyspdVtHXS5zZWVrKHEpO2Vsc2UgZm9yKDt2LS07KXVbdl0uc2VlayhxKX1pZihxPj13fHwhaylnLmJlZ2FufHwoZy5iZWdhbj0hMCxmKFwiYmVnaW5cIikpLGYoXCJydW5cIik7aWYocT5uJiZxPGspYihxKTtlbHNlIGlmKHE8PW4mJjAhPT1yJiYoYigwKSx4JiZlKCkpLHE+PWsmJnIhPT1rfHwhayliKGspLHh8fGUoKTtmKFwidXBkYXRlXCIpO2E+PWsmJihnLnJlbWFpbmluZz8odD1oLFwiYWx0ZXJuYXRlXCI9PT1nLmRpcmVjdGlvbiYmKGcucmV2ZXJzZWQ9IWcucmV2ZXJzZWQpKTooZy5wYXVzZSgpLGcuY29tcGxldGVkfHwoZy5jb21wbGV0ZWQ9ITAsZihcImNvbXBsZXRlXCIpLFwiUHJvbWlzZVwiaW4gd2luZG93JiYocCgpLG09YygpKSkpLGw9MCl9YT12b2lkIDA9PT1hP3t9OmE7dmFyIGgsdCxsPTAscD1udWxsLG09YygpLGc9ZmEoYSk7Zy5yZXNldD1mdW5jdGlvbigpe3ZhciBhPWcuZGlyZWN0aW9uLGM9Zy5sb29wO2cuY3VycmVudFRpbWU9XG4wO2cucHJvZ3Jlc3M9MDtnLnBhdXNlZD0hMDtnLmJlZ2FuPSExO2cuY29tcGxldGVkPSExO2cucmV2ZXJzZWQ9XCJyZXZlcnNlXCI9PT1hO2cucmVtYWluaW5nPVwiYWx0ZXJuYXRlXCI9PT1hJiYxPT09Yz8yOmM7YigwKTtmb3IoYT1nLmNoaWxkcmVuLmxlbmd0aDthLS07KWcuY2hpbGRyZW5bYV0ucmVzZXQoKX07Zy50aWNrPWZ1bmN0aW9uKGEpe2g9YTt0fHwodD1oKTtrKChsK2gtdCkqcS5zcGVlZCl9O2cuc2Vlaz1mdW5jdGlvbihhKXtrKGQoYSkpfTtnLnBhdXNlPWZ1bmN0aW9uKCl7dmFyIGE9di5pbmRleE9mKGcpOy0xPGEmJnYuc3BsaWNlKGEsMSk7Zy5wYXVzZWQ9ITB9O2cucGxheT1mdW5jdGlvbigpe2cucGF1c2VkJiYoZy5wYXVzZWQ9ITEsdD0wLGw9ZChnLmN1cnJlbnRUaW1lKSx2LnB1c2goZyksQnx8aWEoKSl9O2cucmV2ZXJzZT1mdW5jdGlvbigpe2cucmV2ZXJzZWQ9IWcucmV2ZXJzZWQ7dD0wO2w9ZChnLmN1cnJlbnRUaW1lKX07Zy5yZXN0YXJ0PWZ1bmN0aW9uKCl7Zy5wYXVzZSgpO1xuZy5yZXNldCgpO2cucGxheSgpfTtnLmZpbmlzaGVkPW07Zy5yZXNldCgpO2cuYXV0b3BsYXkmJmcucGxheSgpO3JldHVybiBnfXZhciBnYT17dXBkYXRlOnZvaWQgMCxiZWdpbjp2b2lkIDAscnVuOnZvaWQgMCxjb21wbGV0ZTp2b2lkIDAsbG9vcDoxLGRpcmVjdGlvbjpcIm5vcm1hbFwiLGF1dG9wbGF5OiEwLG9mZnNldDowfSxTPXtkdXJhdGlvbjoxRTMsZGVsYXk6MCxlYXNpbmc6XCJlYXNlT3V0RWxhc3RpY1wiLGVsYXN0aWNpdHk6NTAwLHJvdW5kOjB9LFc9XCJ0cmFuc2xhdGVYIHRyYW5zbGF0ZVkgdHJhbnNsYXRlWiByb3RhdGUgcm90YXRlWCByb3RhdGVZIHJvdGF0ZVogc2NhbGUgc2NhbGVYIHNjYWxlWSBzY2FsZVogc2tld1ggc2tld1kgcGVyc3BlY3RpdmVcIi5zcGxpdChcIiBcIiksSCxoPXthcnI6ZnVuY3Rpb24oYSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoYSl9LG9iajpmdW5jdGlvbihhKXtyZXR1cm4tMTxPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkuaW5kZXhPZihcIk9iamVjdFwiKX0sXG5wdGg6ZnVuY3Rpb24oYSl7cmV0dXJuIGgub2JqKGEpJiZhLmhhc093blByb3BlcnR5KFwidG90YWxMZW5ndGhcIil9LHN2ZzpmdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnR9LGRvbTpmdW5jdGlvbihhKXtyZXR1cm4gYS5ub2RlVHlwZXx8aC5zdmcoYSl9LHN0cjpmdW5jdGlvbihhKXtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGF9LGZuYzpmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYX0sdW5kOmZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYX0saGV4OmZ1bmN0aW9uKGEpe3JldHVybi8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGEpfSxyZ2I6ZnVuY3Rpb24oYSl7cmV0dXJuL15yZ2IvLnRlc3QoYSl9LGhzbDpmdW5jdGlvbihhKXtyZXR1cm4vXmhzbC8udGVzdChhKX0sY29sOmZ1bmN0aW9uKGEpe3JldHVybiBoLmhleChhKXx8aC5yZ2IoYSl8fGguaHNsKGEpfX0sQT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxcbmQsYil7cmV0dXJuKCgoMS0zKmIrMypkKSphKygzKmItNipkKSkqYSszKmQpKmF9cmV0dXJuIGZ1bmN0aW9uKGMsZCxiLGYpe2lmKDA8PWMmJjE+PWMmJjA8PWImJjE+PWIpe3ZhciBlPW5ldyBGbG9hdDMyQXJyYXkoMTEpO2lmKGMhPT1kfHxiIT09Zilmb3IodmFyIGs9MDsxMT5rOysrayllW2tdPWEoLjEqayxjLGIpO3JldHVybiBmdW5jdGlvbihrKXtpZihjPT09ZCYmYj09PWYpcmV0dXJuIGs7aWYoMD09PWspcmV0dXJuIDA7aWYoMT09PWspcmV0dXJuIDE7Zm9yKHZhciBoPTAsbD0xOzEwIT09bCYmZVtsXTw9azsrK2wpaCs9LjE7LS1sO3ZhciBsPWgrKGstZVtsXSkvKGVbbCsxXS1lW2xdKSouMSxuPTMqKDEtMypiKzMqYykqbCpsKzIqKDMqYi02KmMpKmwrMypjO2lmKC4wMDE8PW4pe2ZvcihoPTA7ND5oOysraCl7bj0zKigxLTMqYiszKmMpKmwqbCsyKigzKmItNipjKSpsKzMqYztpZigwPT09bilicmVhazt2YXIgbT1hKGwsYyxiKS1rLGw9bC1tL259az1sfWVsc2UgaWYoMD09PVxubilrPWw7ZWxzZXt2YXIgbD1oLGg9aCsuMSxnPTA7ZG8gbT1sKyhoLWwpLzIsbj1hKG0sYyxiKS1rLDA8bj9oPW06bD1tO3doaWxlKDFlLTc8TWF0aC5hYnMobikmJjEwPisrZyk7az1tfXJldHVybiBhKGssZCxmKX19fX0oKSxRPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe3JldHVybiAwPT09YXx8MT09PWE/YTotTWF0aC5wb3coMiwxMCooYS0xKSkqTWF0aC5zaW4oMiooYS0xLWIvKDIqTWF0aC5QSSkqTWF0aC5hc2luKDEpKSpNYXRoLlBJL2IpfXZhciBjPVwiUXVhZCBDdWJpYyBRdWFydCBRdWludCBTaW5lIEV4cG8gQ2lyYyBCYWNrIEVsYXN0aWNcIi5zcGxpdChcIiBcIiksZD17SW46W1suNTUsLjA4NSwuNjgsLjUzXSxbLjU1LC4wNTUsLjY3NSwuMTldLFsuODk1LC4wMywuNjg1LC4yMl0sWy43NTUsLjA1LC44NTUsLjA2XSxbLjQ3LDAsLjc0NSwuNzE1XSxbLjk1LC4wNSwuNzk1LC4wMzVdLFsuNiwuMDQsLjk4LC4zMzVdLFsuNiwtLjI4LC43MzUsLjA0NV0sYV0sT3V0OltbLjI1LFxuLjQ2LC40NSwuOTRdLFsuMjE1LC42MSwuMzU1LDFdLFsuMTY1LC44NCwuNDQsMV0sWy4yMywxLC4zMiwxXSxbLjM5LC41NzUsLjU2NSwxXSxbLjE5LDEsLjIyLDFdLFsuMDc1LC44MiwuMTY1LDFdLFsuMTc1LC44ODUsLjMyLDEuMjc1XSxmdW5jdGlvbihiLGMpe3JldHVybiAxLWEoMS1iLGMpfV0sSW5PdXQ6W1suNDU1LC4wMywuNTE1LC45NTVdLFsuNjQ1LC4wNDUsLjM1NSwxXSxbLjc3LDAsLjE3NSwxXSxbLjg2LDAsLjA3LDFdLFsuNDQ1LC4wNSwuNTUsLjk1XSxbMSwwLDAsMV0sWy43ODUsLjEzNSwuMTUsLjg2XSxbLjY4LC0uNTUsLjI2NSwxLjU1XSxmdW5jdGlvbihiLGMpe3JldHVybi41PmI/YSgyKmIsYykvMjoxLWEoLTIqYisyLGMpLzJ9XX0sYj17bGluZWFyOkEoLjI1LC4yNSwuNzUsLjc1KX0sZj17fSxlO2ZvcihlIGluIGQpZi50eXBlPWUsZFtmLnR5cGVdLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGQsZil7YltcImVhc2VcIithLnR5cGUrY1tmXV09aC5mbmMoZCk/XG5kOkEuYXBwbHkoJGpzY29tcCR0aGlzLGQpfX0oZikpLGY9e3R5cGU6Zi50eXBlfTtyZXR1cm4gYn0oKSxoYT17Y3NzOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gYS5zdHlsZVtjXT1kfSxhdHRyaWJ1dGU6ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBhLnNldEF0dHJpYnV0ZShjLGQpfSxvYmplY3Q6ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBhW2NdPWR9LHRyYW5zZm9ybTpmdW5jdGlvbihhLGMsZCxiLGYpe2JbZl18fChiW2ZdPVtdKTtiW2ZdLnB1c2goYytcIihcIitkK1wiKVwiKX19LHY9W10sQj0wLGlhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe0I9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGMpfWZ1bmN0aW9uIGMoYyl7dmFyIGI9di5sZW5ndGg7aWYoYil7Zm9yKHZhciBkPTA7ZDxiOyl2W2RdJiZ2W2RdLnRpY2soYyksZCsrO2EoKX1lbHNlIGNhbmNlbEFuaW1hdGlvbkZyYW1lKEIpLEI9MH1yZXR1cm4gYX0oKTtxLnZlcnNpb249XCIyLjIuMFwiO3Euc3BlZWQ9MTtxLnJ1bm5pbmc9djtxLnJlbW92ZT1cbmZ1bmN0aW9uKGEpe2E9UChhKTtmb3IodmFyIGM9di5sZW5ndGg7Yy0tOylmb3IodmFyIGQ9dltjXSxiPWQuYW5pbWF0aW9ucyxmPWIubGVuZ3RoO2YtLTspdShhLGJbZl0uYW5pbWF0YWJsZS50YXJnZXQpJiYoYi5zcGxpY2UoZiwxKSxiLmxlbmd0aHx8ZC5wYXVzZSgpKX07cS5nZXRWYWx1ZT1LO3EucGF0aD1mdW5jdGlvbihhLGMpe3ZhciBkPWguc3RyKGEpP2UoYSlbMF06YSxiPWN8fDEwMDtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJue2VsOmQscHJvcGVydHk6YSx0b3RhbExlbmd0aDpOKGQpKihiLzEwMCl9fX07cS5zZXREYXNob2Zmc2V0PWZ1bmN0aW9uKGEpe3ZhciBjPU4oYSk7YS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsYyk7cmV0dXJuIGN9O3EuYmV6aWVyPUE7cS5lYXNpbmdzPVE7cS50aW1lbGluZT1mdW5jdGlvbihhKXt2YXIgYz1xKGEpO2MucGF1c2UoKTtjLmR1cmF0aW9uPTA7Yy5hZGQ9ZnVuY3Rpb24oZCl7Yy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuYmVnYW49XG4hMDthLmNvbXBsZXRlZD0hMH0pO20oZCkuZm9yRWFjaChmdW5jdGlvbihiKXt2YXIgZD16KGIsRChTLGF8fHt9KSk7ZC50YXJnZXRzPWQudGFyZ2V0c3x8YS50YXJnZXRzO2I9Yy5kdXJhdGlvbjt2YXIgZT1kLm9mZnNldDtkLmF1dG9wbGF5PSExO2QuZGlyZWN0aW9uPWMuZGlyZWN0aW9uO2Qub2Zmc2V0PWgudW5kKGUpP2I6TChlLGIpO2MuYmVnYW49ITA7Yy5jb21wbGV0ZWQ9ITA7Yy5zZWVrKGQub2Zmc2V0KTtkPXEoZCk7ZC5iZWdhbj0hMDtkLmNvbXBsZXRlZD0hMDtkLmR1cmF0aW9uPmImJihjLmR1cmF0aW9uPWQuZHVyYXRpb24pO2MuY2hpbGRyZW4ucHVzaChkKX0pO2Muc2VlaygwKTtjLnJlc2V0KCk7Yy5hdXRvcGxheSYmYy5yZXN0YXJ0KCk7cmV0dXJuIGN9O3JldHVybiBjfTtxLnJhbmRvbT1mdW5jdGlvbihhLGMpe3JldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKGMtYSsxKSkrYX07cmV0dXJuIHF9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5pbWVqcy9hbmltZS5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEFjdGl2ZSBjb2xvci5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdhY3RpdmUtY29sb3InLCB7XG4gIGRlcGVuZGVuY2llczogWydtYXRlcmlhbCddLFxuXG4gIHNjaGVtYToge1xuICAgIGFjdGl2ZToge2RlZmF1bHQ6IGZhbHNlfSxcbiAgICBjb2xvcjoge2RlZmF1bHQ6ICcjZmZmZmZmJ31cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0Q29sb3IgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnbWF0ZXJpYWwnKS5jb2xvcjtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5hY3RpdmUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbWF0ZXJpYWwnLCB7J2NvbG9yJzogdGhpcy5kYXRhLmNvbG9yLCAnb3BhY2l0eSc6IDF9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdtYXRlcmlhbCcsICdjb2xvcicsIHRoaXMuZGVmYXVsdENvbG9yKTtcbiAgICAgIGlmIChlbC5jb21wb25lbnRzLmFuaW1hdGlvbl9fbW91c2VsZWF2ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgZWwuZW1pdCgnbW91c2VsZWF2ZScsIG51bGwsIGZhbHNlKTsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxufSk7XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnYWN0aXZlLXRleHQtY29sb3InLCB7XG4gIGRlcGVuZGVuY2llczogWyd0ZXh0J10sXG5cbiAgc2NoZW1hOiB7XG4gICAgYWN0aXZlOiB7ZGVmYXVsdDogZmFsc2V9LFxuICAgIGNvbG9yOiB7ZGVmYXVsdDogJyMzMzMnfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRDb2xvciA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCd0ZXh0JykuY29sb3I7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAodGhpcy5kYXRhLmFjdGl2ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0ZXh0JywgJ2NvbG9yJywgdGhpcy5kYXRhLmNvbG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0ZXh0JywgJ2NvbG9yJywgdGhpcy5kZWZhdWx0Q29sb3IpO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvYWN0aXZlLWNvbG9yLmpzIiwiQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdhbmFseXNlcicsIHtcbiAgZGVwZW5kZW5jaWVzOiBbJ2F1ZGlvYW5hbHlzZXInXSxcbiAgc2NoZW1hOiB7XG4gICAgaGVpZ2h0OiB7ZGVmYXVsdDogMS4wfSxcbiAgICB0aGlja25lc3M6IHtkZWZhdWx0OiAwLjF9LFxuICAgIHNlcGFyYXRpb246IHtkZWZhdWx0OiAwLjN9LFxuICAgIHNjYWxlOiB7ZGVmYXVsdDogNC4wfSxcbiAgICBtaXJyb3I6IHtkZWZhdWx0OiAzfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuYWx5c2VyID0gdGhpcy5lbC5jb21wb25lbnRzLmF1ZGlvYW5hbHlzZXI7XG4gICAgdGhpcy5jb2x1bW5zID0gbnVsbDtcbiAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmVsLnNjZW5lRWwuc3lzdGVtcy5tYXRlcmlhbHMuYmxhY2s7XG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFuYWx5c2VyLmRhdGEuZmZ0U2l6ZTsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBzaWRlID0gMDsgc2lkZSA8IDI7IHNpZGUrKykge1xuICAgICAgICB2YXIgY29sdW1uID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgdGhpcy5lbC5vYmplY3QzRC5hZGQoY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb2x1bW5zID0gdGhpcy5lbC5vYmplY3QzRC5jaGlsZHJlbjtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY29sdW1uc1tpXS5wb3NpdGlvbi54ID0gKChpICUgMikgKiAyIC0gMSkgKiB0aGlzLmRhdGEubWlycm9yO1xuICAgICAgdGhpcy5jb2x1bW5zW2ldLnBvc2l0aW9uLnogPSB6O1xuICAgICAgdGhpcy5jb2x1bW5zW2ldLnNjYWxlLnNldCh0aGlzLmRhdGEudGhpY2tuZXNzLCB0aGlzLmRhdGEuaGVpZ2h0LCB0aGlzLmRhdGEudGhpY2tuZXNzKTtcbiAgICAgIHogLT0gdGhpcy5kYXRhLnNlcGFyYXRpb247XG4gICAgfVxuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdjtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5kYXRhLmhlaWdodDtcbiAgICB2YXIgbiA9IHRoaXMuY29sdW1ucy5sZW5ndGggLyAyO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHYgPSBoZWlnaHQgKyB0aGlzLmFuYWx5c2VyLmxldmVsc1tpXSAvIDI1Ni4wICogdGhpcy5kYXRhLnNjYWxlO1xuICAgICAgdGhpcy5jb2x1bW5zW2kgKiAyICsgMF0uc2NhbGUueSA9IHY7XG4gICAgICB0aGlzLmNvbHVtbnNbaSAqIDIgKyAxXS5zY2FsZS55ID0gdjtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvYW5hbHl6ZXIuanMiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIExvYWQgYmVhdCBkYXRhIChhbGwgdGhlIGJlYXRzIGFuZCBzdWNoKS5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdiZWF0LWxvYWRlcicsIHtcbiAgc2NoZW1hOiB7XG4gICAgY2hhbGxlbmdlSWQ6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgZGlmZmljdWx0eToge3R5cGU6ICdzdHJpbmcnfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kYXRhLmNoYWxsZW5nZUlkIHx8ICF0aGlzLmRhdGEuZGlmZmljdWx0eSkgeyByZXR1cm47IH1cbiAgICB0aGlzLmxvYWRCZWF0cyh0aGlzLmRhdGEuY2hhbGxlbmdlSWQsIHRoaXMuZGF0YS5kaWZmaWN1bHR5KTtcbiAgfSxcblxuICAvKipcbiAgICogWEhSLlxuICAgKi9cbiAgbG9hZEJlYXRzOiBmdW5jdGlvbiAoaWQsIGRpZmZpY3VsdHkpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciB4aHI7XG5cbiAgICAvLyBMb2FkIGJlYXRzLlxuICAgIGxldCB1cmwgPSB1dGlscy5nZXRTM0ZpbGVVcmwodGhpcy5kYXRhLmNoYWxsZW5nZUlkLCBgJHt0aGlzLmRhdGEuZGlmZmljdWx0eX0uanNvbmApO1xuICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGVsLmVtaXQoJ2JlYXRsb2FkZXJzdGFydCcpO1xuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyAke3VybH0uLi5gKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlQmVhdHMoSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgfSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSxcblxuICAvKipcbiAgICogVE9ETzogTG9hZCB0aGUgYmVhdCBkYXRhIGludG8gdGhlIGdhbWUuXG4gICAqL1xuICBoYW5kbGVCZWF0czogZnVuY3Rpb24gKGJlYXREYXRhKSB7XG4gICAgdGhpcy5lbC5zY2VuZUVsLmVtaXQoJ2JlYXRsb2FkZXJmaW5pc2gnLCBiZWF0RGF0YSwgZmFsc2UpO1xuICAgIGNvbnNvbGUubG9nKCdGaW5pc2hlZCBsb2FkaW5nIGNoYWxsZW5nZSBkYXRhLicpO1xuICB9LFxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVF1ZXJ5UGFyYW0odXJpLCBrZXksIHZhbHVlKSB7XG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJyhbPyZdKScgKyBrZXkgKyAnPS4qPygmfCQpJywgJ2knKTtcbiAgdmFyIHNlcGFyYXRvciA9IHVyaS5pbmRleE9mKCc/JykgIT09IC0xID8gJyYnIDogJz8nO1xuICBpZiAodXJpLm1hdGNoKHJlKSkge1xuICAgIHJldHVybiB1cmkucmVwbGFjZShyZSwgJyQxJyArIGtleSArICc9JyArIHZhbHVlICsgJyQyJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVyaSArIHNlcGFyYXRvciArIGtleSArICc9JyArIHZhbHVlO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9iZWF0LWxvYWRlci5qcyIsIkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnY29uc29sZS1zaG9ydGN1dHMnLCB7XG4gIHBsYXk6IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cuJCA9IHZhbCA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHZhbCk7XG4gICAgd2luZG93LiQkID0gdmFsID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodmFsKTtcbiAgICB3aW5kb3cuJCQkID0gdmFsID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFske3ZhbH1dYCkuZ2V0QXR0cmlidXRlKHZhbCk7XG4gICAgd2luZG93LiQkJCQgPSB2YWwgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgWyR7dmFsfV1gKS5jb21wb25lbnRzW3ZhbF07XG4gICAgd2luZG93LnNjZW5lID0gdGhpcy5lbDtcbiAgICB3aW5kb3cuc3RhdGUgPSB0aGlzLmVsLnN5c3RlbXMuc3RhdGUuc3RhdGU7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvY29uc29sZS1zaG9ydGN1dHMuanMiLCIvKipcbiAqIEN1cnNvciBtZXNoIHRvIHNob3cgYXQgaW50ZXJzZWN0aW9uIHBvaW50IHdpdGggcmVzcGVjdGl2ZSBoYW5kLlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2N1cnNvci1tZXNoJywge1xuICBzY2hlbWE6IHtcbiAgICBjdXJzb3JFbDoge3R5cGU6ICdzZWxlY3Rvcid9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2NlbmVQaXZvdEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5lUGl2b3QnKTtcbiAgfSxcblxuICB0aWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnNvcjtcbiAgICB2YXIgY3Vyc29yRWwgPSB0aGlzLmRhdGEuY3Vyc29yRWw7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uO1xuICAgIHZhciBpbnRlcnNlY3RlZEVsO1xuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludDtcbiAgICB2YXIgb2JqZWN0M0QgPSB0aGlzLmVsLm9iamVjdDNEO1xuICAgIHZhciBzY2VuZVBpdm90RWwgPSB0aGlzLnNjZW5lUGl2b3RFbDtcblxuICAgIGN1cnNvciA9IGN1cnNvckVsLmNvbXBvbmVudHMuY3Vyc29yO1xuICAgIGlmICghY3Vyc29yKSB7IHJldHVybjsgfVxuXG4gICAgLy8gTG9vayBmb3IgdmFsaWQgaW50ZXJzZWN0aW9uIHRhcmdldC5cbiAgICBpbnRlcnNlY3RlZEVsID0gY3Vyc29yRWwuY29tcG9uZW50cy5jdXJzb3IuaW50ZXJzZWN0ZWRFbDtcbiAgICBpZiAoaW50ZXJzZWN0ZWRFbCkge1xuICAgICAgZWwub2JqZWN0M0QudmlzaWJsZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLm9iamVjdDNELnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgY3Vyc29yIG1lc2guXG4gICAgaW50ZXJzZWN0aW9uID0gY3Vyc29yRWwuY29tcG9uZW50cy5yYXljYXN0ZXIuZ2V0SW50ZXJzZWN0aW9uKGludGVyc2VjdGVkRWwpO1xuICAgIGVsLm9iamVjdDNELnBvc2l0aW9uLmNvcHkoaW50ZXJzZWN0aW9uLnBvaW50KTtcblxuICAgIGlmIChzY2VuZVBpdm90RWwpIHtcbiAgICAgIGVsLm9iamVjdDNELnJvdGF0aW9uLmNvcHkoc2NlbmVQaXZvdEVsLm9iamVjdDNELnJvdGF0aW9uKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvY3Vyc29yLW1lc2guanMiLCIvKipcbiAqIEtleWJvYXJkIGJpbmRpbmdzIHRvIGNvbnRyb2wgY29udHJvbGxlci5cbiAqIFBvc2l0aW9uIGNvbnRyb2xsZXIgaW4gZnJvbnQgb2YgY2FtZXJhLlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2RlYnVnLWNvbnRyb2xsZXInLCB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJpbWFyeUhhbmQ7XG4gICAgdmFyIHNlY29uZGFyeUhhbmQ7XG5cbiAgICBpZiAoIUFGUkFNRS51dGlscy5nZXRVcmxQYXJhbWV0ZXIoJ2RlYnVnJykpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zb2xlLmxvZygnJWMgZGVidWctY29udHJvbGxlciBlbmFibGVkICcsICdiYWNrZ3JvdW5kOiAjMTExOyBjb2xvcjogcmVkJyk7XG5cbiAgICB0aGlzLmlzQ2xvbmluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNEZWxldGluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmlnZ2VyRG93biA9IGZhbHNlO1xuXG4gICAgcHJpbWFyeUhhbmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmlnaHRIYW5kJyk7XG4gICAgc2Vjb25kYXJ5SGFuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsZWZ0SGFuZCcpO1xuXG4gICAgaWYgKEFGUkFNRS51dGlscy5nZXRVcmxQYXJhbWV0ZXIoJ2RlYnVnJykgPT09ICdvY3VsdXMnKSB7XG4gICAgICBwcmltYXJ5SGFuZC5lbWl0KCdjb250cm9sbGVyY29ubmVjdGVkJywge25hbWU6ICdvY3VsdXMtdG91Y2gtY29udHJvbHMnfSk7XG4gICAgICBzZWNvbmRhcnlIYW5kLmVtaXQoJ2NvbnRyb2xsZXJjb25uZWN0ZWQnLCB7bmFtZTogJ29jdWx1cy10b3VjaC1jb250cm9scyd9KTtcbiAgICAgIHByaW1hcnlIYW5kLnNldEF0dHJpYnV0ZSgnY29udHJvbGxlcicsICdjb250cm9sbGVyVHlwZScsICdvY3VsdXMtdG91Y2gtY29udHJvbHMnKTtcbiAgICAgIHNlY29uZGFyeUhhbmQuc2V0QXR0cmlidXRlKCdjb250cm9sbGVyJywgJ2NvbnRyb2xsZXJUeXBlJywgJ29jdWx1cy10b3VjaC1jb250cm9scycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmltYXJ5SGFuZC5lbWl0KCdjb250cm9sbGVyY29ubmVjdGVkJywge25hbWU6ICd2aXZlLWNvbnRyb2xzJ30pO1xuICAgICAgc2Vjb25kYXJ5SGFuZC5lbWl0KCdjb250cm9sbGVyY29ubmVjdGVkJywge25hbWU6ICd2aXZlLWNvbnRyb2xzJ30pO1xuICAgICAgcHJpbWFyeUhhbmQuc2V0QXR0cmlidXRlKCdjb250cm9sbGVyJywgJ2NvbnRyb2xsZXJUeXBlJywgJ3ZpdmUtY29udHJvbHMnKTtcbiAgICAgIHNlY29uZGFyeUhhbmQuc2V0QXR0cmlidXRlKCdjb250cm9sbGVyJywgJ2NvbnRyb2xsZXJUeXBlJywgJ3ZpdmUtY29udHJvbHMnKTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgcmF5Y2FzdGVyLlxuICAgIHRoaXMuZWwuZW1pdCgnZW50ZXItdnInLCBudWxsLCBmYWxzZSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZ0ID0+IHtcbiAgICAgIHZhciBwcmltYXJ5UG9zaXRpb247XG4gICAgICB2YXIgcHJpbWFyeVJvdGF0aW9uO1xuICAgICAgdmFyIHNlY29uZGFyeVBvc2l0aW9uO1xuICAgICAgdmFyIHNlY29uZGFyeVJvdGF0aW9uO1xuXG4gICAgICBpZiAoIWV2dC5zaGlmdEtleSkgeyByZXR1cm47IH1cblxuICAgICAgLy8gPHNwYWNlPiBmb3IgdHJpZ2dlci5cbiAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUcmlnZ2VyRG93bikge1xuICAgICAgICAgIHByaW1hcnlIYW5kLmVtaXQoJ3RyaWdnZXJ1cCcpO1xuICAgICAgICAgIHRoaXMuaXNUcmlnZ2VyRG93biA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW1hcnlIYW5kLmVtaXQoJ3RyaWdnZXJkb3duJyk7XG4gICAgICAgICAgdGhpcy5pc1RyaWdnZXJEb3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIDxxPiBmb3Igc2Vjb25kYXJ5IHRyaWdnZXIuXG4gICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDgxKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2Vjb25kYXJ5VHJpZ2dlckRvd24pIHtcbiAgICAgICAgICBzZWNvbmRhcnlIYW5kLmVtaXQoJ3RyaWdnZXJ1cCcpO1xuICAgICAgICAgIHRoaXMuaXNTZWNvbmRhcnlUcmlnZ2VyRG93biA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlY29uZGFyeUhhbmQuZW1pdCgndHJpZ2dlcmRvd24nKTtcbiAgICAgICAgICB0aGlzLmlzU2Vjb25kYXJ5VHJpZ2dlckRvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gPG4+IHNlY29uZGFyeSBncmlwLlxuICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSA3OCkge1xuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlHcmlwRG93bikge1xuICAgICAgICAgIHNlY29uZGFyeUhhbmQuZW1pdCgnZ3JpcHVwJyk7XG4gICAgICAgICAgdGhpcy5zZWNvbmRhcnlHcmlwRG93biA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlY29uZGFyeUhhbmQuZW1pdCgnZ3JpcGRvd24nKTtcbiAgICAgICAgICB0aGlzLnNlY29uZGFyeUdyaXBEb3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA8bT4gcHJpbWFyeSBncmlwLlxuICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSA3Nykge1xuICAgICAgICBpZiAodGhpcy5wcmltYXJ5R3JpcERvd24pIHtcbiAgICAgICAgICBwcmltYXJ5SGFuZC5lbWl0KCdncmlwdXAnKTtcbiAgICAgICAgICB0aGlzLnByaW1hcnlHcmlwRG93biA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW1hcnlIYW5kLmVtaXQoJ2dyaXBkb3duJyk7XG4gICAgICAgICAgdGhpcy5wcmltYXJ5R3JpcERvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1lbnUgYnV0dG9uIDwxPi5cbiAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gNDkpIHtcbiAgICAgICAgc2Vjb25kYXJ5SGFuZC5lbWl0KCdtZW51ZG93bicpO1xuICAgICAgfVxuXG4gICAgICAvLyBQb3NpdGlvbiBiaW5kaW5ncy5cbiAgICAgIGlmIChldnQuY3RybEtleSkge1xuICAgICAgICBzZWNvbmRhcnlQb3NpdGlvbiA9IHNlY29uZGFyeUhhbmQuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDcyKSB7IHNlY29uZGFyeVBvc2l0aW9uLnggLT0gMC4wMSB9ICAvLyBoLlxuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDc0KSB7IHNlY29uZGFyeVBvc2l0aW9uLnkgLT0gMC4wMSB9ICAvLyBqLlxuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDc1KSB7IHNlY29uZGFyeVBvc2l0aW9uLnkgKz0gMC4wMSB9ICAvLyBrLlxuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDc2KSB7IHNlY29uZGFyeVBvc2l0aW9uLnggKz0gMC4wMSB9ICAvLyBsLlxuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDU5IHx8IGV2dC5rZXlDb2RlID09PSAxODYpIHsgc2Vjb25kYXJ5UG9zaXRpb24ueiAtPSAwLjAxIH0gIC8vIDsuXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gMjIyKSB7IHNlY29uZGFyeVBvc2l0aW9uLnogKz0gMC4wMSB9ICAvLyA7LlxuICAgICAgICBzZWNvbmRhcnlIYW5kLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBBRlJBTUUudXRpbHMuY2xvbmUoc2Vjb25kYXJ5UG9zaXRpb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW1hcnlQb3NpdGlvbiA9IHByaW1hcnlIYW5kLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSA3MikgeyBwcmltYXJ5UG9zaXRpb24ueCAtPSAwLjAxIH0gIC8vIGguXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gNzQpIHsgcHJpbWFyeVBvc2l0aW9uLnkgLT0gMC4wMSB9ICAvLyBqLlxuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDc1KSB7IHByaW1hcnlQb3NpdGlvbi55ICs9IDAuMDEgfSAgLy8gay5cbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSA3NikgeyBwcmltYXJ5UG9zaXRpb24ueCArPSAwLjAxIH0gIC8vIGwuXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gNTkgfHwgZXZ0LmtleUNvZGUgPT09IDE4NikgeyBwcmltYXJ5UG9zaXRpb24ueiAtPSAwLjAxIH0gIC8vIDsuXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gMjIyKSB7IHByaW1hcnlQb3NpdGlvbi56ICs9IDAuMDEgfSAgLy8gOy5cbiAgICAgICAgcHJpbWFyeUhhbmQuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIEFGUkFNRS51dGlscy5jbG9uZShwcmltYXJ5UG9zaXRpb24pKTtcbiAgICAgIH1cblxuICAgICAgLy8gUm90YXRpb24gYmluZGluZ3MuXG4gICAgICBpZiAoZXZ0LmN0cmxLZXkpIHtcbiAgICAgICAgc2Vjb25kYXJ5Um90YXRpb24gPSBzZWNvbmRhcnlIYW5kLmdldEF0dHJpYnV0ZSgncm90YXRpb24nKTtcbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSA4OSkgeyBzZWNvbmRhcnlSb3RhdGlvbi54IC09IDEwIH0gIC8vIHkuXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gNzkpIHsgc2Vjb25kYXJ5Um90YXRpb24ueCArPSAxMCB9ICAvLyBvLlxuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDg1KSB7IHNlY29uZGFyeVJvdGF0aW9uLnkgLT0gMTAgfSAgLy8gdS5cbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSA3MykgeyBzZWNvbmRhcnlSb3RhdGlvbi55ICs9IDEwIH0gIC8vIGkuXG4gICAgICAgIHNlY29uZGFyeUhhbmQuc2V0QXR0cmlidXRlKCdyb3RhdGlvbicsIEFGUkFNRS51dGlscy5jbG9uZShzZWNvbmRhcnlSb3RhdGlvbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJpbWFyeVJvdGF0aW9uID0gcHJpbWFyeUhhbmQuZ2V0QXR0cmlidXRlKCdyb3RhdGlvbicpO1xuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDg5KSB7IHByaW1hcnlSb3RhdGlvbi54IC09IDEwIH0gIC8vIHkuXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gNzkpIHsgcHJpbWFyeVJvdGF0aW9uLnggKz0gMTAgfSAgLy8gby5cbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSA4NSkgeyBwcmltYXJ5Um90YXRpb24ueSAtPSAxMCB9ICAvLyB1LlxuICAgICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDczKSB7IHByaW1hcnlSb3RhdGlvbi55ICs9IDEwIH0gIC8vIGkuXG4gICAgICAgIHByaW1hcnlIYW5kLnNldEF0dHJpYnV0ZSgncm90YXRpb24nLCBBRlJBTUUudXRpbHMuY2xvbmUocHJpbWFyeVJvdGF0aW9uKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmltYXJ5SGFuZDtcbiAgICB2YXIgc2Vjb25kYXJ5SGFuZDtcblxuICAgIGlmICghQUZSQU1FLnV0aWxzLmdldFVybFBhcmFtZXRlcignZGVidWcnKSkgeyByZXR1cm47IH1cblxuICAgIHByaW1hcnlIYW5kID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JpZ2h0SGFuZCcpO1xuICAgIHNlY29uZGFyeUhhbmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVmdEhhbmQnKTtcblxuICAgIHNlY29uZGFyeUhhbmQub2JqZWN0M0QucG9zaXRpb24uc2V0KC0wLjIsIDEuNSwgLTAuNSk7XG4gICAgcHJpbWFyeUhhbmQub2JqZWN0M0QucG9zaXRpb24uc2V0KDAuMiwgMS41LCAtMC41KTtcbiAgICBzZWNvbmRhcnlIYW5kLnNldEF0dHJpYnV0ZSgncm90YXRpb24nLCB7eDogMzUsIHk6IDAsIHo6IDB9KTtcbiAgICBwcmltYXJ5SGFuZC5zZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJywge3g6IDM1LCB5OiAwLCB6OiAwfSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvZGVidWctY29udHJvbGxlci5qcyIsIi8qKlxuICogTG9nIGN1cnNvciBldmVudHMuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnZGVidWctY3Vyc29yJywge1xuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGV2dCA9PiB7XG4gICAgICB0aGlzLmxvZygnbW91c2VlbnRlcicsIGV2dC5kZXRhaWwuaW50ZXJzZWN0ZWRFbCwgJ2dyZWVuJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBldnQgPT4ge1xuICAgICAgdGhpcy5sb2coJ21vdXNlbGVhdmUnLCBldnQuZGV0YWlsLmludGVyc2VjdGVkRWwsICdyZWQnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldnQgPT4ge1xuICAgICAgdGhpcy5sb2coJ2NsaWNrJywgZXZ0LmRldGFpbC5pbnRlcnNlY3RlZEVsLCAnYmx1ZScpO1xuICAgIH0pO1xuICB9LFxuXG4gIGxvZzogZnVuY3Rpb24oZXZlbnQsIGludGVyc2VjdGVkRWwsIGNvbG9yKSB7XG4gICAgaWYgKGludGVyc2VjdGVkRWwuaWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAlY1ske2V2ZW50fV0gJHtpbnRlcnNlY3RlZEVsLmlkfWAsIGBjb2xvcjogJHtjb2xvcn1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYCVjWyR7ZXZlbnR9XWAsIGBjb2xvcjogJHtjb2xvcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGludGVyc2VjdGVkRWwpO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvZGVidWctY3Vyc29yLmpzIiwiY29uc3QgZXZlbnRzID0gW1xuICAndHJpZ2dlcmRvd24nLFxuICAnZ3JpcGRvd24nLFxuICAnYWJ1dHRvbmRvd24nLFxuICAnYmJ1dHRvbmRvd24nLFxuICAneGJ1dHRvbmRvd24nLFxuICAneWJ1dHRvbmRvd24nLFxuICAndHJhY2twYWRkb3duJ1xuXTtcblxuLyoqXG4gKiBTd2FwIGxlZnQgb3IgcmlnaHQtaGFuZGVkIG1vZGUuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnaGFuZC1zd2FwcGVyJywge1xuICBzY2hlbWE6IHtcbiAgICBlbmFibGVkOiB7ZGVmYXVsdDogZmFsc2V9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3dhcEhhbmQgPSB0aGlzLnN3YXBIYW5kLmJpbmQodGhpcyk7XG4gICAgZXZlbnRzLmZvckVhY2goZXZlbnQgID0+IHtcbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5zd2FwSGFuZCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc3dhcEhhbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gICAgLy8gSGFuZGxlZCB2aWEgc3RhdGUuXG4gICAgdGhpcy5lbC5zY2VuZUVsLmVtaXQoJ2FjdGl2ZWhhbmRzd2FwJywgbnVsbCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL2hhbmQtc3dhcHBlci5qcyIsIi8qKlxuICogVXBkYXRlIHdpbmRvdyB0aXRsZSBhbmQgaGlzdG9yeS5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdoaXN0b3J5Jywge1xuICBzY2hlbWE6IHtcbiAgICBjaGFsbGVuZ2VJZDoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICBzb25nTmFtZToge3R5cGU6ICdzdHJpbmcnfSxcbiAgICBzb25nU3ViTmFtZToge3R5cGU6ICdzdHJpbmcnfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgaGlzdG9yeS5wdXNoU3RhdGUoXG4gICAgICAnJyxcbiAgICAgIGRhdGEuc29uZ05hbWUsXG4gICAgICB1cGRhdGVRdWVyeVBhcmFtKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCAnY2hhbGxlbmdlJywgZGF0YS5jaGFsbGVuZ2VJZClcbiAgICApO1xuICAgIGRvY3VtZW50LnRpdGxlID0gYFN1cGVyIFNhYmVyIC0gJHtkYXRhLnNvbmdOYW1lfWA7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvaGlzdG9yeS5qcyIsIkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgna2V5Ym9hcmQtcmF5Y2FzdGFibGUnLCB7XG4gIGRlcGVuZGVuY2llczogWydzdXBlci1rZXlib2FyZCddLFxuXG4gIHBsYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBiaW5kLXRvZ2dsZV9fcmF5Y2FzdGFibGUgZm9yIHdoZW4gc2VhcmNoIGlzIGFjdGl2YXRlZC5cbiAgICB0aGlzLmVsLmNvbXBvbmVudHNbJ3N1cGVyLWtleWJvYXJkJ10ua2JJbWcuc2V0QXR0cmlidXRlKCdiaW5kLXRvZ2dsZV9fcmF5Y2FzdGFibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21lbnUuYWN0aXZlJyk7XG4gIH0sXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL2tleWJvYXJkLXJheWNhc3RhYmxlLmpzIiwiQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdsb2dvZmxpY2tlcicsIHtcclxuICBkZXBlbmRlbmNpZXM6IFsndGV4dCddLFxyXG5cclxuICBzY2hlbWE6IHtcclxuICAgIGRlbGF5OiB7ZGVmYXVsdDogMTAwMC4wfSxcclxuICB9LFxyXG5cclxuICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnNldE9mZiA9IHRoaXMuc2V0T2ZmLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnNldE9uID0gdGhpcy5zZXRPbi5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuZGVmYXVsdENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCkuc2V0U3R5bGUodGhpcy5lbC5jb21wb25lbnRzLnRleHQuZGF0YS5jb2xvcik7XHJcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCkuc2V0U3R5bGUoJyMwQTAyMjgnKTtcclxuICAgIHRoaXMuY29sb3JVbmlmb3JtID0gdGhpcy5lbC5jb21wb25lbnRzLnRleHQubWF0ZXJpYWwudW5pZm9ybXMuY29sb3IudmFsdWU7XHJcblxyXG4gICAgdGhpcy5zcGFya3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nb3NwYXJrcycpO1xyXG4gICAgdGhpcy5zcGFya1Bvc2l0aW9ucyA9IFtcclxuICAgICAge3Bvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLjEsIDApfSxcclxuICAgICAge3Bvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLjUsIDEuMiwgMCl9LFxyXG4gICAgICB7cG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEuMiwgMCl9XHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuc2V0T24oKTtcclxuICB9LFxyXG5cclxuICBzZXRPZmY6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY29sb3JVbmlmb3JtLnggPSB0aGlzLmNvbG9yLnI7XHJcbiAgICB0aGlzLmNvbG9yVW5pZm9ybS55ID0gdGhpcy5jb2xvci5nO1xyXG4gICAgdGhpcy5jb2xvclVuaWZvcm0ueiA9IHRoaXMuY29sb3IuYjtcclxuICAgIHRoaXMuY29sb3JVbmlmb3JtLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNwYXJrcy5lbWl0KCdsb2dvZmxpY2tlcicsXHJcbiAgICAgIHRoaXMuc3BhcmtQb3NpdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zcGFya1Bvc2l0aW9ucy5sZW5ndGgpXSxcclxuICAgICAgZmFsc2UpO1xyXG5cclxuICAgIHNldFRpbWVvdXQodGhpcy5zZXRPbixcclxuICAgICAgICAgICAgICAgNTAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApKTtcclxuICB9LFxyXG5cclxuICBzZXRPbjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5jb2xvclVuaWZvcm0ueCA9IHRoaXMuZGVmYXVsdENvbG9yLnI7XHJcbiAgICB0aGlzLmNvbG9yVW5pZm9ybS55ID0gdGhpcy5kZWZhdWx0Q29sb3IuZztcclxuICAgIHRoaXMuY29sb3JVbmlmb3JtLnogPSB0aGlzLmRlZmF1bHRDb2xvci5iO1xyXG4gICAgdGhpcy5jb2xvclVuaWZvcm0ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIHNldFRpbWVvdXQodGhpcy5zZXRPZmYsXHJcbiAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHRoaXMuZGF0YS5kZWxheSAqIDMgLyAxMCkgKyBNYXRoLnJhbmRvbSgpICogdGhpcy5kYXRhLmRlbGF5KSk7XHJcbiAgfVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvbG9nb2ZsaWNrZXIuanMiLCJBRlJBTUUucmVnaXN0ZXJTeXN0ZW0oJ21hdGVyaWFscycsIHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYmxhY2sgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7Y29sb3I6IDB4MDAwMDAwLCBmbGF0U2hhZGluZzogdHJ1ZX0pO1xuICAgIHRoaXMuZGVmYXVsdCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtjb2xvcjogMHhmZjAwMDAsIGZsYXRTaGFkaW5nOiB0cnVlfSk7XG4gICAgdGhpcy5uZW9uID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtjb2xvcjogMHg5OTk5ZmYsIGZvZzogZmFsc2V9KTtcbiAgfVxufSk7XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnbWF0ZXJpYWxzJywge1xuICBzY2hlbWE6IHtcbiAgICBkZWZhdWx0OiAnYmxhY2snLFxuICAgIG9uZU9mOiBbJ2JsYWNrJywgJ2RlZmF1bHQnLCAnbmVvbiddXG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwub2JqZWN0M0QudHJhdmVyc2UobyA9PiBvLm1hdGVyaWFsID0gdGhpcy5zeXN0ZW1bdGhpcy5kYXRhXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvbWF0ZXJpYWxzLmpzIiwidmFyIGJpbmRFdmVudCA9IHJlcXVpcmUoJ2FmcmFtZS1ldmVudC1kZWNvcmF0b3JzJykuYmluZEV2ZW50O1xuXG4vKipcbiAqIFNlbGVjdCBkaWZmaWN1bHR5LlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ21lbnUtZGlmZmljdWx0eS1zZWxlY3QnLCB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLnNjZW5lRWwuYWRkRXZlbnRMaXN0ZW5lcignbWVudWNoYWxsZW5nZXNlbGVjdCcsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmVsLmNvbXBvbmVudHMubGF5b3V0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgY2xpY2s6IGJpbmRFdmVudChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdGhpcy5lbC5zY2VuZUVsLmVtaXQoXG4gICAgICAnbWVudWRpZmZpY3VsdHlzZWxlY3QnLFxuICAgICAgZXZ0LnRhcmdldC5jbG9zZXN0KCcuZGlmZmljdWx0eU9wdGlvbicpLmRhdGFzZXQuZGlmZmljdWx0eSxcbiAgICAgIGZhbHNlKTtcbiAgfSlcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvbWVudS1kaWZmaWN1bHR5LXNlbGVjdC5qcyIsIi8qKlxuICogUmV1c2UgaW1hZ2VzIGZyb20gdGhlIHNlYXJjaCByZXN1bHRzIHRvIG5vdCBjcmVhdGUgYW5vdGhlciB0ZXh0dXJlLlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ21lbnUtc2VsZWN0ZWQtY2hhbGxlbmdlLWltYWdlJywge1xuICBzY2hlbWE6IHtcbiAgICBzZWxlY3RlZENoYWxsZW5nZUlkOiB7dHlwZTogJ3N0cmluZyd9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VhcmNoUmVzdWx0RWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlYXJjaFJlc3VsdExpc3QnKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbDtcblxuICAgIGlmICghZGF0YS5zZWxlY3RlZENoYWxsZW5nZUlkKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgaW1hZ2VFbCA9IHRoaXMuc2VhcmNoUmVzdWx0RWxzXG4gICAgICAucXVlcnlTZWxlY3RvcihgW2RhdGEtaWQ9XCIke2RhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZH1cIl0gLnNlYXJjaFJlc3VsdEltYWdlYCk7XG4gICAgZWwuZ2V0T2JqZWN0M0QoJ21lc2gnKS5tYXRlcmlhbC5tYXAgPSBpbWFnZUVsLmdldE9iamVjdDNEKCdtZXNoJykubWF0ZXJpYWwubWFwO1xuICAgIGVsLmdldE9iamVjdDNEKCdtZXNoJykubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL21lbnUtc2VsZWN0ZWQtY2hhbGxlbmdlLWltYWdlLmpzIiwiY29uc3QgZXZlbnRzID0gW1xuICAnbWVudWRvd24nLFxuICAnYWJ1dHRvbmRvd24nLFxuICAnYmJ1dHRvbmRvd24nLFxuICAneGJ1dHRvbmRvd24nLFxuICAneWJ1dHRvbmRvd24nXG5dO1xuXG4vKipcbiAqIFRlbGwgYXBwIHRvIHBhdXNlIGdhbWUgaWYgcGxheWluZy5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdwYXVzZXInLCB7XG4gIHNjaGVtYToge1xuICAgIGVuYWJsZWQ6IHtkZWZhdWx0OiB0cnVlfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhdXNlR2FtZSA9IHRoaXMucGF1c2VHYW1lLmJpbmQodGhpcyk7XG5cbiAgICBldmVudHMuZm9yRWFjaChldmVudCAgPT4ge1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLnBhdXNlR2FtZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcGF1c2VHYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEuZW5hYmxlZCkgeyByZXR1cm47IH1cbiAgICB0aGlzLmVsLnNjZW5lRWwuZW1pdCgncGF1c2VnYW1lJywgbnVsbCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3BhdXNlci5qcyIsInZhciBTb3VuZFBvb2wgPSByZXF1aXJlKCcuLi9saWIvc291bmRwb29sJyk7XG5cbkFGUkFNRS5yZWdpc3RlclN5c3RlbSgncGxheS1zb3VuZCcsIHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGFzdFNvdW5kUGxheWVkID0gJyc7XG4gICAgdGhpcy5sYXN0U291bmRQbGF5ZWRUaW1lID0gMDtcbiAgICB0aGlzLnBvb2xzID0ge307XG4gIH0sXG5cbiAgY3JlYXRlUG9vbDogZnVuY3Rpb24gKHNvdW5kLCB2b2x1bWUpIHtcbiAgICBpZiAodGhpcy5wb29sc1tzb3VuZF0pIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5wb29sc1tzb3VuZF0gPSBuZXcgU291bmRQb29sKHNvdW5kLCB2b2x1bWUpO1xuICB9LFxuXG4gIHBsYXlTb3VuZDogZnVuY3Rpb24gKHNvdW5kLCB2b2x1bWUpIHtcbiAgICBpZiAoIXRoaXMucG9vbHNbc291bmRdKSB7XG4gICAgICB0aGlzLmNyZWF0ZVBvb2woc291bmQsIHZvbHVtZSk7XG4gICAgfVxuICAgIHRoaXMucG9vbHNbc291bmRdLnBsYXkoKTtcblxuICAgIHRoaXMubGFzdFNvdW5kUGxheWVkID0gc291bmQ7XG4gICAgdGhpcy5sYXN0U291bmRUaW1lID0gdGhpcy5lbC50aW1lO1xuICB9XG59KTtcblxuLyoqXG4gKiBQbGF5IHNvdW5kIG9uIGV2ZW50LlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3BsYXktc291bmQnLCB7XG4gIHNjaGVtYToge1xuICAgIGVuYWJsZWQ6IHtkZWZhdWx0OiB0cnVlfSxcbiAgICBldmVudDoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICBzb3VuZDoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICB2b2x1bWU6IHt0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMX1cbiAgfSxcblxuICBtdWx0aXBsZTogdHJ1ZSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZGF0YS5ldmVudCwgZXZ0ID0+IHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLnN5c3RlbS5wbGF5U291bmQodGhpcy5zcmMsIHRoaXMuZGF0YS52b2x1bWUpO1xuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3JjID0gdGhpcy5kYXRhLnNvdW5kO1xuICAgIGlmICh0aGlzLmRhdGEuc291bmQuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICB0aGlzLnNyYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5kYXRhLnNvdW5kKS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9wbGF5LXNvdW5kLmpzIiwiQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdncHUtcHJlbG9hZGVyJywge1xuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucHJlbG9hZEZvbnQoKTtcbiAgICAgIHRoaXMucHJlbG9hZEtleWJvYXJkKCk7XG4gICAgfSwgMTAwMCk7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZWwub2JqZWN0M0QudmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sIDIwMDApO1xuICB9LFxuXG4gIHByZWxvYWRGb250OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dDtcbiAgICB0ZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3RleHRdJyk7XG4gICAgaWYgKHRleHQuY29tcG9uZW50cy50ZXh0LnRleHR1cmUpIHtcbiAgICAgIHRoaXMucHJlbG9hZFRleHR1cmUodGV4dC5jb21wb25lbnRzLnRleHQudGV4dHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHQuYWRkRXZlbnRMaXN0ZW5lcigndGV4dGZvbnRzZXQnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJlbG9hZFRleHR1cmUodGV4dC5jb21wb25lbnRzLnRleHQudGV4dHVyZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlbG9hZEtleWJvYXJkOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2JkO1xuICAgIGtiZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdrYicpO1xuICAgIGtiZC5vYmplY3QzRC50cmF2ZXJzZShub2RlID0+IHtcbiAgICAgIGlmIChub2RlLm1hdGVyaWFsICYmIG5vZGUubWF0ZXJpYWwubWFwKSB7XG4gICAgICAgIHRoaXMucHJlbG9hZFRleHR1cmUobm9kZS5tYXRlcmlhbC5tYXApO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHByZWxvYWRUZXh0dXJlOiBmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgdGhpcy5lbC5zY2VuZUVsLnJlbmRlcmVyLnNldFRleHR1cmUyRCh0ZXh0dXJlLCAwKTtcbiAgfSxcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvcHJlbG9hZGVyLmpzIiwiQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdyYXljYXN0YWJsZScsIHt9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3JheWNhc3RhYmxlLmpzIiwiLyoqXG4gKiBQaXZvdCB0aGUgc2NlbmUgd2hlbiB1c2VyIGVudGVycyBWUiB0byBmYWNlIHRoZSBsaW5rcy5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdyZWNlbnRlcicsIHtcbiAgc2NoZW1hOiB7XG4gICAgZW5hYmxlZDoge2RlZmF1bHQ6IHRydWV9LFxuICAgIHRhcmdldDoge2RlZmF1bHQ6ICcnfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NlbmVFbCA9IHRoaXMuZWwuc2NlbmVFbDtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgdGhpcy5mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKTtcbiAgICB0aGlzLnJvdGF0aW9uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmV1bGVyID0gbmV3IFRIUkVFLkV1bGVyKCk7XG4gICAgdGhpcy5ldWxlci5vcmRlciA9ICdZWFonO1xuICAgIHRoaXMubWVudVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLnJlY2VudGVyID0gdGhpcy5yZWNlbnRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2hlY2tJblZpZXdBZnRlclJlY2VudGVyID0gdGhpcy5jaGVja0luVmlld0FmdGVyUmVjZW50ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5kYXRhLnRhcmdldCk7XG5cbiAgICAvLyBEZWxheSB0byBtYWtlIHN1cmUgd2UgaGF2ZSBhIHZhbGlkIHBvc2UuXG4gICAgc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCdlbnRlci12cicsICgpID0+IHNldFRpbWVvdXQodGhpcy5yZWNlbnRlciwgMTAwKSk7XG4gICAgLy8gVXNlciBjYW4gYWxzbyByZWNlbnRlciB0aGUgbWVudSBtYW51YWxseS5cbiAgICBzY2VuZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21lbnVkb3duJywgdGhpcy5yZWNlbnRlcik7XG4gICAgc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCd0aHVtYnN0aWNrZG93bicsIHRoaXMucmVjZW50ZXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2cmRpc3BsYXlwcmVzZW50Y2hhbmdlJywgdGhpcy5yZWNlbnRlcik7XG4gIH0sXG5cbiAgcmVjZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXVsZXIgPSB0aGlzLmV1bGVyO1xuICAgIGlmICghdGhpcy5kYXRhLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG4gICAgZXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHRoaXMuZWwuc2NlbmVFbC5jYW1lcmEuZWwub2JqZWN0M0QubWF0cml4V29ybGQsICdZWFonKTtcbiAgICB0aGlzLmVsLm9iamVjdDNELnJvdGF0aW9uLnkgPSBldWxlci55ICsgdGhpcy5yb3RhdGlvbk9mZnNldDtcbiAgICAvLyBDaGVjayBpZiB0aGUgbWVudSBpcyBpbiBjYW1lcmEgZnJ1c3R1bSBpbiBuZXh0IHRpY2sgYWZ0ZXIgYSBmcmFtZSBoYXMgcmVuZGVyZWQuXG4gICAgc2V0VGltZW91dCh0aGlzLmNoZWNrSW5WaWV3QWZ0ZXJSZWNlbnRlciwgMCk7XG4gIH0sXG5cbiAgLypcbiAgICogU29tZXRpbWVzIHRoZSBxdWF0ZXJuaW9uIHJldHVybnMgdGhlIHlhdyBpbiB0aGUgWy0xODAsIDE4MF0gcmFuZ2UuXG4gICAqIENoZWNrIGlmIHRoZSBtZW51IGlzIGluIHRoZSBjYW1lcmEgZnJ1c3R1bSBhZnRlciByZWNlbnRlciBpdCB0b1xuICAgKiBkZWNpZGUgaWYgd2UgYXBwbHkgYW4gb2Zmc2V0IG9yIG5vdC5cbiAgICovXG4gIGNoZWNrSW5WaWV3QWZ0ZXJSZWNlbnRlcjogKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm90dG9tVmVjMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHRvcFZlYzMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLmVsLnNjZW5lRWwuY2FtZXJhO1xuICAgICAgdmFyIGZydXN0dW0gPSB0aGlzLmZydXN0dW07XG4gICAgICB2YXIgbWVudVBvc2l0aW9uID0gdGhpcy5tZW51UG9zaXRpb247XG5cbiAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXgoKTtcbiAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgZnJ1c3R1bS5zZXRGcm9tTWF0cml4KHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgbWVudSBwb3NpdGlvbiAoYW5kIGl0cyBib3VuZHMpIGFyZSB3aXRoaW4gdGhlIGZydXN0dW0uXG4gICAgICAvLyBDaGVjayBib3VuZHMgaW4gY2FzZSBsb29raW5nIGFuZ2xlZCB1cCBvciBkb3duLCByYXRoZXIgdGhhbiBtZW51IGNlbnRyYWwuXG4gICAgICBtZW51UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMudGFyZ2V0Lm9iamVjdDNELm1hdHJpeFdvcmxkKTtcbiAgICAgIGJvdHRvbVZlYzMuY29weShtZW51UG9zaXRpb24pLnkgLT0gMztcbiAgICAgIHRvcFZlYzMuY29weShtZW51UG9zaXRpb24pLnkgKz0gMztcblxuICAgICAgaWYgKGZydXN0dW0uY29udGFpbnNQb2ludChtZW51UG9zaXRpb24pIHx8XG4gICAgICAgICAgZnJ1c3R1bS5jb250YWluc1BvaW50KGJvdHRvbVZlYzMpIHx8XG4gICAgICAgICAgZnJ1c3R1bS5jb250YWluc1BvaW50KHRvcFZlYzMpKSB7IHJldHVybjsgfVxuXG4gICAgICB0aGlzLnJvdGF0aW9uT2Zmc2V0ID0gdGhpcy5yb3RhdGlvbk9mZnNldCA9PT0gMCA/IE1hdGguUEkgOiAwO1xuICAgICAgLy8gUmVjZW50ZXIgYWdhaW4gd2l0aCB0aGUgbmV3IG9mZnNldC5cbiAgICAgIHRoaXMucmVjZW50ZXIoKTtcbiAgICB9O1xuICB9KSgpLFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwuc2NlbmVFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlci12cicsIHRoaXMucmVjZW50ZXIpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3JlY2VudGVyLmpzIiwiQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdzYWJlci1jb250cm9scycsIHtcbiAgc2NoZW1hOiB7XG4gICAgaGFuZDoge2RlZmF1bHQ6ICdyaWdodCcsIG9uZU9mOiBbJ2xlZnQnLCAncmlnaHQnXX0sXG4gICAgYmxhZGVFbmFibGVkOiB7ZGVmYXVsdDogdHJ1ZX1cbiAgfSxcblxuICBjb2xvcnM6IHtcbiAgICByaWdodDogJyM3OGFhZmYnLCAvLyBCbHVlXG4gICAgbGVmdDogJyNmZmE4YTgnIC8vIFJlZFxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRyb2xsZXJjb25uZWN0ZWQnLCB0aGlzLmluaXRTYWJlci5iaW5kKHRoaXMpKTtcblxuICAgIGNvbnN0IGhhbmQgPSB7aGFuZDogZGF0YS5oYW5kLCBtb2RlbDogZmFsc2V9O1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnb2N1bHVzLXRvdWNoLWNvbnRyb2xzJywgaGFuZCk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCd2aXZlLWNvbnRyb2xzJywgaGFuZCk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCd3aW5kb3dzLW1vdGlvbi1jb250cm9scycsIGhhbmQpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5ibGFkZUVsKSB7IHJldHVybjsgfVxuICAgIHRoaXMuYmxhZGVFbC5vYmplY3QzRC52aXNpYmxlID0gdGhpcy5kYXRhLmJsYWRlRW5hYmxlZDtcbiAgICBpZiAodGhpcy5kYXRhLmJsYWRlRW5hYmxlZCkge1xuICAgICAgdGhpcy5ibGFkZUVsUGl2b3Qub2JqZWN0M0Quc2NhbGUuc2V0KDAuMDAwMSwgMC4wMDEsIDAuMDAwMSk7XG4gICAgICB0aGlzLmJsYWRlRWwuZW1pdCgnZHJhd2JsYWRlJyk7XG4gICAgfVxuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuYmxhZGVFbCB8fCAhdGhpcy5ibGFkZUVsLmdldE9iamVjdDNEKCdtZXNoJykpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tT2JqZWN0KHRoaXMuYmxhZGVFbC5nZXRPYmplY3QzRCgnbWVzaCcpKTtcbiAgfSxcblxuICBpbml0U2FiZXI6IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBzYWJlckhhbmRsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICB2YXIgYmxhZGVFbCA9IHRoaXMuYmxhZGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EtZW50aXR5Jyk7XG4gICAgdmFyIGJsYWRlRWxQaXZvdCA9IHRoaXMuYmxhZGVFbFBpdm90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICB2YXIgc2FiZXJQaXZvdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICB2YXIgaGlnaGxpZ2h0VG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICB2YXIgaGlnaGxpZ2h0Qm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICB2YXIgY29udHJvbGxlckNvbmZpZyA9IHRoaXMuY29uZmlnW2V2dC5kZXRhaWwubmFtZV07XG5cbiAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIGJsYWRlRWwuc2V0QXR0cmlidXRlKCdtYXRlcmlhbCcsIHtzaGFkZXI6ICdmbGF0JywgY29sb3I6IHRoaXMuY29sb3JzW3RoaXMuZGF0YS5oYW5kXX0pO1xuICAgIGJsYWRlRWwuc2V0QXR0cmlidXRlKCdnZW9tZXRyeScsIHtwcmltaXRpdmU6ICdib3gnLCBoZWlnaHQ6IDAuOSwgZGVwdGg6IDAuMDIwLCB3aWR0aDogMC4wMjB9KTtcbiAgICBibGFkZUVsLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCAnMCAtMC41NSAwJyk7XG4gICAgYmxhZGVFbC5zZXRBdHRyaWJ1dGUoJ3BsYXktc291bmQnLCB7ZXZlbnQ6ICdkcmF3YmxhZGUnLCBzb3VuZDogXCIjc2FiZXJEcmF3XCJ9KTtcbiAgICBibGFkZUVsLm9iamVjdDNELnZpc2libGUgPSB0aGlzLmRhdGEuYmxhZGVFbmFibGVkO1xuXG4gICAgLy8gRm9yIGJsYWRlIHNhYmVyIGRyYXcgYW5pbWF0aW9uLlxuICAgIGJsYWRlRWxQaXZvdC5hcHBlbmRDaGlsZChibGFkZUVsKTtcbiAgICBibGFkZUVsUGl2b3Quc2V0QXR0cmlidXRlKCdhbmltYXRpb24nLCAncHJvcGVydHk6IHNjYWxlOyBmcm9tOiAwIDAgMDsgdG86IDEuMCAxLjAgMS4wOyBkdXI6IDc1MDsgZWFzaW5nOiBsaW5lYXI7IHN0YXJ0RXZlbnRzOiBkcmF3YmxhZGUnKTtcblxuICAgIHNhYmVySGFuZGxlRWwuc2V0QXR0cmlidXRlKCdtYXRlcmlhbCcsIHtzaGFkZXI6ICdmbGF0JywgY29sb3I6ICcjMTUxNTE1J30pO1xuICAgIHNhYmVySGFuZGxlRWwuc2V0QXR0cmlidXRlKCdnZW9tZXRyeScsIHtwcmltaXRpdmU6ICdib3gnLCBoZWlnaHQ6IDAuMiwgZGVwdGg6IDAuMDI1LCB3aWR0aDogMC4wMjV9KTtcbiAgICBzYWJlckhhbmRsZUVsLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCAnMCAwIDAnKTtcblxuICAgIGhpZ2hsaWdodFRvcC5zZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywge3NoYWRlcjogJ2ZsYXQnLCBjb2xvcjogdGhpcy5jb2xvcnNbdGhpcy5kYXRhLmhhbmRdfSk7XG4gICAgaGlnaGxpZ2h0VG9wLnNldEF0dHJpYnV0ZSgnZ2VvbWV0cnknLCB7cHJpbWl0aXZlOiAnYm94JywgaGVpZ2h0OiAwLjE4LCBkZXB0aDogMC4wMDUsIHdpZHRoOiAwLjAwNX0pO1xuICAgIGhpZ2hsaWdodFRvcC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgJzAgMCAwLjAxMjUnKTtcblxuICAgIGhpZ2hsaWdodEJvdHRvbS5zZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywge3NoYWRlcjogJ2ZsYXQnLCBjb2xvcjogdGhpcy5jb2xvcnNbdGhpcy5kYXRhLmhhbmRdfSk7XG4gICAgaGlnaGxpZ2h0Qm90dG9tLnNldEF0dHJpYnV0ZSgnZ2VvbWV0cnknLCB7cHJpbWl0aXZlOiAnYm94JywgaGVpZ2h0OiAwLjE4LCBkZXB0aDogMC4wMDUsIHdpZHRoOiAwLjAwNX0pO1xuICAgIGhpZ2hsaWdodEJvdHRvbS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgJzAgMCAtMC4wMTI1Jyk7XG5cbiAgICBzYWJlckhhbmRsZUVsLmFwcGVuZENoaWxkKGhpZ2hsaWdodFRvcCk7XG4gICAgc2FiZXJIYW5kbGVFbC5hcHBlbmRDaGlsZChoaWdobGlnaHRCb3R0b20pXG5cbiAgICBzYWJlclBpdm90RWwuc2V0QXR0cmlidXRlKCdyb3RhdGlvbicsICc5MCAwIDAnKTtcbiAgICBzYWJlclBpdm90RWwuYXBwZW5kQ2hpbGQoc2FiZXJIYW5kbGVFbCk7XG4gICAgc2FiZXJQaXZvdEVsLmFwcGVuZENoaWxkKGJsYWRlRWxQaXZvdCk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoc2FiZXJQaXZvdEVsKTtcblxuICAgIHRoaXMuY29udHJvbGxlckNvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5jb250cm9sbGVyVHlwZSA9IGV2dC5kZXRhaWwubmFtZTtcblxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY3Vyc29yJywgY29udHJvbGxlckNvbmZpZy5jdXJzb3IgfHwge30pO1xuICB9LFxuXG4gIGNvbmZpZzoge1xuICAgICdvY3VsdXMtdG91Y2gtY29udHJvbHMnOiB7XG4gICAgICBjdXJzb3I6IHtcbiAgICAgICAgZG93bkV2ZW50czogW1xuICAgICAgICAgICd0cmlnZ2VyZG93bicsXG4gICAgICAgICAgJ2dyaXBkb3duJyxcbiAgICAgICAgICAnYWJ1dHRvbmRvd24nLFxuICAgICAgICAgICdiYnV0dG9uZG93bicsXG4gICAgICAgICAgJ3hidXR0b25kb3duJyxcbiAgICAgICAgICAneWJ1dHRvbmRvd24nLFxuICAgICAgICBdLFxuICAgICAgICB1cEV2ZW50czogW1xuICAgICAgICAgICd0cmlnZ2VydXAnLFxuICAgICAgICAgICdncmlwdXAnLFxuICAgICAgICAgICdhYnV0dG9udXAnLFxuICAgICAgICAgICdiYnV0dG9udXAnLFxuICAgICAgICAgICd4YnV0dG9udXAnLFxuICAgICAgICAgICd5YnV0dG9udXAnLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgJ3ZpdmUtY29udHJvbHMnOiB7XG4gICAgICBjdXJzb3I6IHtcbiAgICAgICAgZG93bkV2ZW50czogWyd0cmFja3BhZGRvd24nLCAndHJpZ2dlcmRvd24nLCAnZ3JpcGRvd24nXSxcbiAgICAgICAgdXBFdmVudHM6IFsndHJhY2twYWR1cCcsICd0cmlnZ2VydXAnLCAnZ3JpcHVwJ10sXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICAnd2luZG93cy1tb3Rpb24tY29udHJvbHMnOiB7XG4gICAgICBjdXJzb3I6IHtcbiAgICAgICAgZG93bkV2ZW50czogWyd0cmFja3BhZGRvd24nLCAndHJpZ2dlcmRvd24nLCAnZ3JpcGRvd24nXSxcbiAgICAgICAgdXBFdmVudHM6IFsndHJhY2twYWR1cCcsICd0cmlnZ2VydXAnLCAnZ3JpcHVwJ10sXG4gICAgICB9LFxuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9zYWJlci1jb250cm9scy5qcyIsInZhciBhbGdvbGlhc2VhcmNoID0gcmVxdWlyZSgnYWxnb2xpYXNlYXJjaC9saXRlJyk7XG52YXIgYmluZEV2ZW50ID0gcmVxdWlyZSgnYWZyYW1lLWV2ZW50LWRlY29yYXRvcnMnKS5iaW5kRXZlbnQ7XG5cbnZhciBjbGllbnQgPSBhbGdvbGlhc2VhcmNoKCdRVUxUT1kzWldVJywgJ2JlMDcxNjQxOTI0NzFkZjdlOTdlNmZhNzBjMWQwNDFkJyk7XG52YXIgYWxnb2xpYSA9IGNsaWVudC5pbml0SW5kZXgoJ3N1cGVyc2FiZXInKTtcblxuLyoqXG4gKiBTZWFyY2ggKGluY2x1ZGluZyB0aGUgaW5pdGlhbCBsaXN0IG9mIHBvcHVsYXIgc2VhcmNoZXMpLlxuICogQXR0YWNoZWQgdG8gc3VwZXIta2V5Ym9hcmQuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc2VhcmNoJywge1xuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV2ZW50RGV0YWlsID0ge3Jlc3VsdHM6IFtdfTtcbiAgICB0aGlzLnBvcHVsYXJIaXRzID0gbnVsbDtcbiAgICB0aGlzLnF1ZXJ5T2JqZWN0ID0ge2hpdHNQZXJQYWdlOiAxMDAsIHF1ZXJ5OiAnJ307XG5cbiAgICAvLyBQb3B1bGF0ZSBwb3B1bGFyLlxuICAgIHRoaXMuc2VhcmNoKCcnKTtcblxuICAgIC8vIExlc3MgaGl0cyBvbiBub3JtYWwgc2VhcmNoZXMuXG4gICAgdGhpcy5xdWVyeU9iamVjdC5oaXRzUGVyUGFnZSA9IDMwO1xuICB9LFxuXG4gIHN1cGVya2V5Ym9hcmRjaGFuZ2U6IGJpbmRFdmVudChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdGhpcy5zZWFyY2goZXZ0LmRldGFpbC52YWx1ZSk7XG4gIH0pLFxuXG4gIHNlYXJjaDogZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgLy8gVXNlIGNhY2hlZCBmb3IgcG9wdWxhciBoaXRzLlxuICAgIGlmICghcXVlcnkgJiYgdGhpcy5wb3B1bGFySGl0cykge1xuICAgICAgdGhpcy5ldmVudERldGFpbC5yZXN1bHRzID0gcG9wdWxhckhpdHM7XG4gICAgICB0aGlzLmVsLnNjZW5lRWwuZW1pdCgnc2VhcmNocmVzdWx0cycsIHRoaXMuZXZlbnREZXRhaWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucXVlcnlPYmplY3QucXVlcnkgPSBxdWVyeTtcbiAgICBhbGdvbGlhLnNlYXJjaCh0aGlzLnF1ZXJ5T2JqZWN0LCAoZXJyLCBjb250ZW50KSA9PiB7XG4gICAgICAvLyBDYWNoZSBwb3B1bGFyIGhpdHMuXG4gICAgICBpZiAoIXF1ZXJ5KSB7IHRoaXMucG9wdWxhckhpdHMgPSBjb250ZW50LmhpdHM7IH1cbiAgICAgIHRoaXMuZXZlbnREZXRhaWwucmVzdWx0cyA9IGNvbnRlbnQuaGl0cztcbiAgICAgIHRoaXMuZWwuc2NlbmVFbC5lbWl0KCdzZWFyY2hyZXN1bHRzJywgdGhpcy5ldmVudERldGFpbCk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENsaWNrIGxpc3RlbmVyIGZvciBzZWFyY2ggcmVzdWx0LlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3NlYXJjaC1yZXN1bHQtbGlzdCcsIHtcbiAgY2xpY2s6IGJpbmRFdmVudChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdGhpcy5lbC5zY2VuZUVsLmVtaXQoJ21lbnVjaGFsbGVuZ2VzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGV2dC50YXJnZXQuY2xvc2VzdCgnLnNlYXJjaFJlc3VsdCcpLmRhdGFzZXQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICB9KSxcbn0pO1xuXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3NlYXJjaC1yZXN1bHQtaW1hZ2UnLCB7XG4gIGRlcGVuZGVuY2llczogWydtYXRlcmlhbCddLFxuXG4gIHNjaGVtYToge1xuICAgIGlkOiB7dHlwZTogJ3N0cmluZyd9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubWF0ZXJpYWxVcGRhdGVPYmogPSB7Y29sb3I6ICcjMjIzJ307XG5cbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21hdGVyaWFsdGV4dHVyZWxvYWRlZCcsICgpID0+IHtcbiAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdtYXRlcmlhbCcsICdjb2xvcicsICcjRkZGJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsLm1hcCA9IG51bGw7XG4gICAgdGhpcy5lbC5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIHRoaXMubWF0ZXJpYWxVcGRhdGVPYmouc3JjID1cbiAgICAgIGBodHRwczovL3MzLXVzLXdlc3QtMi5hbWF6b25hd3MuY29tL3N1cGVyc2FiZXIvJHt0aGlzLmRhdGEuaWR9LWltYWdlLmpwZ2BcbiAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnbWF0ZXJpYWwnLCB0aGlzLm1hdGVyaWFsVXBkYXRlT2JqKTtcbiAgfSxcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvc2VhcmNoLmpzIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBTb25nIHByZXZpZXcgd2hlbiBzZWFyY2ggcmVzdWx0IHNlbGVjdGVkIHdpdGggc21hcnQgbG9naWMgZm9yIHByZWxvYWRpbmcuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc29uZy1wcmV2aWV3LXN5c3RlbScsIHtcbiAgc2NoZW1hOiB7XG4gICAgc2VsZWN0ZWRDaGFsbGVuZ2VJZDoge3R5cGU6ICdzdHJpbmcnfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmF1ZGlvID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvU3RvcmUgPSB7fTtcbiAgICB0aGlzLnByZWxvYWRlZEF1ZGlvSWRzID0gW107XG4gICAgdGhpcy5wcmVsb2FkUXVldWUgPSBbXTtcblxuICAgIC8vIGFuaW1lLmpzIGFuaW1hdGlvbiB0byBmYWRlIGluIHZvbHVtZS5cbiAgICB0aGlzLnZvbHVtZVRhcmdldCA9IHt2b2x1bWU6IDB9O1xuICAgIHRoaXMuYW5pbWF0aW9uID0gQUZSQU1FLmFuaW1lKHtcbiAgICAgIHRhcmdldHM6IHRoaXMudm9sdW1lVGFyZ2V0LFxuICAgICAgZGVsYXk6IDI1MCxcbiAgICAgIGR1cmF0aW9uOiAxNTAwLFxuICAgICAgZWFzaW5nOiAnZWFzZUluUXVhZCcsXG4gICAgICB2b2x1bWU6IDAuNSxcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuYXVkaW8udm9sdW1lID0gdGhpcy52b2x1bWVUYXJnZXQudm9sdW1lO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgaWYgKG9sZERhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZCAmJlxuICAgICAgICBvbGREYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWQgIT09IGRhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZCkge1xuICAgICAgdGhpcy5zdG9wU29uZygpO1xuICAgIH1cblxuICAgIC8vIFNlbGVjdGVkIGNoYWxsZW5nZSBJRCB1cGRhdGVkLlxuICAgIGlmIChkYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWQgJiYgb2xkRGF0YS5zZWxlY3RlZENoYWxsZW5nZUlkICE9PSBkYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWQpIHtcbiAgICAgIC8vIElmIG5vdCB5ZXQgcHJlbG9hZGVkLCBwYXVzZSB0aGUgcHJlbG9hZCBxdWV1ZSB1bnRpbCB0aGlzIHNvbmcgaXMgbG9hZGVkLlxuICAgICAgaWYgKCF0aGlzLnByZWxvYWRlZEF1ZGlvSWRzLmluY2x1ZGVzKGRhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZCkgJiZcbiAgICAgICAgICBkYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWQgIT09IHRoaXMuY3VycmVudExvYWRpbmdJZCkge1xuICAgICAgICB0aGlzLnByaW9yaXRpemVQcmVsb2FkU29uZygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXlTb25nKGRhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTb25nIHdhcyBzZWxlY3RlZCBzbyBwYXVzZSBwcmVsb2FkIHF1ZXVlLCBwcmlvcml0aXplIGl0cyBsb2FkaW5nLCBhbmQgdHJ5IHRvIHBsYXkgQVNBUC5cbiAgICovXG4gIHByaW9yaXRpemVQcmVsb2FkU29uZzogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgcHJlbG9hZFF1ZXVlID0gdGhpcy5wcmVsb2FkUXVldWU7XG5cbiAgICBjb25zb2xlLmxvZyhgW3NvbmctcHJldmlld10gUHJpb3JpdGl6aW5nIGxvYWRpbmcgb2YgJHtkYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWR9YCk7XG4gICAgdGhpcy5wcmlvcml0eUxvYWRpbmdDaGFsbGVuZ2VJZCA9IGRhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZDtcblxuICAgIHRoaXMuYXVkaW9TdG9yZVtkYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWRdLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgW3NvbmctcHJldmlld10gRmluaXNoZWQgbG9hZCBvZiBwcmlvcml0eSAke2RhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZH1gKTtcbiAgICAgIHRoaXMucHJlbG9hZGVkQXVkaW9JZHMucHVzaChkYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWQpO1xuICAgICAgdGhpcy5wcmlvcml0eUxvYWRpbmdDaGFsbGVuZ2VJZCA9ICcnO1xuICAgICAgLy8gUmVzdW1lIHByZWxvYWRpbmcgcXVldWUuXG4gICAgICBpZiAocHJlbG9hZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3NvbmctcHJldmlld10gUmVzdW1pbmcgcXVldWUgd2l0aCAke3ByZWxvYWRRdWV1ZVswXS5jaGFsbGVuZ2VJZH1gKTtcbiAgICAgICAgdGhpcy5wcmVsb2FkTWV0YWRhdGEocHJlbG9hZFF1ZXVlWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFByZWxvYWQuXG4gICAgdGhpcy5hdWRpb1N0b3JlW2RhdGEuc2VsZWN0ZWRDaGFsbGVuZ2VJZF0uc3JjID1cbiAgICAgIHV0aWxzLmdldFMzRmlsZVVybChkYXRhLnNlbGVjdGVkQ2hhbGxlbmdlSWQsICdzb25nLm9nZycpO1xuXG4gICAgLy8gUmVtb3ZlIGZyb20gcHJlbG9hZCBxdWV1ZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWxvYWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByZWxvYWRRdWV1ZVtpXS5jaGFsbGVuZ2VJZCA9PT0gZGF0YS5zZWxlY3RlZENoYWxsZW5nZUlkKSB7XG4gICAgICAgIHByZWxvYWRRdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGF1ZGlvIGVsZW1lbnQgYW5kIHF1ZXVlIHRvIHByZWxvYWQuIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSwgcHJlbG9hZCBpdFxuICAgKiBpbW1lZGlhdGVseS5cbiAgICovXG4gIHF1ZXVlUHJlbG9hZFNvbmc6IGZ1bmN0aW9uIChjaGFsbGVuZ2VJZCwgcHJldmlld1N0YXJ0VGltZSkge1xuICAgIGlmICh0aGlzLmF1ZGlvU3RvcmVbY2hhbGxlbmdlSWRdKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgIGF1ZGlvLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgLy8gYXVkaW8uY3VycmVudFRpbWUgPSBwcmV2aWV3U3RhcnRUaW1lO1xuICAgIGF1ZGlvLnZvbHVtZSA9IDA7XG4gICAgdGhpcy5hdWRpb1N0b3JlW2NoYWxsZW5nZUlkXSA9IGF1ZGlvO1xuXG4gICAgbGV0IHNyYyA9IHV0aWxzLmdldFMzRmlsZVVybChjaGFsbGVuZ2VJZCwgJ3Nvbmcub2dnJyk7XG4gICAgaWYgKHRoaXMuY3VycmVudExvYWRpbmdJZCkge1xuICAgICAgLy8gQXVkaW8gY3VycmVudGx5IGxvYWRpbmcsIGFkZCB0byBxdWV1ZS5cbiAgICAgIHRoaXMucHJlbG9hZFF1ZXVlLnB1c2goe1xuICAgICAgICBhdWRpbzogYXVkaW8sXG4gICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VJZCxcbiAgICAgICAgc3JjOiBzcmNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbXB0eSBxdWV1ZSwgcHJlbG9hZCBub3cuXG4gICAgICB0aGlzLnByZWxvYWRNZXRhZGF0YSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpbyxcbiAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZUlkLFxuICAgICAgICBzcmM6IHNyY1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcmVsb2FkIG1ldGFkYXRhIG9mIGF1ZGlvIGZpbGUgZm9yIHF1aWNrIHBsYXkuXG4gICAqIFNldCBgc3JjYCBhbmQgYHByZWxvYWRgLlxuICAgKiBBIHByZWxvYWQgcXVldWUgaXMgc2V0IHVwIHNvIHdlIG9ubHkgcHJlbG9hZCBvbmUgYXQgYSB0aW1lIHRvIG5vdCBib2cgZG93blxuICAgKiB0aGUgbmV0d29yay4gSWYgYSBzb25nIGlzIHNlbGVjdGVkIHRvIHByZXZpZXcsIHdlIGNhbiBidW1wIGl0IHRvIHRoZSBmcm9udCBvZiB0aGVcbiAgICogcXVldWUuXG4gICAqL1xuICBwcmVsb2FkTWV0YWRhdGE6IGZ1bmN0aW9uIChwcmVsb2FkSXRlbSkge1xuICAgIGNvbnN0IGF1ZGlvID0gcHJlbG9hZEl0ZW0uYXVkaW87XG4gICAgY29uc29sZS5sb2coYFtzb25nLXByZXZpZXddIFByZWxvYWRpbmcgc29uZyBwcmV2aWV3ICR7cHJlbG9hZEl0ZW0uY2hhbGxlbmdlSWR9YCk7XG5cbiAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgIC8vIFNvbmcgcHJlbG9hZGVkLlxuICAgICAgY29uc29sZS5sb2coYFtzb25nLXByZXZpZXddIEZpbmlzaGVkIHByZWxvYWRpbmcgc29uZyBwcmV2aWV3ICR7cHJlbG9hZEl0ZW0uY2hhbGxlbmdlSWR9YCk7XG4gICAgICB0aGlzLnByZWxvYWRlZEF1ZGlvSWRzLnB1c2gocHJlbG9hZEl0ZW0uY2hhbGxlbmdlSWQpO1xuICAgICAgdGhpcy5jdXJyZW50TG9hZGluZ0lkID0gJyc7XG5cbiAgICAgIC8vIE1vdmUgb24gdG8gbmV4dCBzb25nIGluIHF1ZXVlIGlmIGFueS5cbiAgICAgIGNvbnNvbGUubG9nKGBbc29uZy1wcmV2aWV3XSAke3RoaXMucHJlbG9hZFF1ZXVlLmxlbmd0aH0gaW4gcXVldWVgKTtcbiAgICAgIGlmICh0aGlzLnByZWxvYWRRdWV1ZS5sZW5ndGggJiYgIXRoaXMucHJpb3JpdHlMb2FkaW5nQ2hhbGxlbmdlSWQpIHtcbiAgICAgICAgdGhpcy5wcmVsb2FkTWV0YWRhdGEodGhpcy5wcmVsb2FkUXVldWUuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhdWRpby5wcmVsb2FkID0gJ21ldGFkYXRhJztcbiAgICBhdWRpby5zcmMgPSBwcmVsb2FkSXRlbS5zcmM7XG4gICAgdGhpcy5jdXJyZW50TG9hZGluZ0lkID0gcHJlbG9hZEl0ZW0uY2hhbGxlbmdlSWQ7XG4gIH0sXG5cbiAgc3RvcFNvbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuYXVkaW8pIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7IHRoaXMuYW5pbWF0aW9uLnBhdXNlKCk7IH1cbiAgICBpZiAoIXRoaXMuYXVkaW8ucGF1c2VkKSB7IHRoaXMuYXVkaW8ucGF1c2UoKTsgfVxuICB9LFxuXG4gIHBsYXlTb25nOiBmdW5jdGlvbiAoY2hhbGxlbmdlSWQpIHtcbiAgICBpZiAoIWNoYWxsZW5nZUlkKSB7IHJldHVybjsgfVxuICAgIHRoaXMuYXVkaW8gPSB0aGlzLmF1ZGlvU3RvcmVbY2hhbGxlbmdlSWRdO1xuICAgIHRoaXMuYXVkaW8udm9sdW1lID0gMDtcbiAgICB0aGlzLnZvbHVtZVRhcmdldC52b2x1bWUgPSAwO1xuICAgIHRoaXMuYXVkaW8ucGxheSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uLnJlc3RhcnQoKTtcbiAgICB0aGlzLnVwZGF0ZUFuYWx5c2VyKCk7XG4gIH0sXG5cbiAgdXBkYXRlQW5hbHlzZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50cm9Tb25nJykucGF1c2UoKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXVkaW9hbmFseXNlcicpLnNldEF0dHJpYnV0ZSgnYXVkaW9hbmFseXNlcicsICdzcmMnLCB0aGlzLmF1ZGlvKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBzb25nIGZyb20gcHJlbG9hZGluZy5cbiAgICovXG4gIGNsZWFyU29uZzogZnVuY3Rpb24gKGNoYWxsZW5nZUlkKSB7XG4gICAgbGV0IGF1ZGlvID0gdGhpcy5hdWRpb1N0b3JlW2NoYWxsZW5nZUlkXTtcbiAgICBhdWRpby5wcmVsb2FkID0gJ25vbmUnO1xuXG4gICAgLy8gUmVtb3ZlIGZyb20gcXVldWUgaWYgaW4gdGhlcmUuXG4gICAgbGV0IGluZGV4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcmVsb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnByZWxvYWRRdWV1ZVtpXS5pZCA9PT0gY2hhbGxlbmdlSWQpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbmRleCkgeyByZXR1cm47IH1cbiAgICB0aGlzLnByZWxvYWRRdWV1ZS5zcGxpY2UoaSwgMSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIERhdGEgY29tcG9uZW50IGF0dGFjaGVkIHRvIHNlYXJjaCByZXN1bHQgZm9yIHNvbmcgcHJldmlldyBzeXN0ZW0uXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc29uZy1wcmV2aWV3Jywge1xuICBzY2hlbWE6IHtcbiAgICBjaGFsbGVuZ2VJZDoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICBwcmV2aWV3U3RhcnRUaW1lOiB7dHlwZTogJ251bWJlcid9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgIGlmIChvbGREYXRhLmNoYWxsZW5nZUlkICYmIHRoaXMuZGF0YS5jaGFsbGVuZ2VJZCAhPT0gb2xkRGF0YS5jaGFsbGVuZ2VJZCkge1xuICAgICAgdGhpcy5lbC5zY2VuZUVsLmNvbXBvbmVudHNbJ3NvbmctcHJldmlldy1zeXN0ZW0nXS5jbGVhclNvbmcob2xkRGF0YS5jaGFsbGVuZ2VJZCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbC5zY2VuZUVsLmNvbXBvbmVudHNbJ3NvbmctcHJldmlldy1zeXN0ZW0nXS5xdWV1ZVByZWxvYWRTb25nKFxuICAgICAgdGhpcy5kYXRhLmNoYWxsZW5nZUlkLCB0aGlzLmRhdGEucHJldmlld1N0YXJ0VGltZVxuICAgICk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvc29uZy1wcmV2aWV3LmpzIiwiY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEFjdGl2ZSBjaGFsbGVuZ2Ugc29uZyAvIGF1ZGlvLlxuICovXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3NvbmcnLCB7XG4gIHNjaGVtYToge1xuICAgIGNoYWxsZW5nZUlkOiB7ZGVmYXVsdDogJyd9LFxuICAgIGlzUGxheWluZzoge2RlZmF1bHQ6IGZhbHNlfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBVc2UgYXVkaW8gZWxlbWVudCBmb3IgYXVkaW9hbmFseXNlci5cbiAgICB0aGlzLmF1ZGlvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICB0aGlzLmF1ZGlvLnNldEF0dHJpYnV0ZSgnaWQnLCAnc29uZycpO1xuICAgIHRoaXMuZWwuc2NlbmVFbC5hcHBlbmRDaGlsZCh0aGlzLmF1ZGlvKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChvbGREYXRhKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIC8vIENoYW5nZWQgY2hhbGxlbmdlLlxuICAgIGlmIChkYXRhLmNoYWxsZW5nZUlkICE9PSBvbGREYXRhLmNoYWxsZW5nZUlkKSB7XG4gICAgICBsZXQgc29uZ1VybCA9IHV0aWxzLmdldFMzRmlsZVVybChkYXRhLmNoYWxsZW5nZUlkLCAnc29uZy5vZ2cnKTtcbiAgICAgIHRoaXMuYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYXVkaW8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgfSwgZmFsc2UpO1xuICAgICAgdGhpcy5hdWRpby5zcmMgPSBkYXRhLmNoYWxsZW5nZUlkID8gc29uZ1VybCA6ICcnO1xuICAgIH1cblxuICAgIC8vIEtlZXAgcGxheWJhY2sgc3RhdGUgdXAgdG8gZGF0ZS5cbiAgICBpZiAoKGRhdGEuaXNQbGF5aW5nICYmIGRhdGEuY2hhbGxlbmdlSWQpICYmIHRoaXMuYXVkaW8ucGF1c2VkKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUGxheWluZyAke3RoaXMuYXVkaW8uc3JjfS4uLmApO1xuICAgICAgdGhpcy5hdWRpby5wbGF5KCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICgoIWRhdGEuaXNQbGF5aW5nIHx8ICFkYXRhLmNoYWxsZW5nZUlkKSAmJiAhdGhpcy5hdWRpby5wYXVzZWQpIHtcbiAgICAgIHRoaXMuYXVkaW8ucGF1c2UoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvc29uZy5qcyIsIkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc3RhZ2UtY29sb3JzJywge1xuICBzY2hlbWE6IHtcbiAgICBkZWZhdWx0OiAncmVkJyxcbiAgICBvbmVPZjogWydyZWQnLCAnYmx1ZSddXG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubmVvblJlZCAgPSBuZXcgVEhSRUUuQ29sb3IoMHhmZjk5OTkpO1xuICAgIHRoaXMubmVvbkJsdWUgPSBuZXcgVEhSRUUuQ29sb3IoMHg5OTk5ZmYpO1xuICAgIHRoaXMuZGVmYXVsdFJlZCAgPSBuZXcgVEhSRUUuQ29sb3IoMHhmZjAwMDApO1xuICAgIHRoaXMuZGVmYXVsdEJsdWUgPSBuZXcgVEhSRUUuQ29sb3IoMHgwMDAwZmYpO1xuICAgIHRoaXMubWluZUVudk1hcCA9IHtcbiAgICAgIHJlZDogIG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnYXNzZXRzL2ltZy9taW5lZW52aXJvLXJlZC5qcGcnKSxcbiAgICAgIGJsdWU6IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnYXNzZXRzL2ltZy9taW5lZW52aXJvLWJsdWUuanBnJylcbiAgICB9O1xuICAgIHRoaXMubWluZUNvbG9yID0geyByZWQ6IG5ldyBUSFJFRS5Db2xvcigweDA3MDMwNCksIGJsdWU6IG5ldyBUSFJFRS5Db2xvcigweDAzMDQwNykgfTtcbiAgICB0aGlzLm1pbmVFbWlzc2lvbiA9IHsgcmVkOiBuZXcgVEhSRUUuQ29sb3IoMHgwOTA3MDcpLCBibHVlOiBuZXcgVEhSRUUuQ29sb3IoMHgwNzA3MDkpIH07XG4gICAgdGhpcy5taW5lTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgcm91Z2huZXNzOiAwLjM4LFxuICAgICAgbWV0YWxuZXNzOiAwLjQ4LFxuICAgICAgY29sb3I6IHRoaXMubWluZUNvbG9yW3RoaXMuZGF0YV0sXG4gICAgICBlbWlzc2l2ZTogdGhpcy5taW5lRW1pc3Npb25bdGhpcy5kYXRhXSxcbiAgICAgIGVudk1hcDogdGhpcy5taW5lRW52TWFwW3RoaXMuZGF0YV1cbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVkID0gKHRoaXMuZGF0YSA9PSAncmVkJyk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhY2tnbG93Jykuc2V0QXR0cmlidXRlKCdtYXRlcmlhbCcsIHtjb2xvcjogcmVkID8gJyNmMTAnIDogJyMwMGFjZmMnfSk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NreScpLnNldEF0dHJpYnV0ZSgnbWF0ZXJpYWwnLCB7Y29sb3I6IHJlZCA/ICcjNzcwMTAwJzogJyMxNTI1MmQnfSk7XG4gICAgdGhpcy5lbC5zY2VuZUVsLnNldEF0dHJpYnV0ZSgnZm9nJywge2NvbG9yOiByZWQgPyAnI2EwMCcgOiAnIzAwN2NiOSd9KTtcbiAgICB0aGlzLmVsLnNjZW5lRWwuc3lzdGVtcy5tYXRlcmlhbHMubmVvbi5jb2xvciA9IHJlZCA/IHRoaXMubmVvblJlZCA6IHRoaXMubmVvbkJsdWU7XG4gICAgdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMubWF0ZXJpYWxzLmRlZmF1bHQuY29sb3IgPSByZWQgPyB0aGlzLmRlZmF1bHRSZWQgOiB0aGlzLmRlZmF1bHRCbHVlO1xuICAgIHRoaXMubWluZU1hdGVyaWFsLmNvbG9yID0gdGhpcy5taW5lQ29sb3JbdGhpcy5kYXRhXTtcbiAgICB0aGlzLm1pbmVNYXRlcmlhbC5lbWlzc2l2ZSA9IHRoaXMubWluZUVtaXNzaW9uW3RoaXMuZGF0YV07XG4gICAgdGhpcy5taW5lTWF0ZXJpYWwuZW52TWFwID0gdGhpcy5taW5lRW52TWFwW3RoaXMuZGF0YV07XG4gIH1cblxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvc3RhZ2UtY29sb3JzLmpzIiwiQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCd0ZXh0LXVwcGVyY2FzZScsIHtcbiAgc2NoZW1hOiB7XG4gICAgdmFsdWU6IHt0eXBlOiAnc3RyaW5nJ31cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgndGV4dCcsICd2YWx1ZScsIHRoaXMuZGF0YS52YWx1ZS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy90ZXh0LXVwcGVyY2FzZS5qcyIsIkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgndG9nZ2xlLXBhdXNlLXBsYXknLCB7XG4gIHNjaGVtYToge1xuICAgIGlzUGxheWluZzogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5kYXRhLmlzUGxheWluZyA/ICdwYXVzZScgOiAncGxheSc7XG4gICAgcGFyZW50LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsgdmVyaWZ5OiAnZ2FtZS1hY3Rpb24nLCBhY3Rpb24gfSksICcqJyk7XG4gIH0sXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3RvZ2dsZS1wYXVzZS1wbGF5LmpzIiwiQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCd0d2lzdGVyJywge1xuICBzY2hlbWE6IHtcbiAgICB0d2lzdDoge2RlZmF1bHQ6IDB9LFxuICAgIHZlcnRpY2VzOiB7ZGVmYXVsdDogNCwgdHlwZTogJ2ludCd9LFxuICAgIGNvdW50OiB7ZGVmYXVsdDogMjAsIHR5cGU6ICdpbnQnfSxcbiAgICBwb3NpdGlvbkluY3JlbWVudDoge2RlZmF1bHQ6IDJ9LFxuICAgIHJhZGl1c0luY3JlbWVudDoge2RlZmF1bHQ6IDAuNX0sXG4gICAgdGhpY2tuZXNzOiB7ZGVmYXVsdDogMC40fVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnJlbnRUd2lzdCA9IDA7XG4gICAgdGhpcy5hbmltYXRlID0gZmFsc2U7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgIHZhciByYWRpdXMgPSA0O1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBsYXN0U2VnbWVudDtcblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmRhdGEudHdpc3QgLSB0aGlzLmN1cnJlbnRUd2lzdCkgPiAwLjAwMSl7XG4gICAgICB0aGlzLmFuaW1hdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXJTZWdtZW50cygpO1xuICAgIGxhc3RTZWdtZW50ID0gdGhpcy5lbC5vYmplY3QzRDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmNvdW50OyBpKyspIHtcbiAgICAgIHNlZ21lbnQgPSB0aGlzLmNyZWF0ZVNlZ21lbnQocmFkaXVzKTtcbiAgICAgIHNlZ21lbnQucG9zaXRpb24ueSA9IHRoaXMuZGF0YS5wb3NpdGlvbkluY3JlbWVudDtcbiAgICAgIGxhc3RTZWdtZW50LmFkZChzZWdtZW50KTtcbiAgICAgIGxhc3RTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgIHJhZGl1cyArPSB0aGlzLmRhdGEucmFkaXVzSW5jcmVtZW50O1xuICAgIH1cbiAgfSxcblxuICBjcmVhdGVTZWdtZW50OiBmdW5jdGlvbiAocmFkaXVzKSB7XG4gICAgY29uc3QgUiA9IHRoaXMuZGF0YS50aGlja25lc3M7XG4gICAgdmFyIHBvaW50cyA9IFtcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHJhZGl1cyAtIFIsICBSKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHJhZGl1cyAtIFIsIC1SKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHJhZGl1cyArIFIsIC1SKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHJhZGl1cyArIFIsICBSKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHJhZGl1cyAtIFIsICBSKVxuICAgIF07XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMubWF0ZXJpYWxzLmJsYWNrO1xuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5MYXRoZUJ1ZmZlckdlb21ldHJ5KHBvaW50cywgdGhpcy5kYXRhLnZlcnRpY2VzKTtcbiAgICB2YXIgc2VnbWVudCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgcmV0dXJuIHNlZ21lbnQ7XG4gIH0sXG5cbiAgY2xlYXJTZWdtZW50czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwub2JqZWN0M0QucmVtb3ZlKHRoaXMuZWwub2JqZWN0M0QuY2hpbGRyZW5bMF0pO1xuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICh0aW1lLCBkZWx0YSkge1xuICAgIGlmICghdGhpcy5hbmltYXRlKSB7IHJldHVybjsgfVxuICAgIGlmIChNYXRoLmFicyh0aGlzLmRhdGEudHdpc3QgLSB0aGlzLmN1cnJlbnRUd2lzdCkgPCAwLjAwMSl7XG4gICAgICB0aGlzLmFuaW1hdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRUd2lzdCArPSAodGhpcy5kYXRhLnR3aXN0IC0gdGhpcy5jdXJyZW50VHdpc3QpICogZGVsdGEgKiAwLjAwMTtcblxuICAgIHZhciBjaGlsZCA9IHRoaXMuZWwub2JqZWN0M0QuY2hpbGRyZW5bMF07XG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBjaGlsZC5yb3RhdGlvbi55ID0gdGhpcy5jdXJyZW50VHdpc3Q7XG4gICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy90d2lzdGVyLmpzIiwicmVxdWlyZSgnYmFiZWwtcG9seWZpbGwnKTtcblxuZnVuY3Rpb24gcmVxdWlyZUFsbCAocmVxKSB7IHJlcS5rZXlzKCkuZm9yRWFjaChyZXEpOyB9XG5cbnJlcXVpcmUoJ2FmcmFtZS1hbmltYXRpb24tY29tcG9uZW50Jyk7XG5yZXF1aXJlKCdhZnJhbWUtYXVkaW9hbmFseXNlci1jb21wb25lbnQnKTtcbnJlcXVpcmUoJ2FmcmFtZS1jdWJlbWFwLWNvbXBvbmVudCcpO1xucmVxdWlyZSgnYWZyYW1lLWV2ZW50LXNldC1jb21wb25lbnQnKTtcbnJlcXVpcmUoJ2FmcmFtZS1oYXB0aWNzLWNvbXBvbmVudCcpO1xucmVxdWlyZSgnYWZyYW1lLWxheW91dC1jb21wb25lbnQnKTtcbnJlcXVpcmUoJ2FmcmFtZS1vcmJpdC1jb250cm9scycpO1xucmVxdWlyZSgnYWZyYW1lLXBhcnRpY2xlLXN5c3RlbS1jb21wb25lbnQnKTtcbnJlcXVpcmUoJ2FmcmFtZS1wcm94eS1ldmVudC1jb21wb25lbnQnKTtcbnJlcXVpcmUoJ2FmcmFtZS1zdGF0ZS1jb21wb25lbnQnKTtcbnJlcXVpcmUoJ2FmcmFtZS1zbGljZTktY29tcG9uZW50Jyk7XG5yZXF1aXJlKCdhZnJhbWUtc3VwZXIta2V5Ym9hcmQnKTtcbnJlcXVpcmUoJ2FmcmFtZS1wYXJ0aWNsZXBsYXllci1jb21wb25lbnQnKTtcblxucmVxdWlyZUFsbChyZXF1aXJlLmNvbnRleHQoJy4vY29tcG9uZW50cy8nLCB0cnVlLCAvXFwuanMkLykpO1xucmVxdWlyZUFsbChyZXF1aXJlLmNvbnRleHQoJy4vc3RhdGUvJywgdHJ1ZSwgL1xcLmpzJC8pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU291bmRQb29sIChzcmMsIHZvbHVtZSkge1xuICB2YXIgY3VyclNvdW5kID0gMDtcbiAgdmFyIGk7XG4gIHZhciBwb29sID0gW107XG4gIHZhciBzb3VuZDtcblxuICBzb3VuZCA9IG5ldyBBdWRpbyhzcmMpO1xuICBzb3VuZC52b2x1bWUgPSB2b2x1bWU7XG4gIHBvb2wucHVzaChzb3VuZCk7XG5cbiAgcmV0dXJuIHtcbiAgICBwbGF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEeW5hbWljIHNpemUgcG9vbC5cbiAgICAgIGlmIChwb29sW2N1cnJTb3VuZF0uY3VycmVudFRpbWUgIT09IDAgfHwgIXBvb2xbY3VyclNvdW5kXS5lbmRlZCkge1xuICAgICAgICBzb3VuZCA9IG5ldyBBdWRpbyhzcmMpO1xuICAgICAgICBzb3VuZC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICAgIHBvb2wucHVzaChzb3VuZCk7XG4gICAgICAgIGN1cnJTb3VuZCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9vbFtjdXJyU291bmRdLmN1cnJlbnRUaW1lID09PSAwIHx8IHBvb2xbY3VyclNvdW5kXS5lbmRlZCkge1xuICAgICAgICBwb29sW2N1cnJTb3VuZF0ucGxheSgpO1xuICAgICAgfVxuICAgICAgY3VyclNvdW5kID0gKGN1cnJTb3VuZCArIDEpICUgcG9vbC5sZW5ndGg7XG4gICAgfVxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvc291bmRwb29sLmpzIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuY29uc3QgY2hhbGxlbmdlRGF0YVN0b3JlID0ge307XG5jb25zdCBoYXNJbml0aWFsQ2hhbGxlbmdlID0gISFBRlJBTUUudXRpbHMuZ2V0VXJsUGFyYW1ldGVyKCdjaGFsbGVuZ2UnKTtcbmNvbnN0IFNFQVJDSF9QRVJfUEFHRSA9IDY7XG5cbi8qKlxuICogU3RhdGUgaGFuZGxlci5cbiAqXG4gKiAxLiBgaGFuZGxlcnNgIGlzIGFuIG9iamVjdCBvZiBldmVudHMgdGhhdCB3aGVuIGVtaXR0ZWQgdG8gdGhlIHNjZW5lIHdpbGwgcnVuIHRoZSBoYW5kbGVyLlxuICpcbiAqIDIuIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZSBzdGF0ZS5cbiAqXG4gKiAzLiBFbnRpdGllcyBhbmQgY29tcG9uZW50cyB0aGF0IGFyZSBgYmluZGBlZCBhdXRvbWF0aWNhbGx5IHVwZGF0ZTpcbiAqICAgIGBiaW5kX188Y29tcG9uZW50TmFtZT49XCI8cHJvcGVydHlOYW1lPjogc29tZS5pdGVtLmluLnN0YXRlXCJgXG4gKi9cbkFGUkFNRS5yZWdpc3RlclN0YXRlKHtcbiAgaW5pdGlhbFN0YXRlOiB7XG4gICAgYWN0aXZlSGFuZDogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2hhbmQnKSB8fCAncmlnaHQnLFxuICAgIGNoYWxsZW5nZToge1xuICAgICAgYXV0aG9yOiAnJyxcbiAgICAgIGRpZmZpY3VsdHk6ICcnLFxuICAgICAgaWQ6IEFGUkFNRS51dGlscy5nZXRVcmxQYXJhbWV0ZXIoJ2NoYWxsZW5nZScpLFxuICAgICAgaW1hZ2U6ICcnLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIHNvbmdOYW1lOiAnJyxcbiAgICAgIHNvbmdTdWJOYW1lOiAnJ1xuICAgIH0sXG4gICAgaW5WUjogZmFsc2UsXG4gICAgbWVudToge1xuICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgcGxheUJ1dHRvblRleHQ6ICdQbGF5J1xuICAgIH0sXG4gICAgbWVudURpZmZpY3VsdGllczogW10sXG4gICAgbWVudVNlbGVjdGVkQ2hhbGxlbmdlOiB7XG4gICAgICBhdXRob3I6ICcnLFxuICAgICAgZGlmZmljdWx0eTogJycsXG4gICAgICBkb3dubG9hZHM6ICcnLFxuICAgICAgZG93bmxvYWRzVGV4dDogJycsXG4gICAgICBpZDogJycsXG4gICAgICBpbWFnZTogJycsXG4gICAgICBzb25nTmFtZTogJycsXG4gICAgICBzb25nU3ViTmFtZTogJydcbiAgICB9LFxuICAgIHNjb3JlOiB7XG4gICAgICBtYXhTdHJlYWs6IDAsXG4gICAgICBzY29yZTogMCxcbiAgICAgIHN0cmVhazogMFxuICAgIH0sXG4gICAgc2VhcmNoOiB7XG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgICBwYWdlOiAwLFxuICAgICAgaGFzTmV4dDogZmFsc2UsXG4gICAgICBoYXNQcmV2OiBmYWxzZSxcbiAgICAgIHJlc3VsdHM6IFtdLFxuICAgIH0sXG4gICAgc2VhcmNoUmVzdWx0c1BhZ2U6IFtdXG4gIH0sXG5cbiAgaGFuZGxlcnM6IHtcbiAgICAvKipcbiAgICAgKiBTd2FwIGxlZnQtaGFuZGVkIG9yIHJpZ2h0LWhhbmRlZCBtb2RlLlxuICAgICAqL1xuICAgIGFjdGl2ZWhhbmRzd2FwOiBzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5hY3RpdmVIYW5kID0gc3RhdGUuYWN0aXZlSGFuZCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYWN0aXZlSGFuZCcsIHN0YXRlLmFjdGl2ZUhhbmQpO1xuICAgIH0sXG5cbiAgICBiZWF0bG9hZGVyZmluaXNoOiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNoYWxsZW5nZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgYmVhdGxvYWRlcnN0YXJ0OiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNoYWxsZW5nZS5pc0xvYWRpbmcgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTb25nIGNsaWNrZWQgZnJvbSBtZW51LlxuICAgICAqL1xuICAgIG1lbnVjaGFsbGVuZ2VzZWxlY3Q6IChzdGF0ZSwgaWQpID0+IHtcbiAgICAgIC8vIENvcHkgZnJvbSBjaGFsbGVuZ2Ugc3RvcmUgcG9wdWxhdGVkIGZyb20gc2VhcmNoIHJlc3VsdHMuXG4gICAgICBsZXQgY2hhbGxlbmdlRGF0YSA9IGNoYWxsZW5nZURhdGFTdG9yZVtpZF07XG4gICAgICBPYmplY3QuYXNzaWduKHN0YXRlLm1lbnVTZWxlY3RlZENoYWxsZW5nZSwgY2hhbGxlbmdlRGF0YSk7XG5cbiAgICAgIC8vIFBvcHVsYXRlIGRpZmZpY3VsdHkgb3B0aW9ucy5cbiAgICAgIHN0YXRlLm1lbnVEaWZmaWN1bHRpZXMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbGxlbmdlRGF0YS5kaWZmaWN1bHRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUubWVudURpZmZpY3VsdGllcy51bnNoaWZ0KGNoYWxsZW5nZURhdGEuZGlmZmljdWx0aWVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1lbnVEaWZmaWN1bHRpZXMuc29ydChkaWZmaWN1bHR5Q29tcGFyYXRvcik7XG4gICAgICAvLyBEZWZhdWx0IHRvIGVhc2llc3QgZGlmZmljdWx0eS5cbiAgICAgIHN0YXRlLm1lbnVTZWxlY3RlZENoYWxsZW5nZS5kaWZmaWN1bHR5ID0gc3RhdGUubWVudURpZmZpY3VsdGllc1swXTtcblxuICAgICAgc3RhdGUubWVudVNlbGVjdGVkQ2hhbGxlbmdlLmltYWdlID0gdXRpbHMuZ2V0UzNGaWxlVXJsKGlkLCAnaW1hZ2UuanBnJyk7XG4gICAgICBzdGF0ZS5tZW51U2VsZWN0ZWRDaGFsbGVuZ2UuZG93bmxvYWRzVGV4dCA9IGAke2NoYWxsZW5nZURhdGEuZG93bmxvYWRzfSBQbGF5c2A7XG4gICAgfSxcblxuICAgIG1lbnVkaWZmaWN1bHR5c2VsZWN0OiAoc3RhdGUsIGRpZmZpY3VsdHkpID0+IHtcbiAgICAgIHN0YXRlLm1lbnVTZWxlY3RlZENoYWxsZW5nZS5kaWZmaWN1bHR5ID0gZGlmZmljdWx0eTtcbiAgICB9LFxuXG4gICAgcGF1c2VnYW1lOiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLm1lbnUuYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgY2hhbGxlbmdlLlxuICAgICAqIFRyYW5zZmVyIHN0YWdlZCBjaGFsbGVuZ2UgdG8gdGhlIGFjdGl2ZSBjaGFsbGVuZ2UuXG4gICAgICovXG4gICAgcGxheWJ1dHRvbmNsaWNrOiAoc3RhdGUpID0+IHtcbiAgICAgIC8vIFJlc2V0IHNjb3JlLlxuICAgICAgc3RhdGUuc2NvcmUubWF4U3RyZWFrID0gMDtcbiAgICAgIHN0YXRlLnNjb3JlLnNjb3JlID0gMDtcbiAgICAgIHN0YXRlLnNjb3JlLnN0cmVhayA9IDA7XG5cbiAgICAgIC8vIFNldCBjaGFsbGVuZ2UuIGBiZWF0LWxvYWRlcmAgaXMgbGlzdGVuaW5nLlxuICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5jaGFsbGVuZ2UsIHN0YXRlLm1lbnVTZWxlY3RlZENoYWxsZW5nZSk7XG5cbiAgICAgIC8vIFJlc2V0IG1lbnUuXG4gICAgICBzdGF0ZS5tZW51LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubWVudVNlbGVjdGVkQ2hhbGxlbmdlLmlkID0gJyc7XG4gICAgfSxcblxuICAgIHNlYXJjaHByZXZwYWdlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5zZWFyY2gucGFnZSA9PT0gMCkgeyByZXR1cm47IH1cbiAgICAgIHN0YXRlLnNlYXJjaC5wYWdlLS07XG4gICAgICBjb21wdXRlU2VhcmNoUGFnaW5hdGlvbihzdGF0ZSk7XG4gICAgfSxcblxuICAgIHNlYXJjaG5leHRwYWdlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5zZWFyY2gucGFnZSA+IE1hdGguZmxvb3Ioc3RhdGUuc2VhcmNoLnJlc3VsdHMubGVuZ3RoIC8gU0VBUkNIX1BFUl9QQUdFKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGF0ZS5zZWFyY2gucGFnZSsrO1xuICAgICAgY29tcHV0ZVNlYXJjaFBhZ2luYXRpb24oc3RhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc2VhcmNoIHJlc3VsdHMuIFdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgdXNpbmcgYGJpbmQtZm9yYCAobWVudS5odG1sKS5cbiAgICAgKi9cbiAgICBzZWFyY2hyZXN1bHRzOiAoc3RhdGUsIHBheWxvYWQpID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgc3RhdGUuc2VhcmNoLnBhZ2UgPSAwO1xuICAgICAgc3RhdGUuc2VhcmNoLnJlc3VsdHMgPSBwYXlsb2FkLnJlc3VsdHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcGF5bG9hZC5yZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXlsb2FkLnJlc3VsdHNbaV07XG4gICAgICAgIHJlc3VsdC5zb25nU3ViTmFtZSA9IHJlc3VsdC5zb25nU3ViTmFtZSB8fCAnVW5rbm93biBBcnRpc3QnO1xuICAgICAgICByZXN1bHQuc2hvcnRTb25nTmFtZSA9IHRydW5jYXRlKHJlc3VsdC5zb25nTmFtZSwgMjQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlc3VsdC5zaG9ydFNvbmdTdWJOYW1lID0gdHJ1bmNhdGUocmVzdWx0LnNvbmdTdWJOYW1lLCAzMik7XG4gICAgICAgIGNoYWxsZW5nZURhdGFTdG9yZVtyZXN1bHQuaWRdID0gcmVzdWx0XG4gICAgICB9XG4gICAgICBjb21wdXRlU2VhcmNoUGFnaW5hdGlvbihzdGF0ZSk7XG4gICAgfSxcblxuICAgICdlbnRlci12cic6IChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuaW5WUiA9IHRydWU7XG4gICAgfSxcblxuICAgICdleGl0LXZyJzogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5pblZSID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgdGhlIHN0YXRlIGFmdGVyIGVhY2ggYWN0aW9uLlxuICAgKi9cbiAgY29tcHV0ZVN0YXRlOiAoc3RhdGUpID0+IHtcbiAgICBzdGF0ZS5sZWZ0UmF5Y2FzdGVyQWN0aXZlID0gc3RhdGUubWVudS5hY3RpdmUgJiYgc3RhdGUuYWN0aXZlSGFuZCA9PT0gJ2xlZnQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmluVlI7XG4gICAgc3RhdGUucmlnaHRSYXljYXN0ZXJBY3RpdmUgPSBzdGF0ZS5tZW51LmFjdGl2ZSAmJiBzdGF0ZS5hY3RpdmVIYW5kID09PSAncmlnaHQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pblZSO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29tcHV0ZVNlYXJjaFBhZ2luYXRpb24gKHN0YXRlKSB7XG4gIGxldCBudW1QYWdlcyA9IE1hdGguY2VpbChzdGF0ZS5zZWFyY2gucmVzdWx0cy5sZW5ndGggLyBTRUFSQ0hfUEVSX1BBR0UpO1xuICBzdGF0ZS5zZWFyY2guaGFzUHJldiA9IHN0YXRlLnNlYXJjaC5wYWdlID4gMDtcbiAgc3RhdGUuc2VhcmNoLmhhc05leHQgPSBzdGF0ZS5zZWFyY2gucGFnZSA8IG51bVBhZ2VzIC0gMTtcblxuICBzdGF0ZS5zZWFyY2hSZXN1bHRzUGFnZS5sZW5ndGggPSAwO1xuICBmb3IgKGkgPSBzdGF0ZS5zZWFyY2gucGFnZSAqIFNFQVJDSF9QRVJfUEFHRTtcbiAgICAgICBpIDwgc3RhdGUuc2VhcmNoLnBhZ2UgKiBTRUFSQ0hfUEVSX1BBR0UgKyBTRUFSQ0hfUEVSX1BBR0U7IGkrKykge1xuICAgIGlmICghc3RhdGUuc2VhcmNoLnJlc3VsdHNbaV0pIHsgYnJlYWs7IH1cbiAgICBzdGF0ZS5zZWFyY2hSZXN1bHRzUGFnZS5wdXNoKHN0YXRlLnNlYXJjaC5yZXN1bHRzW2ldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZSAoc3RyLCBsZW5ndGgpIHtcbiAgaWYgKCFzdHIpIHsgcmV0dXJuICcnOyB9XG4gIGlmIChzdHIubGVuZ3RoID49IGxlbmd0aCkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIDMpICsgJy4uLic7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuY29uc3QgRElGRklDVUxUSUVTID0gWydFYXN5JywgJ05vcm1hbCcsICdIYXJkJywgJ0V4cGVydCcsICdFeHBlcnRQbHVzJ107XG5mdW5jdGlvbiBkaWZmaWN1bHR5Q29tcGFyYXRvciAoYSwgYikge1xuICBjb25zdCBhSW5kZXggPSBESUZGSUNVTFRJRVMuaW5kZXhPZihhKTtcbiAgY29uc3QgYkluZGV4ID0gRElGRklDVUxUSUVTLmluZGV4T2YoYik7XG4gIGlmIChhSW5kZXggPCBiSW5kZXgpIHsgcmV0dXJuIC0xOyB9XG4gIGlmIChhSW5kZXggPiBiSW5kZXgpIHsgcmV0dXJuIDE7IH1cbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RhdGUvaW5kZXguanMiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8taXNvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVnRXhwLCByZXBsYWNlKSB7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qc1xuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywgeyBlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCkgeyByZXR1cm4gJHJlKGl0KTsgfSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRldmVyeSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDIxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciAkbmF0aXZlID0gW10uaW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5JykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciAkbmF0aXZlID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gQFsqLTFdICovKSB7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmIChORUdBVElWRV9aRVJPKSByZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8pIGlmIChPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGh0bWwpIGFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKTtcbiAgICB2YXIga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYgKGtsYXNzID09ICdBcnJheScpIHJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW4pO1xuICAgIHZhciB1cFRvID0gdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKTtcbiAgICB2YXIgc2l6ZSA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydCk7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzaXplOyBpKyspIGNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRzb21lID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7IG5vdzogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fZGF0ZS10by1pc28tc3RyaW5nJyk7XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiB0b0lTT1N0cmluZ1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGxcbiAgICB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9IH0pICE9PSAxO1xufSksICdEYXRlJywge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKTtcbnZhciBwcm90byA9IERhdGUucHJvdG90eXBlO1xuXG5pZiAoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKSByZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEYXRlUHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IERhdGVQcm90b1tUT19TVFJJTkddO1xudmFyIGdldFRpbWUgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHsgYmluZDogcmVxdWlyZSgnLi9fYmluZCcpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIEhBU19JTlNUQU5DRSA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpO1xudmFyIEZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmICghKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHsgdmFsdWU6IGZ1bmN0aW9uIChPKSB7XG4gIGlmICh0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSkgcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKSBpZiAodGhpcy5wcm90b3R5cGUgPT09IE8pIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXNpbmggPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7IGFzaW5oOiBhc2luaCB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanNcbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdGFuaCA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanNcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywgeyBleHBtMTogJGV4cG0xIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qc1xuLy8gbW9kdWxlIGlkID0gMjQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBmcm91bmQ6IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGltdWwgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSkge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyIHhuID0gK3g7XG4gICAgdmFyIHluID0gK3k7XG4gICAgdmFyIHhsID0gVUlOVDE2ICYgeG47XG4gICAgdmFyIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanNcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KTtcbiAgICB2YXIgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciAkTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgQmFzZSA9ICROdW1iZXI7XG52YXIgcHJvdG8gPSAkTnVtYmVyLnByb3RvdHlwZTtcbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DT0YgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKSB7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IEVQU0lMT046IE1hdGgucG93KDIsIC01MikgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZiB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHsgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanNcbi8vIG1vZHVsZSBpZCA9IDI2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG52YXIgJHRvRml4ZWQgPSAxLjAudG9GaXhlZDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbnZhciBFUlJPUiA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJztcbnZhciBaRVJPID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiAobiwgYykge1xuICB2YXIgaSA9IC0xO1xuICB2YXIgYzIgPSBjO1xuICB3aGlsZSAoKytpIDwgNikge1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbiAobikge1xuICB2YXIgaSA9IDY7XG4gIHZhciBjID0gMDtcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCkge1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG52YXIgcG93ID0gZnVuY3Rpb24gKHgsIG4sIGFjYykge1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKFxuICAwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcbiAgMTAwMDAwMDAwMDAwMDAwMDEyOC4wLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b0ZpeGVkLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpO1xuICAgIHZhciBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKTtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBtID0gWkVSTztcbiAgICB2YXIgZSwgeiwgaiwgaztcbiAgICBpZiAoZiA8IDAgfHwgZiA+IDIwKSB0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKHggIT0geCkgcmV0dXJuICdOYU4nO1xuICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkgcmV0dXJuIFN0cmluZyh4KTtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcbiAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlIChqID49IDIzKSB7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZiA+IDApIHtcbiAgICAgIGsgPSBtLmxlbmd0aDtcbiAgICAgIG0gPSBzICsgKGsgPD0gZiA/ICcwLicgKyByZXBlYXQuY2FsbChaRVJPLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9IHJldHVybiBtO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyICR0b1ByZWNpc2lvbiA9IDEuMC50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b1ByZWNpc2lvbi5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qc1xuLy8gbW9kdWxlIGlkID0gMjY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbiAoJGlzRXh0ZW5zaWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uICgkaXNGcm96ZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uICgkaXNTZWFsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanNcbi8vIG1vZHVsZSBpZCA9IDI3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24gKCRwcmV2ZW50RXh0ZW5zaW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qc1xuLy8gbW9kdWxlIGlkID0gMjgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAyODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpXG4gICAgICAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2VcbiAgICAgIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgICAgLy8gd2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwXG4gICAgICAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY2JykgPT09IC0xO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHJBcHBseSA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseTtcbnZhciBmQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIHZhciBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAyODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vX2JpbmQnKTtcbnZhciByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0KCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwgeyB2YWx1ZTogMSB9KSwgMSwgeyB2YWx1ZTogMiB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMjg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdOyAgICAgIC8vIGtleXNcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gaXRlcmF0ZWQpIGtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBrZXlzID0gdGhhdC5faztcbiAgdmFyIGtleTtcbiAgZG8ge1xuICAgIGlmICh0aGF0Ll9pID49IGtleXMubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH0gd2hpbGUgKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4geyB2YWx1ZToga2V5LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzYywgcHJvdG87XG4gIGlmIChhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgZ2V0OiBnZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgb3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDI5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAyOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmIChzZXRQcm90bykgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkpIHtcbiAgICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IuZ2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci5zZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIH0gZWxzZSBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgY3JlYXRlRGVzYygwLCBWKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgQmFzZSA9ICRSZWdFeHA7XG52YXIgcHJvdG8gPSAkUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7XG4vLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbnZhciBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSkge1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpIHtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwO1xuICAgIHZhciBwaVJFID0gaXNSZWdFeHAocCk7XG4gICAgdmFyIGZpVSA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGl0KSB7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOykgcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCkge1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJG1hdGNoXTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UpIHtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sICRyZXBsYWNlXTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKSB7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanNcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbiAgdmFyIF9zcGxpdCA9ICRzcGxpdDtcbiAgdmFyICRwdXNoID0gW10ucHVzaDtcbiAgdmFyICRTUExJVCA9ICdzcGxpdCc7XG4gIHZhciBMRU5HVEggPSAnbGVuZ3RoJztcbiAgdmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbiAgaWYgKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApIHtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZiAoIU5QQ0cpIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAvLyBgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgICBpZiAoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKSBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSkge1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYgKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhbmNob3IobmFtZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qc1xuLy8gbW9kdWxlIGlkID0gMzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJpZygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qc1xuLy8gbW9kdWxlIGlkID0gMzA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDMwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qc1xuLy8gbW9kdWxlIGlkID0gMzEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIEVORFNfV0lUSCA9ICdlbmRzV2l0aCc7XG52YXIgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKTtcbiAgICB2YXIgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qc1xuLy8gbW9kdWxlIGlkID0gMzEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDMxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlIChhTGVuID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDMxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qc1xuLy8gbW9kdWxlIGlkID0gMzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSkge1xuICAgIHZhciB0cGwgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodHBsLmxlbmd0aCk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYgKGkgPCBhTGVuKSByZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanNcbi8vIG1vZHVsZSBpZCA9IDMyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5zbWFsbCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzbWFsbCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc21hbGwnLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDMyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDMyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qc1xuLy8gbW9kdWxlIGlkID0gMzI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanNcbi8vIG1vZHVsZSBpZCA9IDMyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qc1xuLy8gbW9kdWxlIGlkID0gMzI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDMyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXI7XG52YXIgJERhdGFWaWV3ID0gYnVmZmVyLkRhdGFWaWV3O1xudmFyICRpc1ZpZXcgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlldztcbnZhciAkc2xpY2UgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlO1xudmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwgeyBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyIH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICgkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW4gLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDMzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDM0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDM0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdE1hcFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuLCBBO1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0TWFwJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUFycmF5LnByb3RvdHlwZS5mbGF0dGVuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuL19mbGF0dGVuLWludG8tYXJyYXknKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oLyogZGVwdGhBcmcgPSAxICovKSB7XG4gICAgdmFyIGRlcHRoQXJnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgZGVwdGhBcmcgPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGhBcmcpKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0dGVuJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgcHJvY2VzcyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3M7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBhc2FwOiBmdW5jdGlvbiBhc2FwKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbjtcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KSB7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7IGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbGFtcDogZnVuY3Rpb24gY2xhbXAoeCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHVwcGVyLCBNYXRoLm1heChsb3dlciwgeCkpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDM1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IERFR19QRVJfUkFEOiBNYXRoLlBJIC8gMTgwIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZC5qc1xuLy8gbW9kdWxlIGlkID0gMzUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgUkFEX1BFUl9ERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGRlZ3JlZXM6IGZ1bmN0aW9uIGRlZ3JlZXMocmFkaWFucykge1xuICAgIHJldHVybiByYWRpYW5zICogUkFEX1BFUl9ERUc7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWdyZWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzY2FsZSA9IHJlcXVpcmUoJy4vX21hdGgtc2NhbGUnKTtcbnZhciBmcm91bmQgPSByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZzY2FsZTogZnVuY3Rpb24gZnNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICAgIHJldHVybiBmcm91bmQoc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5mc2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanNcbi8vIG1vZHVsZSBpZCA9IDM1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4gMTY7XG4gICAgdmFyIHYxID0gJHYgPj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qc1xuLy8gbW9kdWxlIGlkID0gMzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBSQURfUEVSX0RFRzogMTgwIC8gTWF0aC5QSSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcuanNcbi8vIG1vZHVsZSBpZCA9IDM1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIERFR19QRVJfUkFEID0gTWF0aC5QSSAvIDE4MDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICByYWRpYW5zOiBmdW5jdGlvbiByYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIERFR19QRVJfUkFEO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucy5qc1xuLy8gbW9kdWxlIGlkID0gMzU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2NhbGU6IHJlcXVpcmUoJy4vX21hdGgtc2NhbGUnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguc2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwOi8vamZiYXN0aWVuLmdpdGh1Yi5pby9wYXBlcnMvTWF0aC5zaWduYml0Lmh0bWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbmJpdDogZnVuY3Rpb24gc2lnbmJpdCh4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpICE9IHggPyB4IDogeCA9PSAwID8gMSAvIHggPT0gSW5maW5pdHkgOiB4ID4gMDtcbn0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQuanNcbi8vIG1vZHVsZSBpZCA9IDM2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4+IDE2O1xuICAgIHZhciB2MSA9ICR2ID4+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanNcbi8vIG1vZHVsZSBpZCA9IDM2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpIHtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4vX293bi1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgICB2YXIgRDtcbiAgICBkbyB7XG4gICAgICBpZiAoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSkgcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIE9CU0VSVkFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIFJFVFVSTiA9IGZvck9mLlJFVFVSTjtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmIChjbGVhbnVwKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9jID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXAoKTtcbiAgfVxufTtcblxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgfVxufTtcblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc3Vic2NyaWJlcikge1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgPSBzdWJzY3JpYmVyKG9ic2VydmVyKTtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZiAoY2xlYW51cCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICByZXR1cm47XG4gIH0gaWYgKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSkgY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7IGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpOyB9XG59KTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB0aHJvdyB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5lcnJvcik7XG4gICAgICBpZiAoIW0pIHRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyAoY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoYW5PYmplY3QoeClbT0JTRVJWQUJMRV0pO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBSRVRVUk47XG4gICAgICAgICAgICB9KSA9PT0gUkVUVVJOKSByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KGwpOyBpIDwgbDspIGl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbal0pO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7IE9ic2VydmFibGU6ICRPYnNlcnZhYmxlIH0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdPYnNlcnZhYmxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDM3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7IGRlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwO1xudmFyIHN0b3JlID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7IGRlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHZhciB0YXJnZXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pO1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZiAobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobWV0YWRhdGFNYXAuc2l6ZSkgcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXQgPSByZXF1aXJlKCcuL2VzNi5zZXQnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xudmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIHZhciBvS2V5cyA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpIHJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGdldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDM3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGdldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDM3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGhhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgaGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvTWV0YUtleSA9ICRtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9ICRtZXRhZGF0YS5zZXQ7XG5cbiRtZXRhZGF0YS5leHAoeyBtZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSkge1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDM4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAzODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzXG4vLyBtb2R1bGUgaWQgPSAzODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBnZXRGbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24gKHJlZ2V4cCwgc3RyaW5nKSB7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7IHZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGwgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYgKCFpc1JlZ0V4cChyZWdleHApKSB0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApO1xuICAgIHZhciByeCA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAzODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAzODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanNcbi8vIG1vZHVsZSBpZCA9IDM4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMzg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMzkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeXN0ZW0nLCB7IGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDM5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrTWFwJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrU2V0Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha1NldCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1zZXQub2YuanNcbi8vIG1vZHVsZSBpZCA9IDM5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgTVNJRSA9IC9NU0lFIC5cXC4vLnRlc3QodXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIHRpbWUgLyogLCAuLi5hcmdzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogZmFsc2U7XG4gICAgcmV0dXJuIHNldChib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWUpO1xuICB9O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDQwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5mc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zY2FsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gNDAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVidWcvZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDQwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuNCszMTRlNDgzMVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgVFJZX0NBVENIX0VSUk9SID0geyBlcnJvcjogbnVsbCB9O1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIFRSWV9DQVRDSF9FUlJPUi5lcnJvcik7XG4gICAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdm9pZCAwLFxuICAgICAgZmFpbGVkID0gdm9pZCAwO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsb2JhbC93aW5kb3cuanNcbi8vIG1vZHVsZSBpZCA9IDQwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbnZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xudmFyIGRvbnRFbnVtcyA9IFtcblx0J3RvU3RyaW5nJyxcblx0J3RvTG9jYWxlU3RyaW5nJyxcblx0J3ZhbHVlT2YnLFxuXHQnaGFzT3duUHJvcGVydHknLFxuXHQnaXNQcm90b3R5cGVPZicsXG5cdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdCdjb25zdHJ1Y3Rvcidcbl07XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xufTtcbnZhciBleGNsdWRlZEtleXMgPSB7XG5cdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHQkY29uc29sZTogdHJ1ZSxcblx0JGV4dGVybmFsOiB0cnVlLFxuXHQkZnJhbWU6IHRydWUsXG5cdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdCRmcmFtZXM6IHRydWUsXG5cdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0JGlubmVyV2lkdGg6IHRydWUsXG5cdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0JG91dGVyV2lkdGg6IHRydWUsXG5cdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHQkcGFyZW50OiB0cnVlLFxuXHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0JHNjcm9sbFg6IHRydWUsXG5cdCRzY3JvbGxZOiB0cnVlLFxuXHQkc2VsZjogdHJ1ZSxcblx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHQkd2luZG93OiB0cnVlXG59O1xudmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59KCkpO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHR9XG5cblx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGVLZXlzO1xufTtcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0cmV0dXJuIChPYmplY3Qua2V5cyhhcmd1bWVudHMpIHx8ICcnKS5sZW5ndGggPT09IDI7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vYmplY3Qta2V5cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNDA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==